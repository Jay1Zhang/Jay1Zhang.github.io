<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「算法入门」《算法笔记》 C/C++ 程序设计手册 | J1z's Blog</title><meta name="keywords" content="Algorithm"><meta name="author" content="Jay"><meta name="copyright" content="Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作「算法入门手册」使用。如需「进阶版」请移步「算法思想」系列。 0x00 C&#x2F;C++ 程序设计基础1#include&lt;bits&#x2F;stdc++.h&gt;   黑盒测试大部分在线评测系统都采用多点测试的方式，即将所有输入数据放在一个文件里，系统会让程序去读">
<meta property="og:type" content="article">
<meta property="og:title" content="「算法入门」《算法笔记》 C&#x2F;C++ 程序设计手册">
<meta property="og:url" content="http://jay1zhang.github.io/2021/03/05/Computer%20Science/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="J1z&#39;s Blog">
<meta property="og:description" content="本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作「算法入门手册」使用。如需「进阶版」请移步「算法思想」系列。 0x00 C&#x2F;C++ 程序设计基础1#include&lt;bits&#x2F;stdc++.h&gt;   黑盒测试大部分在线评测系统都采用多点测试的方式，即将所有输入数据放在一个文件里，系统会让程序去读">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/020.jpg">
<meta property="article:published_time" content="2021-03-05T00:53:51.000Z">
<meta property="article:modified_time" content="2021-04-02T07:49:56.808Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/020.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jay1zhang.github.io/2021/03/05/Computer%20Science/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKEK6XV2V5","apiKey":"e093fbb9f29fdf5c7ddd56ec43e9ae05","indexName":"Jay","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-02 15:49:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/020.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1z's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「算法入门」《算法笔记》 C/C++ 程序设计手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-05T00:53:51.000Z" title="Created 2021-03-05 08:53:51">2021-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-04-02T07:49:56.808Z" title="Updated 2021-04-02 15:49:56">2021-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Science/">Computer Science</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Science/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">28.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>104min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作<strong>「算法入门手册」</strong>使用。如需「进阶版」请移步<strong>「算法思想」</strong>系列。</p>
<h2 id="0x00-C-C-程序设计基础"><a href="#0x00-C-C-程序设计基础" class="headerlink" title="0x00 C/C++ 程序设计基础"></a>0x00 C/C++ 程序设计基础</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>


<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>大部分在线评测系统都采用<strong>多点测试</strong>的方式，即将所有输入数据放在一个文件里，系统会让程序去读取这个文件，然后执行程序并输出结果。因此必须保证程序能够反复执行代码的核心部分，这就要用到循环。</p>
<p><strong>（1）while(T–) 型</strong></p>
<p>给定了测试数据的组数，因此只需要用一个变量T来存储，并在程序开始时读入即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）while…EOF 型</strong></p>
<p>没有给定测试数据的组数，因此需要反复读取，直至文件末尾。</p>
<ul>
<li>scanf 函数的返回值为其成功读入的参数的个数，当读到文件末尾时，scanf 函数会返回 -1，即 EOF。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="0x01-算法入门专题"><a href="#0x01-算法入门专题" class="headerlink" title="0x01 算法入门专题"></a>0x01 算法入门专题</h2><ul>
<li>字符串专题</li>
<li>数学专题</li>
</ul>
<h3 id="1-表达式计算问题"><a href="#1-表达式计算问题" class="headerlink" title="1. 表达式计算问题"></a>1. 表达式计算问题</h3><p>对于一般形式的表达式，通常称为中缀表达式（infix）。但这种表达式在计算时面临的主要问题有：</p>
<ol>
<li><p>运算符有优先级</p>
</li>
<li><p>括号会改变计算的次序</p>
</li>
</ol>
<p>为了方便表达式的（计算机）计算，波兰数学家发明了一种将运算符写在操作数之后的表达式表示方式，称为后缀表达（postfix），或逆波兰表示。</p>
<table>
<thead>
<tr>
<th align="center">中缀表达式</th>
<th align="center">后缀表达式（RPN）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a + b</td>
<td align="center">a b +</td>
</tr>
<tr>
<td align="center">a + b * c</td>
<td align="center">a b c * +</td>
</tr>
<tr>
<td align="center">a + b * c + ( d * e + f ) / g</td>
<td align="center">a b c * + d e * f + g * +</td>
</tr>
</tbody></table>
<h4 id="1）中缀表达式计算"><a href="#1）中缀表达式计算" class="headerlink" title="1）中缀表达式计算"></a>1）中缀表达式计算</h4><p><strong>【中缀到后缀】</strong></p>
<p>从左至右遍历中缀表达式中每个数字和符号：</p>
<ul>
<li>若是数字直接输出，即成为后缀表达式的一部分；</li>
<li>若是符号：<ul>
<li>若是)，则将栈中元素弹出并输出，直到遇到“(”， “(”弹出但不输出；</li>
<li>若是(，+，* 等符号，则从栈中弹出并输出优先级高于当前的符号，直到遇到一个优先级低的符号；然后将当前符号压入栈中。（优先级+，-最低，*，/次之，“(”最高）</li>
</ul>
</li>
<li>遍历结束，将栈中所有元素依次弹出，直到栈为空。</li>
</ul>
<p><strong>【后缀表达式计算】</strong></p>
<p>从左至右遍历后缀表达式中每个数字和符号：</p>
<ul>
<li><p>若是数字直接进栈；</p>
</li>
<li><p>若是运算符（+，-，*，/），则从栈中弹出两个元素进行计算（注意：后弹出的是左运算数）。</p>
</li>
<li><p>遍历结束，将计算结果从栈中弹出（栈中应只有一个元素，否则表达式有错）。</p>
</li>
</ul>
<p><strong>【伪代码】</strong></p>
<p>实际上，对于上述问题我们没有必要像编译程序那样先将中缀表达式转换为后缀表达式，然后再进行计算，而是可以同时进行。</p>
<p>为此，可设两个栈，一个为<strong>数据栈</strong>，另一个为<strong>运算符栈</strong>，主要思路为：</p>
<ul>
<li>当一个运算符出栈时，即与数据栈中的数据进行相应计算，计算结果仍存至数据栈中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isOper</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isLbrkt</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27;(&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isRbrkt</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27;)&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getPrior</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prior;</span><br><span class="line">	<span class="keyword">switch</span>(c) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">			prior = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">			prior = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">			prior = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			prior = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num, oper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popAndCalc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> expr = <span class="string">&quot;24/(1+2+36/6/2-2)*(12/2/2)&quot;</span>;	<span class="comment">// =18</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expr.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(isDigit(expr[i])) &#123;</span><br><span class="line">			<span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(isDigit(expr[i])) &#123;</span><br><span class="line">				d *= <span class="number">10</span>;</span><br><span class="line">				d += expr[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			num.push(d);</span><br><span class="line">			i--;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOper(expr[i])) &#123; <span class="comment">// 运算符</span></span><br><span class="line">			<span class="keyword">while</span>(!oper.empty() &amp;&amp; !isLbrkt(oper.top())) &#123;	<span class="comment">// 非空且非左括号 </span></span><br><span class="line">				<span class="keyword">if</span>(getPrior(oper.top()) &lt; getPrior(expr[i])) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 若栈顶元素优先级大于当前元素，则弹栈，并计算 </span></span><br><span class="line">				popAndCalc();</span><br><span class="line">			&#125;</span><br><span class="line">			oper.push(expr[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLbrkt(expr[i])) &#123;</span><br><span class="line">			oper.push(expr[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(isRbrkt(expr[i])) &#123;</span><br><span class="line">			<span class="keyword">while</span>(!isLbrkt(oper.top())) &#123;	<span class="comment">// 非左括号，则弹栈并计算 </span></span><br><span class="line">				popAndCalc();</span><br><span class="line">			&#125;</span><br><span class="line">			oper.pop();	<span class="comment">// 弹出左括号 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!oper.empty()) &#123;	<span class="comment">// 符号栈非空，则弹栈并计算 </span></span><br><span class="line">		popAndCalc();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num.top()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popAndCalc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 不检验操作是否正确，只是弹栈并计算 </span></span><br><span class="line">	<span class="keyword">int</span> op = oper.top(); oper.pop();</span><br><span class="line">	<span class="keyword">int</span> d2 = num.top();  num.pop(); </span><br><span class="line">	<span class="keyword">int</span> d1 = num.top();  num.pop();</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">switch</span>(op) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: res = d1 + d2; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: res = d1 - d2; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: res = d1 * d2; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: res = d1 / d2; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	num.push(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2）后缀表达式转中缀表达式"><a href="#2）后缀表达式转中缀表达式" class="headerlink" title="2）后缀表达式转中缀表达式"></a>2）后缀表达式转中缀表达式</h4><p>后缀表达式的特点是：一定以两个操作数开始，且以操作符结尾，形如“a b + c d e + * *”就是一个后缀表达式。</p>
<p>基于这个特性，我们可以从左到右遍历，以此构建<strong>表达式树</strong>。</p>
<blockquote>
<p>表达式树的特点就是：<strong>树的树叶是操作数（常数或变量），而其他节点为操作符</strong>。</p>
<p>由于一般的操作符都是二元的，所以表达式树一般的都是二叉树。</p>
</blockquote>
<p>表达式树的建立过程，与<strong>哈密顿树</strong>十分类似，逐个读取后缀表达式的每个符号：</p>
<ul>
<li>如果符号是操作数，那么我们就建立一个单节点树并将一个指向它的指针压入栈中；</li>
<li>如果符号是操作符，则从栈中弹出两棵树T2和T1，并形成一颗以操作符为根的树，其中T1为左儿子，T2为右儿子；</li>
<li>然后将新的树压入栈中，继续上述过程。</li>
</ul>
<p>其具体过程可以参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26849233/article/details/72910010">这篇博客</a>。</p>
<p><strong>【伪代码】</strong></p>
<ul>
<li>注：目前尚未优化括号。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isSpace</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isOper</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">char</span> op;</span><br><span class="line">	<span class="keyword">bool</span> isLeaf;	<span class="comment">// 1: data  0: op</span></span><br><span class="line">	Node *lchild, *rchild;</span><br><span class="line">	</span><br><span class="line">	Node() &#123;&#125;</span><br><span class="line">	Node(<span class="keyword">int</span> _data) &#123;</span><br><span class="line">		data = _data;</span><br><span class="line">		isLeaf = <span class="literal">true</span>;</span><br><span class="line">		lchild = rchild = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node(<span class="keyword">char</span> _op, Node *_lchild, Node *_rchild) &#123;</span><br><span class="line">		op = _op;</span><br><span class="line">		isLeaf = <span class="literal">false</span>;</span><br><span class="line">		lchild = _lchild;</span><br><span class="line">		rchild = _rchild;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!root-&gt;isLeaf) <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	inOrder(root-&gt;lchild);</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;isLeaf) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;data);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;op);</span><br><span class="line">	&#125;</span><br><span class="line">	inOrder(root-&gt;rchild);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!root-&gt;isLeaf) <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	postOrder(root-&gt;lchild);</span><br><span class="line">	postOrder(root-&gt;rchild);</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;isLeaf) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;data);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;op);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// a b + c d e + * *	-&gt;		a + b x (c x (d + e)) </span></span><br><span class="line">	<span class="comment">// 1 2 + 3 4 5 + * *	-&gt;		(1+2)x3x(4+5))=81</span></span><br><span class="line">	<span class="built_in">string</span> expr = <span class="string">&quot;10 2 + 3 4 5 + * *&quot;</span>;</span><br><span class="line">	<span class="comment">// 1. 处理后缀表达式，构建树结点 </span></span><br><span class="line">	<span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expr.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(isSpace(expr[i])) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(isDigit(expr[i])) &#123;</span><br><span class="line">			<span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(isDigit(expr[i])) &#123;</span><br><span class="line">				d *= <span class="number">10</span>;</span><br><span class="line">				d += expr[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			s.push(<span class="keyword">new</span> Node(d));</span><br><span class="line">			i--;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;	<span class="comment">// 运算符 </span></span><br><span class="line">			Node *t2 = s.top(); s.pop();</span><br><span class="line">			Node *t1 = s.top(); s.pop();</span><br><span class="line">			Node *op = <span class="keyword">new</span> Node(expr[i], t1, t2);</span><br><span class="line">			s.push(op);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 建树，并输出中缀表达式 </span></span><br><span class="line">	Node *root = s.top();</span><br><span class="line">	inOrder(root);		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//postOrder(root);	printf(&quot;\n&quot;);	</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3. 优化中缀表达式的括号</span></span><br><span class="line">	<span class="comment">// 比较复杂，暂略 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>关于<strong>括号优化</strong>，实际上，只有当当前结点为加法运算符且父结点为乘法运算符时，才需要加括号。</p>
<p>因此可得如下前序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node *root, <span class="keyword">bool</span> lastIsMult)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;isLeaf) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;data);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分支节点 </span></span><br><span class="line">	<span class="keyword">bool</span> isMult = isMultOper(root-&gt;op);</span><br><span class="line">	<span class="keyword">if</span>(lastIsMult &amp;&amp; !isMult) <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);	<span class="comment">// 上一层是乘法运算符，而这一层是加法运算符 </span></span><br><span class="line">		</span><br><span class="line">	inOrder(root-&gt;lchild, isMult);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;op);</span><br><span class="line">	inOrder(root-&gt;rchild, isMult);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(lastIsMult &amp;&amp; !isMult) <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="2-字符串匹配问题"><a href="#2-字符串匹配问题" class="headerlink" title="2. 字符串匹配问题"></a>2. 字符串匹配问题</h3><p>给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> t = <span class="string">&quot;ABCDABD&quot;</span>;</span><br></pre></td></tr></table></figure>


<p><strong>【暴力解法】</strong></p>
<p>在字符串匹配中，最自然的做法就是，用两个指针i 和j 分别指向待匹配串s 和匹配串t ，每次遇到一个不匹配的字符时，j 都要重头开始遍历，表现在代码上如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pattern</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length(), len2 = t.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j]) &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;	<span class="comment">// i回到开始匹配的那一位的下一位</span></span><br><span class="line">            j = <span class="number">0</span>;			<span class="comment">// j回到0，重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == len2) &#123;		<span class="comment">// 匹配成功</span></span><br><span class="line">        	res.push_back(i - j);</span><br><span class="line">            j = <span class="number">0</span>;			<span class="comment">// j回到0，往下接着匹配 </span></span><br><span class="line">            <span class="comment">// 根据题目要求决定i是否需要回溯</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;	<span class="comment">// i回到开始匹配的那一位的下一位，这样能保证ABABA里能找到两个ABA </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>【KMP算法】</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法 - 阮一峰的网络日志</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/daaikuaichuan/article/details/80719203">字符串算法之KMP（字符串匹配）</a></li>
</ul>
<p>在继续下面的内容之前，有必要在这里介绍下两个概念：<strong>真前缀</strong> 和 <strong>真后缀</strong>。</p>
<ul>
<li>字符串：china</li>
<li>真前缀：c, ch, chi, chin</li>
<li>真后缀：hina, ina, na, a</li>
</ul>
<p>前面的暴力解法忽略了一个基本事实：</p>
<ul>
<li><p>当i与j指向的串不匹配时，其实我们已经知道了<strong>指针 i 前面的长度为 j 的串，一定是t的某个真前缀</strong>。 </p>
</li>
<li><p>我们设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。</p>
<blockquote>
<p>如果这个真前缀中的某个真后缀，与t的某个真前缀相匹配，我们就可以直接从这个位置开始匹配，而不用每次都从头开始了。</p>
<p>（这里说的有点绕，但具体思想就是这样，如果不太懂可以参考上面的链接。）</p>
</blockquote>
</li>
</ul>
<p>具体做法就是设置一个跳转数组 <code>next</code> ：</p>
<ul>
<li><p>next数组的求解基于串 t 的“真前缀”和“真后缀”，即 <code>next[j]</code> 等于 t[0]…t[j - 1] <strong>最长的相同真前后缀的长度</strong> 。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210321102459219.png" alt="image-20210321102459219" style="zoom:80%;" /> 



</li>
</ul>
<p>因此，剩余的工作就是求解 <code>next</code> 数组，并利用这个数组进行匹配了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcNext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;t, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = t.length();</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">			k++, j++;</span><br><span class="line">			next[j] = k;	<span class="comment">// 表示串t的前j-1个字符有k个匹配 </span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">KMP</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="comment">// 计算next数组 </span></span><br><span class="line">	<span class="keyword">int</span> len1 = s.length(), len2 = t.length();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(len2)</span></span>;</span><br><span class="line">	calcNext(t, next);</span><br><span class="line">	<span class="comment">// 模式匹配</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(j == <span class="number">-1</span> || s[i] == t[j]) &#123;</span><br><span class="line">    		i++, j++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j];	<span class="comment">// 当前字符匹配失败，直接从next[j]开始比较，i的位置不变 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j == len2) &#123;	<span class="comment">// 匹配成功</span></span><br><span class="line">        	res.push_back(i - j);</span><br><span class="line">            j = <span class="number">0</span>;		<span class="comment">// j回到0，往下接着匹配 </span></span><br><span class="line">            <span class="comment">// 根据题目要求决定i是否需要回溯</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;	<span class="comment">// i回到开始匹配的那一位的下一位，这样能保证ABABA里能找到两个ABA </span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>【总结】</strong></p>
<p>通过观察上面的代码会发现，暴力解法与KMP算法的不同之处仅在于：</p>
<ul>
<li>当字符匹配失败时，暴力解法的 i 需要回溯到开始匹配的那一位的下一位，j回溯到0 ；而KMP算法的 i 是不需要回溯的，j 回溯到 next[j] 的位置。 </li>
</ul>
<p>需要注意的是，当匹配完整个串时，根据题目要求决定直接返回还是继续寻找：</p>
<ul>
<li>如果选择继续寻找，则 i 和 j 都需要回溯。考虑从 “ABABA” 中匹配 “ABA”  ，如果不回溯i，将会导致只能匹配到一个 “ABA”。</li>
</ul>
<h3 id="3-快速线性筛法求素数"><a href="#3-快速线性筛法求素数" class="headerlink" title="3. 快速线性筛法求素数"></a>3. 快速线性筛法求素数</h3><p>素数即质数，线性筛法求素数，其<strong>基本思想</strong>为：</p>
<ul>
<li>用一个数组 $a$ 来标记自然数，$a[i]$ 为1表示自然数 $i$ 为合数，为0表示为素数。</li>
<li>初始时，我们认为所有自然数都是素数，然后从2开始遍历，<strong>每轮筛掉一批合数</strong>，直到n为止。</li>
<li>至此，我们就得到了从2-n的所有素数。</li>
</ul>
<p>那么如何筛除合数呢？最朴素的做法是：</p>
<ul>
<li>当前数 i 的所有倍数均为合数，即 2i, 3i, 4i, …, ki，直到 ki &gt; n。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000007</span>;</span><br><span class="line"><span class="keyword">bool</span> num[MAXN] = &#123;<span class="number">0</span>&#125;;		<span class="comment">// 0: 素数，1: 合数 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!num[i]) &#123;	<span class="comment">// 素数 </span></span><br><span class="line">    		prime.push_back(i);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+i; j &lt;= n; j+=i) &#123;</span><br><span class="line">			num[j] = <span class="number">1</span>;	<span class="comment">// 合数 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这种做法是把当前数的所有倍数都标记为合数，显然这一定会有很多冗余，那如何改进呢？</p>
<ul>
<li><p>我们不再遍历所有倍数，而是标记当前数 $i$ 与 （目前为止找到的）所有质数 $prime[0]$ ~  $prime[j]$ 的乘积。</p>
</li>
<li><p>这种求素数的算法很容易被理解，但是也存在<strong>缺陷</strong>：</p>
<ul>
<li>对于一个数30，可分解为 $30=2<em>15=3</em>10=5*6$，显然，当循环2,3,5,6,10,15时都会筛除一次30这个数，而当n很大时，就会出现许多的冗余操作。</li>
</ul>
</li>
</ul>
<p>为了提高效率，<strong>快速线性筛法</strong>的算法应运而生，其<strong>核心思想</strong>在于：</p>
<ul>
<li>当 $i \ % \ prime[j] == 0$ 时，就break掉，继续遍历下一个自然数。</li>
</ul>
<blockquote>
<p>举个例子，对于一个数9，9 * 2 = 18 将18标记为合数，循环继续； 9 * 3 = 27 将27标记为合数，此时发现 9 % 3 = 0，循环退出。</p>
<p>如果将循环继续下去会出现筛除9 * 5 = 45的情况，而45 = 15 * 3，在15时会被在筛去一次。</p>
</blockquote>
<p><strong>【伪代码】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000007</span>;</span><br><span class="line"><span class="keyword">bool</span> num[MAXN] = &#123;<span class="number">0</span>&#125;;		<span class="comment">// 0: 素数，1: 合数 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!num[i]) &#123;	<span class="comment">// 素数 </span></span><br><span class="line">    		prime.push_back(i);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i * prime[j] &lt;= n) &#123;</span><br><span class="line">				num[i * prime[j]] = <span class="literal">true</span>;	<span class="comment">// 合数 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 核心代码：剪枝，保证每个合数只会被它的最小质因数筛去</span></span><br><span class="line">			<span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="0x02-C-标准模板库（STL）"><a href="#0x02-C-标准模板库（STL）" class="headerlink" title="0x02 C++ 标准模板库（STL）"></a>0x02 C++ 标准模板库（STL）</h2><p>C++中为使用者提供了标准模板库（Standard Template Library，STL），其中封装了很多相当实用的容器，且定义与常用函数大同小异，在使用时都需要在宏定义下加上一句  <code>using namespace std;</code> 。</p>
<p>下面介绍一些较为常用的几个。</p>
<h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h3><p>vector翻译为向量，但这里使用「动态数组」的叫法更容易理解，作用类似于 Java 中的 <code>ArrayList</code>。</p>
<p>使用vector需要添加头文件 <code>#include&lt;vector&gt;</code> ，此外，还需要加上一句 <code>using namespace std;</code> 。</p>
<h4 id="1）vector的定义与初始化"><a href="#1）vector的定义与初始化" class="headerlink" title="1）vector的定义与初始化"></a>1）vector的定义与初始化</h4><p>单独定义一个 vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>
<p>typename 可以是基本类型（int、double、char、结构体），也可以是STL模板（vector、set、queue）。</p>
<p><strong>（1）不带参数的构造函数初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个size为0的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc;</span><br></pre></td></tr></table></figure>
<p><strong>（2）带参数的构造函数初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">abc</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">//初始化了10个默认值为0的元素</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cde</span><span class="params">(<span class="number">10</span>，<span class="number">1</span>)</span></span>;    <span class="comment">//初始化了10个值为1的元素</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）通过数组地址初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>（4）通过同类型的vector初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//通过a初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>（5）通过insert初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">6</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">vecot&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a[0]~a[2]插入到b中，b.size()由0变为3</span></span><br><span class="line">b.insert(b.begin(), a.begin(), a.begin() + <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>insert也可通过数组地址区间实现插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a的所有元素插入到b中，同样是左闭右开区间</span></span><br><span class="line">b.insert(b.begin(), a, a+<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>此外，insert还可以插入m个值为n的元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在b开始位置处插入6个6</span></span><br><span class="line">b.insert(b.begin(), <span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>


<h4 id="2）vector容器内元素的访问"><a href="#2）vector容器内元素的访问" class="headerlink" title="2）vector容器内元素的访问"></a>2）vector容器内元素的访问</h4><p>vector一般由两种访问方式：</p>
<p><strong>（1）通过下标访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi[index];</span><br></pre></td></tr></table></figure>


<p><strong>（2）通过迭代器访问</strong></p>
<p>迭代器（iterator）可以理解为一种类似指针的东西，定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;::iterator it = vi.begin();	<span class="comment">// begin()为vi的首元素地址</span></span><br></pre></td></tr></table></figure>
<p>易知 <code>vi[i]</code> 和 <code>vi.begin() + i</code> 是的等价的。</p>
<p>需要注意的是，<code>end()</code> 并不是 <code>vi</code> 的尾元素地址，而是<strong>尾元素的下一个地址</strong>。在 C++ 中，这种<strong>「左闭右开」</strong>的思维很常见，务必注意。</p>
<h4 id="3）vector常用函数"><a href="#3）vector常用函数" class="headerlink" title="3）vector常用函数"></a>3）vector常用函数</h4><p><strong>（1）push_back()</strong></p>
<p>顾名思义，<code>push_back(x)</code> 就是在 vector 后面添加一个元素 x，时间复杂度为 $O(1)$ 。</p>
<p><strong>（2）pop_back()</strong></p>
<p><code>pop_back()</code> 用于删除 vector 的尾元素， 时间复杂度为 $O(1)$ 。</p>
<p><strong>（3）size()</strong></p>
<p><code>size()</code> 用来获得 vector 中元素的个数， 时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）clear()</strong></p>
<p><code>clear()</code> 用来清空 vector 中的所有元素， 时间复杂度为 $O(N)$ 。</p>
<p><strong>（5）insert()</strong></p>
<p><code>insert(it, x)</code> 用来向 vector 的任意迭代器 it 处插入一个元素 x， 时间复杂度为 $O(N)$ 。</p>
<p><strong>（6）erase()</strong></p>
<ul>
<li>删除单个元素：<code>erase(it)</code> 即删除迭代器为 it 处的元素。</li>
<li>删除一个区间内的所有元素：<code>erase(first, last)</code> 即删除 <strong>[first, last)</strong> 区间内的所有元素。</li>
</ul>
<h3 id="2-set"><a href="#2-set" class="headerlink" title="2. set"></a>2. set</h3><p>set翻译为集合，是一个<strong>内部自动有序</strong>且<strong>不含重复元素</strong>的容器。</p>
<ul>
<li><p>使用set需要添加头文件 <code>#include&lt;set&gt;</code> 及 <code>using namespace std;</code> 。</p>
</li>
<li><p>set的定义及常见用法与vector大同小异，因此略。</p>
</li>
</ul>
<h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p>在 C 语言中，一般使用字符数组 <code>char str[]</code> 来存放字符串，为了方便字符串操作，C++ 在 STL 中对 string 类型进行了封装。</p>
<p>使用 string 需要添加头文件 <code>#include&lt;string&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）string的定义"><a href="#1）string的定义" class="headerlink" title="1）string的定义"></a>1）string的定义</h4><p>定义string的方式与基本类型相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br></pre></td></tr></table></figure>
<p>如果要初始化，可直接赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="2）string-中内容的访问"><a href="#2）string-中内容的访问" class="headerlink" title="2）string 中内容的访问"></a>2）string 中内容的访问</h4><p><strong>（1）通过下标访问</strong></p>
<ul>
<li><p>一般来说，可以直接像字符数组那样访问 string，即 <code>str[i]</code> ；</p>
</li>
<li><p>如果要读入和输出<strong>整个字符串</strong>，则只能使用 <code>cin</code> 和 <code>cout</code> 。但实际上也能使用 <code>c_str()</code> 将string类型转换为字符数组再进行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str.c_str());</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>（2）通过迭代器访问</strong></p>
<p>一般仅通过（1）即可满足访问的要求，但是有些函数比如 <code>insert()</code> 和 <code>erase()</code> 则要求以迭代器为参数，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it;</span><br></pre></td></tr></table></figure>


<h4 id="3）string常用函数示例解析"><a href="#3）string常用函数示例解析" class="headerlink" title="3）string常用函数示例解析"></a>3）string常用函数示例解析</h4><p><strong>（1）operator+=</strong></p>
<p>这是string的加法，可以直接将两个 string 拼接起来。</p>
<p><strong>（2）compare operator</strong></p>
<p>两个 string 类型可以直接使用 ==、!=、&lt;、&lt;=、&gt;、&gt;= 比较大小，比较规则是<strong>字典序</strong>。 </p>
<p><strong>（3）length() / size()</strong></p>
<p>返回 string 的长度，即存放的字符数，时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）insert()</strong></p>
<ul>
<li><p><code>insert(pos, string)</code> ： pos 位置插入字符串 string。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.insert(<span class="number">3</span>, str2);</span><br></pre></td></tr></table></figure></li>
<li><p><code>insert(it, it2, it3)</code> ：it 为原字符串的欲插入位置，it2 和 it3为待插字符串的首尾迭代器，表示串 [it2, it3) 将被插在 it 位置上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.insert(str.begin()+<span class="number">3</span>, str2.begin(), str2.end());	<span class="comment">// 把str2插入在str的3号位上</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>（5）erase()</strong></p>
<ul>
<li>删除单个元素：<code>str.erase(it)</code> </li>
<li>删除一个区间内的所有元素：<ol>
<li><code>str.erase(first, last)</code> ，即删除 [first, last) </li>
<li><code>str.erase(pos, length)</code> ，其中 pos 为需要开始删除的起始位置，length为删除的字符个数。 </li>
</ol>
</li>
</ul>
<p><strong>（6）clear()</strong></p>
<p>clear() 用于清空 string 中的数据，时间复杂度一般为 $O(1)$ 。</p>
<p><strong>（7）substr()</strong></p>
<p><code>substr(pos, len)</code> 返回从 pos 号位开始、长度为 len 的子串，时间复杂度为 $O(len)$ 。</p>
<p><strong>（8）find()</strong></p>
<p><code>str.find(str2)</code> ：</p>
<ul>
<li><p>当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置；</p>
</li>
<li><p>否则，返回 <code>string::npos</code> 。</p>
<p><code>string::npos</code> 是一个常数，其本身的值为 -1 或者 unsigned_int 的最大值，用以作为 find 函数失配时的返回值。</p>
</li>
</ul>
<p><strong>（9）replace()</strong></p>
<ul>
<li><code>str.replace(pos, len, str2)</code> 把 str 从 pos 号位开始、长度为 len 的子串替换为 str2；</li>
<li><code>str.replace(it1, it2, str2)</code>  把 str 的迭代器 [it1, it2) 范围的子串替换为 str2。</li>
</ul>
<h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map"></a>4. map</h3><p>map翻译为映射，可以将<strong>任何基本类型（包括STL容器）</strong>映射到<strong>任何基本类型（包括STL容器）</strong>。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;map&gt;</code> 及 <code>using namespace std</code> 。</p>
<p>map 会<strong>以键从小到大的顺序自动排序</strong>，这是由于 map 内部是使用<strong>红黑树</strong>实现的（set也是），在建立映射的过程中会自动实现从小到大的排序功能。</p>
<h4 id="1）map的定义"><a href="#1）map的定义" class="headerlink" title="1）map的定义"></a>1）map的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1, typename2&gt; mp;</span><br></pre></td></tr></table></figure>


<h4 id="2）map容器内元素的访问"><a href="#2）map容器内元素的访问" class="headerlink" title="2）map容器内元素的访问"></a>2）map容器内元素的访问</h4><p><strong>（1）通过下标访问</strong></p>
<p>和访问普通数组是一样的，可以直接使用 <code>mp[&#39;c&#39;]</code> 来访问它对应的 value。</p>
<p><strong>（2）通过迭代器访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1, typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>通过 <code>it-&gt;first</code> 和 <code>it-&gt;second</code> 来分别访问键和值。 </p>
<h4 id="3）map常用函数"><a href="#3）map常用函数" class="headerlink" title="3）map常用函数"></a>3）map常用函数</h4><p><strong>（1）find()</strong></p>
<p><code>find(key)</code> 返回键为 key 的映射的迭代器，时间复杂度为 $O(logN)$ 。</p>
<p><strong>（2）erase()</strong></p>
<ul>
<li>删除单个元素：<code>mp.erase(it)</code> 或 <code>mp.erase(key)</code> </li>
<li>删除一个区间内的所有元素：<code>mp.erase(first, last)</code> ，同样为左闭右开区间 [first, last) </li>
</ul>
<p><strong>（3）size()</strong></p>
<p><code>size()</code> 用来获取 map 中映射的对数，时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）clear()</strong></p>
<p><code>clear()</code> 用来清空 map 中的所有元素，复杂度为 $O(N)$ 。</p>
<h3 id="5-queue"><a href="#5-queue" class="headerlink" title="5. queue"></a>5. queue</h3><p>queue 翻译为队列，在 STL 中作为一个<strong>先进先出</strong>的容器。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;queue&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）queue的定义"><a href="#1）queue的定义" class="headerlink" title="1）queue的定义"></a>1）queue的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）queue容器内元素的访问"><a href="#2）queue容器内元素的访问" class="headerlink" title="2）queue容器内元素的访问"></a>2）queue容器内元素的访问</h4><p>由于队列（queue）本身就是一种先进先出的限制性数据结构，因此在 STL 中只能通过 <code>front()</code> 来访问队首元素，或通过 <code>back()</code> 来访问队尾元素。</p>
<h4 id="3）queue常用函数"><a href="#3）queue常用函数" class="headerlink" title="3）queue常用函数"></a>3）queue常用函数</h4><p><strong>（1）front()、back()</strong></p>
<p><code>front()</code> 和 <code>back()</code> 分别获得队首元素和队尾元素。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 将 x 插入队尾。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop()</code> 令队首元素出队。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 检查 queue 是否为空。在使用 <code>front()</code> 和 <code>back()</code> 前，务必判断队列是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回 queue 内元素的个数。</p>
<h3 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6. priority_queue"></a>6. priority_queue</h3><p>priority_queue 又称为<strong>优先队列</strong>，其底层使用<strong>堆</strong>来实现的。在任何时候，队首元素一定是当前队列中优先级最高的那一个。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;queue&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）priority-queue的定义"><a href="#1）priority-queue的定义" class="headerlink" title="1）priority_queue的定义"></a>1）priority_queue的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）priority-queue容器内元素的访问"><a href="#2）priority-queue容器内元素的访问" class="headerlink" title="2）priority_queue容器内元素的访问"></a>2）priority_queue容器内元素的访问</h4><p>和队列（queue）不同的是，优先队列只能通过 <code>top()</code> 来访问<strong>队首元素</strong>（也可以说是<strong>堆顶元素</strong>）。</p>
<h4 id="3）priority-queue常用函数"><a href="#3）priority-queue常用函数" class="headerlink" title="3）priority_queue常用函数"></a>3）priority_queue常用函数</h4><p><strong>（1）top()</strong></p>
<p><code>top()</code> 可以获得队首元素（即堆顶元素）。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 令 x 入队，并自动调整底层数据结构，时间复杂度为 $O(logN)$。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop()</code> 令队首元素出队。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 检查优先队列是否为空。在使用 <code>front()</code> 和 <code>back()</code> 前，务必判断队列是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回优先队列内元素的个数。</p>
<h4 id="4）priority-queue内元素优先级的设置"><a href="#4）priority-queue内元素优先级的设置" class="headerlink" title="4）priority_queue内元素优先级的设置"></a>4）priority_queue内元素优先级的设置</h4><p><strong>（1）基本数据类型的优先级设置</strong></p>
<p>优先队列的<strong>默认优先级是数字大的优先级越高（大顶堆）</strong>，即下面两种优先队列的定义是<strong>等价</strong>的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>在第二种定义方式中，</p>
<ul>
<li><code>vector&lt;int&gt;</code> 表示承载底层数据结构堆（heap）的容器；</li>
<li><code>less&lt;int&gt;</code> 是对第一个参数的比较类，<code>less&lt;int&gt;</code> 表示<strong>数字大的优先级越大</strong>，<code>greater&lt;int&gt;</code> 表示<strong>数字小的优先级越大</strong>。</li>
</ul>
<p>如果想把最小的元素放在队首（小顶堆），则只需如下定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>


<p><strong>（2）结构体的优先级设置</strong></p>
<p>我们不妨对水果的名称和价格建议一个结构体。现在希望<strong>按水果的价格高的为优先级高</strong>，则需要<strong>重载（overload）小于号 “&lt;”</strong> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>friend</code> 为友元，<code>bool operator &lt; (fruit f1, fruit f2)</code> 则对 fruit 类型的操作符 “&lt;” 进行了重载。</p>
<blockquote>
<p>这里务必注意，如果再重载大于号会导致编译出错。因为从数学上来说，f1 &gt; f2 等价于判断 f2 &lt; f1，因此只需要重载小于号即可。</p>
</blockquote>
<p>此时就可以直接定义 fruit 类型的优先队列，其内部就是以价格高的水果为优先级高：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;fruit&gt; q;</span><br></pre></td></tr></table></figure>
<p>同理，如果想要<strong>以价格低的水果为优先级高</strong>，那么只需要把 return 中的<strong>小于号改成大于号</strong>即可，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;	<span class="comment">// 改为大于号，表示价格更低的优先级更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里重载大于号 “&gt;” 也可以，但在定义时就需要：</p>
<p>priority_queue&lt;fruit, vector<int>, greater<int>&gt; q;</p>
<p>因为默认的定义方式中，优先级比较函数为 <code>less&lt;int&gt;</code> ，即小于号 “&lt;”。</p>
</blockquote>
<p>不难注意到，这里<strong>重载小于号</strong>和排序函数 sort() 中的 cmp 函数有些相似，只是效果看上去似乎是“相反”的。</p>
<p>比如对于 <code>return f1.price &gt; f2.price</code> ：</p>
<ul>
<li><p>在排序中，是按价格从高到低排序；</p>
<blockquote>
<p>符合正常思维，价格越高，优先级越高（返回1），因而应排在前面，所以是<strong>从高到低</strong>排序。</p>
</blockquote>
</li>
<li><p>在优先队列中，却是把价格低的放到队首（堆顶）。</p>
</li>
</ul>
<h3 id="7-stack"><a href="#7-stack" class="headerlink" title="7. stack"></a>7. stack</h3><p>stack 翻译为栈，是 STL 中实现的一个<strong>后进先出</strong>的容器。</p>
<p>使用 stack 需要添加头文件 <code>#include&lt;stack&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）stack的定义"><a href="#1）stack的定义" class="headerlink" title="1）stack的定义"></a>1）stack的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）stack容器内元素的访问"><a href="#2）stack容器内元素的访问" class="headerlink" title="2）stack容器内元素的访问"></a>2）stack容器内元素的访问</h4><p>由于栈（stack）本身就是一种后进先出的限制性数据结构，因此在 STL 中只能通过 <code>top()</code> 来访问栈顶元素。</p>
<h4 id="3）stack常用函数"><a href="#3）stack常用函数" class="headerlink" title="3）stack常用函数"></a>3）stack常用函数</h4><p><strong>（1）top()</strong></p>
<p><code>top()</code> 获得栈顶元素，时间复杂度为 $O(1)$ 。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 将 x 入栈，时间复杂度 $O(1)$ 。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop(x)</code> 弹出栈顶元素，时间复杂度 $O(1)$ 。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 可以检查栈是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回 stack 内元素的个数。</p>
<h3 id="8-pair"><a href="#8-pair" class="headerlink" title="8. pair"></a>8. pair</h3><p>pair 是一个很实用的“小玩意”，当想要将两个元素绑定在一起作为一个合成元素、又不像因此定义结构体时，使用 pair 可以很方便地作为一个替代品。实际上，pair 可以看做一个内部有两个元素的结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    typeName1 first;</span><br><span class="line">    typeName2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 pair 需要添加头文件 <code>#include&lt;utility&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）pair的定义"><a href="#1）pair的定义" class="headerlink" title="1）pair的定义"></a>1）pair的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;typename1, typename2&gt; name;</span><br></pre></td></tr></table></figure>
<p>如果想在定义 pair 时进行初始化，只需跟上一个小括号即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, int&gt; p(&quot;haha&quot;, 5);</span><br></pre></td></tr></table></figure>
<p>如果想要在代码中临时构建一个pair，有如下两种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将类型定义写在前面，后面用小括号内两个元素的方式</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; (<span class="string">&quot;haha&quot;</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2. 使用自带的 make_pair 函数</span></span><br><span class="line"><span class="built_in">make_pair</span>(<span class="string">&quot;haha&quot;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<h4 id="2）pair中元素的访问"><a href="#2）pair中元素的访问" class="headerlink" title="2）pair中元素的访问"></a>2）pair中元素的访问</h4><p>按正常结构体的方式访问即可，<code>p.first</code> 或 <code>p.second</code> 。</p>
<h4 id="3）pair常用函数"><a href="#3）pair常用函数" class="headerlink" title="3）pair常用函数"></a>3）pair常用函数</h4><p>两个pair类型数据可以直接使用 ==、!=、&lt;、&lt;=、&gt;、&gt;= 比较大小，比较规则是先以 first 的大小作为标准，只有当 first 相等时才去判别 second 的大小。</p>
<h3 id="9-algorithm头文件下的常用函数"><a href="#9-algorithm头文件下的常用函数" class="headerlink" title="9. algorithm头文件下的常用函数"></a>9. algorithm头文件下的常用函数</h3><p>使用 algorithm 头文件，需要添加头文件 <code>#include&lt;algorithm&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1-基本运算函数"><a href="#1-基本运算函数" class="headerlink" title="1. 基本运算函数"></a>1. 基本运算函数</h4><ul>
<li><code>max(x, y)</code> 、<code>min(x, y)</code>：取 x 和 y 中的最大/小值，参数必须是两个，可以是浮点数。</li>
<li><code>abs(x)</code>：取绝对值，x 必须是整数，浮点型的绝对值可使用 <code>math.h</code> 下的 <code>fabs()</code> 函数。</li>
<li><code>swap(x, y)</code> ：交换 x 和 y 的值。</li>
</ul>
<h4 id="2-next-permutation"><a href="#2-next-permutation" class="headerlink" title="2. next_permutation()"></a>2. next_permutation()</h4><p><code>next_permutation()</code> ：给出一个序列在全排列中的<strong>下一个序列</strong>。</p>
<p>例如，当 n = 3 时的全排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>
<p>这样 231 的下一个序列就是 312。</p>
<p>对于下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(next_permutation(a, a+<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>


<h4 id="3-reverse"><a href="#3-reverse" class="headerlink" title="3. reverse()"></a>3. reverse()</h4><p><code>reverse(it1, it2)</code> ：将<strong>数组指针</strong>或<strong>容器的迭代器</strong>在 [it1, it2) 之间的元素进行反转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">reverse(a, a+<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 3, 2, 1, 0, 4, 5</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">reverse(str.begin() + <span class="number">2</span>, str.begin() + <span class="number">5</span>);</span><br><span class="line"><span class="comment">// abedcfg</span></span><br></pre></td></tr></table></figure>


<h4 id="4-fill"><a href="#4-fill" class="headerlink" title="4. fill()"></a>4. fill()</h4><p><code>fill()</code> 可以把数组或容器中的某一段区间赋为某个相同的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(a, a+<span class="number">5</span>, <span class="number">233</span>);	<span class="comment">// 将 a[0]~a[4]均赋值为233</span></span><br></pre></td></tr></table></figure>


<h4 id="5-lower-bound-和-upper-bound"><a href="#5-lower-bound-和-upper-bound" class="headerlink" title="5. lower_bound() 和 upper_bound()"></a>5. lower_bound() 和 upper_bound()</h4><p><code>lower_bound()</code> 和 <code>upper_bound()</code> 需要用在一个有序数组或容器中。</p>
<ul>
<li><p><code>lower_bound(first, last, val)</code> 用来寻找在数组或容器的 [first, last) 范围内<strong>第一个值大于等于 val</strong> 的元素的位置。</p>
</li>
<li><p><code>upper_bound(first, last, val)</code> 用来寻找在数组或容器的 [first, last) 范围内<strong>第一个值大于 val</strong> 的元素的位置。</p>
</li>
<li><p>如果是数组，则返回该位置的指针；如果是容器，返回该位置的迭代器。时间复杂度为 $O(log(last-first))$ 。</p>
</li>
</ul>
<p>显然，如果只是想要获得欲查元素的下标，就可以不使用临时指针，而<strong>直接令返回值减去数组首地址</strong>即可。</p>
<h4 id="6-sort"><a href="#6-sort" class="headerlink" title="6. sort()"></a>6. sort()</h4><p>顾名思义，<code>sort()</code> 就是用来排序的函数，它根据具体情形使用不同的排序方法，效率较高。</p>
<p>一般来说，不推荐使用 C 语言中的 <code>qsort()</code> 函数，原因是其用起来比较繁琐，涉及很多指针的操作。</p>
<p>而且 <code>sort()</code> 在实现中规避了经典快速排序中可能出现的会导致实际复杂度退化到 $O(n^2)$ 的极端情况。</p>
<h5 id="1）如何使用-sort-排序"><a href="#1）如何使用-sort-排序" class="headerlink" title="1）如何使用 sort 排序"></a>1）如何使用 sort 排序</h5><p>sort 函数的使用必须加上头文件 <code>#include&lt;algorithm&gt;</code> 和 <code>using namespace std;</code> ，其使用的方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(首元素地址， 尾元素地址的下一个地址， 比较函数（非必填）);</span><br></pre></td></tr></table></figure>
<p>当没有比较函数时，默认进行<strong>递增排序</strong>。</p>
<h5 id="2）如何实现比较函数-cmp"><a href="#2）如何实现比较函数-cmp" class="headerlink" title="2）如何实现比较函数 cmp"></a>2）如何实现比较函数 cmp</h5><p>比较函数 cmp 用来“告诉” sort 何时需要交换元素。</p>
<ul>
<li>当 <code>cmp(a, b)</code> 返回 true 时，表明 a 优先级高于 b，a 排在 b 的前面。</li>
</ul>
<p><strong>（1）基本数据类型数组的排序</strong></p>
<p>默认按照从小到大的顺序排序，如果想要从大到小排序，可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）结构体数组的排序</strong></p>
<p>现定义如下结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想先按 x 从大到小排序，但当 x 相等的情况下，按照 y 从小到大排序，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) </span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）容器的排序</strong></p>
<p>以 vector 为例，从大到小排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">sort(vi.begin(), vi.end(), cmp);	<span class="comment">// 对整个vector排序</span></span><br></pre></td></tr></table></figure>
<p>对于 string 来说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str[<span class="number">3</span>] = &#123;<span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aaa&quot;</span>&#125;</span><br><span class="line">sort(str, str + <span class="number">3</span>);		<span class="comment">// 将string型数组按字典序从大到小输出</span></span><br></pre></td></tr></table></figure>




<h2 id="0x03-数据结构专题"><a href="#0x03-数据结构专题" class="headerlink" title="0x03 数据结构专题"></a>0x03 数据结构专题</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p>栈（stack）是一种<strong>后进先出</strong>的数据结构。栈顶指针是<strong>始终指向栈的最上方元素</strong>的一个标记，通常记为 <code>TOP</code>。</p>
<p>栈的常见操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空操作，将栈顶指针置为-1，表示栈中没有元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TOP = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈内元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TOP + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TOP == <span class="number">-1</span>)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s[++TOP] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TOP--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[TOP];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>队列（queue）是一种<strong>先进先出</strong>的数据结构，队列总是从队尾加入元素，而从队首移除元素。一般来说，需要一个<strong>队首指针 front</strong> 来指向<strong>队首元素的前一个位置</strong>，而使用<strong>队尾指针 rear</strong> 来指向<strong>队尾元素</strong>。</p>
<p>队列的常见操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空操作，还原为初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    front = rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈内元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear - front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == rear)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入队，排在队尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q[++rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出队，移除队首</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    front++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取队首元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[front + <span class="number">1</span>];	<span class="comment">// 注意需要+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取队尾元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[rear];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><h4 id="1）链表的概念"><a href="#1）链表的概念" class="headerlink" title="1）链表的概念"></a>1）链表的概念</h4><p>按正常方式定义一个数组时，计算机会从内存中取出块<strong>连续的地址</strong>来存放给定长度的数组；而链表由若干个节点组成，且结点在内存中的存储位置通常是<strong>不连续</strong>的。</p>
<p>链表的结点一般由两部分构成，即数据域和指针域；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;	<span class="comment">// 数据域</span></span><br><span class="line">    node* next;		<span class="comment">// 指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2）为链表结点分配内存空间"><a href="#2）为链表结点分配内存空间" class="headerlink" title="2）为链表结点分配内存空间"></a>2）为链表结点分配内存空间</h4><p>使用malloc函数或new运算法为链表结点分配内存空间。</p>
<p><strong>（1）malloc 函数</strong></p>
<p>malloc 函数时C语言中 <code>stdlib.h</code> 头文件下用于申请动态内存的函数，返回类型是申请的同变脸类型的指针，基本用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">node* p = (node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br></pre></td></tr></table></figure>
<p><strong>（2）new运算符</strong></p>
<p>new 是C++中用来申请动态空间的运算符，其返回类型同样是申请的同变脸类型的指针，基本用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">node* p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure>
<p>可以看到 new 的写法比 malloc 要简洁许多，只需要 <strong>“new + 类型名”</strong> 即可分配一块该类型的内存空间。</p>
<p><strong>（3）内存泄露</strong></p>
<blockquote>
<p>C/C++语言的设计者认为，程序员完全有能力自己控制内存的分配与释放，因此把对内存的控制操作全部交给了程序员。</p>
</blockquote>
<p>内存泄露是指使用 malloc 和 new 开辟出来的内存空间在使用过后没有释放，导致其在程序结束之前始终占据该内存空间。</p>
<ol>
<li>free 函数对应 malloc 函数：<code>free(p)</code> ；</li>
<li>delete 运算符对应 new 运算符：<code>delete(p)</code> 。</li>
</ol>
<h4 id="3）链表的基本操作"><a href="#3）链表的基本操作" class="headerlink" title="3）链表的基本操作"></a>3）链表的基本操作</h4><p><strong>（1）创建链表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Array)</span> </span>&#123;</span><br><span class="line">    node *p, *pre, *head;</span><br><span class="line">    head = <span class="keyword">new</span> node;	<span class="comment">// 创建头结点</span></span><br><span class="line">    </span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;	<span class="comment">// 头结点不需要数据域，指针域初始为 NULL</span></span><br><span class="line">    pre = head;			<span class="comment">// 头结点不需要数据域，指针域初始为 NULL</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.size(); i++) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node;	<span class="comment">// 新建结点</span></span><br><span class="line">        p-&gt;data = Array[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next = p;	<span class="comment">// 前驱结点链接当前结点</span></span><br><span class="line">        pre = p;		<span class="comment">// 把pre设为p，作为下个结点的前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;		<span class="comment">// 返回头结点指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）查找元素</strong></p>
<p>链表的查询操作每次都需要从头开始，时间复杂度为为 $O(N)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(node* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;		<span class="comment">// 计数器</span></span><br><span class="line">    node* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == x) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）插入元素</strong></p>
<p>将 x 插入到第pos个位置上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* head, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        p = p-&gt;next;	<span class="comment">// 保证pos位置不越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    node* q = <span class="keyword">new</span> node;</span><br><span class="line">    q-&gt;data = x;</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（4）删除元素</strong></p>
<p>对链表来说，删除元素是指删除链表上所有值为给定的数x。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(node* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = head-&gt;next;</span><br><span class="line">    node* pre = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == x) &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(p);</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="4-树与二叉树"><a href="#4-树与二叉树" class="headerlink" title="4. 树与二叉树"></a>4. 树与二叉树</h3><h4 id="1）树的定义与性质"><a href="#1）树的定义与性质" class="headerlink" title="1）树的定义与性质"></a>1）树的定义与性质</h4><p><strong>（1）树的定义</strong></p>
<ul>
<li>树的<strong>层次（layer）</strong>从根结点开始算起，即根结点为第一层。</li>
<li>把结点的子树棵树称为结点的<strong>度（degree）</strong>，而树中结点最大的度称为树的度。<strong>叶子结点</strong>被定义为度为0的结点。</li>
<li>由于一条边连接两个结点，且树种不存在环，因此对有n个结点的树，边数一定是n-1。且<strong>满足连通、边数等于顶点数减1</strong>的结构一定是一棵树。</li>
<li>多棵树组合在一起称为<strong>森林（forest）</strong>，即森林是若干棵树的集合。</li>
</ul>
<p><strong>（2）二叉树的定义</strong></p>
<p>二叉树由根结点、左子树、右子树组成，且左子树和右子树都是二叉树。</p>
<p>注意区分<strong>二叉树</strong>与<strong>度为2的树</strong>的区别。</p>
<ul>
<li>度不同<ul>
<li>度为2的树要求每个节点<strong>最多</strong>只能有两棵子树，并且<strong>至少</strong>有一个节点有两棵子树。</li>
<li>二叉树的要求是度不超过2，节点最多有两个叉，可以是1或者0。</li>
</ul>
</li>
<li>次序不同<ul>
<li>度为2的树从形式上看与二叉树很相似，但它的子树是无序的，而二叉树是有序的。</li>
</ul>
</li>
</ul>
<p>在任意一棵二叉树中，<strong>度为0的结点（即叶子结点）总是比度为2的结点多一个</strong>。</p>
<p>下面介绍两种特殊的二叉树：</p>
<ol>
<li><strong>满二叉树</strong>：每一层的结点个数都达到了当层能达到的最大结点数。</li>
<li><strong>完全二叉树</strong>：<strong>除了最下面的一层外</strong>，其余层的结点个数都达到了当层能达到的最大结点数，且最下面一层只<strong>从左至右</strong>连续存在若干结点。</li>
</ol>
<h4 id="2）二叉树的存储结构与基本操作"><a href="#2）二叉树的存储结构与基本操作" class="headerlink" title="2）二叉树的存储结构与基本操作"></a>2）二叉树的存储结构与基本操作</h4><p><strong>（1）二叉树的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;	<span class="comment">// 数据域</span></span><br><span class="line">    node* lchild;	<span class="comment">// 指向左子树根结点的指针</span></span><br><span class="line">    node* rchild<span class="number">&#x27;</span>	<span class="comment">// 指向右子树根结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建结点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个新结点，v为结点权值</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;data = v;</span><br><span class="line">    Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;	<span class="comment">// 初始状态下没有左右孩子</span></span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）二叉树结点的查找、修改</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x, <span class="keyword">int</span> newdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == x) &#123;</span><br><span class="line">        root-&gt;data = newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(root-&gt;lchild, x, newdata);</span><br><span class="line">    search(root-&gt;rchild, x, newdata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）二叉树结点的插入</strong></p>
<p>结点的插入位置一般取决于数据域需要在二叉树中存放的位置，且对给定的结点来说，它在二叉树中的插入位置只会有一个。因此可以得到结论：<strong>二叉树结点的插入位置就是数据域在二叉树中查找失败的位置</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert函数将在二叉树中插入一个数据域为x的新结点</span></span><br><span class="line"><span class="comment">// 注意根结点指针root要使用引用，否则插入不会成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;		<span class="comment">// 空树，说明查找失败，也即插入位置（递归边界）</span></span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(由二叉树的性质，x应该插在左子树) &#123;</span><br><span class="line">        insert(root-&gt;lchild, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isnert(root-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很关键的一点是**根结点指针root使用了引用&amp;**。如果不使用引用，<code>root = new node</code> 这个语句对root的修改就无法作用到原变量上（即上一层的 <code>root-&gt;lchild</code> 与 <code>root-&gt;rchild</code>）上去，也就不能把新结点接到二叉树上面。</p>
<p><strong>（4）二叉树的创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;	</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（5）完全二叉树的存储结构</strong></p>
<p>对完全二叉树来说，除了采用二叉链表的存储结构歪，还有更方便的存储方法。</p>
<p>对一棵完全二叉树，如果给它的所有结点按<strong>从上到下、从左到右</strong>的顺序进行编号。</p>
<p>那么对完全二叉树当中的任何一个结点x，其左孩子的编号一定是2x，而右孩子的编号一定是2x+1。</p>
<h4 id="3）二叉树的遍历"><a href="#3）二叉树的遍历" class="headerlink" title="3）二叉树的遍历"></a>3）二叉树的遍历</h4><p>二叉树的遍历有四种：先序遍历、中序遍历、后序遍历，以及层次遍历。其中，前三种都是用DFS实现，而层次遍历一般用BFS实现。</p>
<p>对于前三种遍历方式，<strong>左子树一定先于右子树</strong>，且所谓的“先中后”都是指<strong>根结点root在遍历中的位置</strong>。</p>
<p><strong>（1）先序遍历</strong></p>
<p>先序遍历的顺序是 “ 根结点 → 左子树 → 右子树 ”。对于一棵二叉树的先序遍历序列，<strong>序列的第一个一定是根结点</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;		<span class="comment">// 到达空树，递归边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问根结点 root，例如将其数据域输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    preorder(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    preorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）中序遍历</strong></p>
<p>中序遍历的顺序是 “ 左子树 → 根结点 → 右子树 ”。因此，只要知道根结点，就可以<strong>通过根结点在中序遍历序列中的位置区分出左子树和右子树</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// 访问根结点 root，例如将其数据域输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p><strong>（3）后序遍历</strong></p>
<p>后序遍历的顺序是 “ 左子树 → 右子树 → 根结点”。对后序遍历来说，<strong>序列的最后一个一定是根结点</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    postorder(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    postorder(root-&gt;rchild);</span><br><span class="line">    <span class="comment">// 访问根结点 root，例如将其数据域输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>总的来说，<strong>必须知道中序遍历序列才能唯一地确定一棵树</strong>。因为只有通过中序遍历序列才能利用根结点把左右自述分开，从而递归生成一棵二叉树。</p>
<p><strong>（4）层序遍历</strong></p>
<p>层序遍历是指按层次的顺序<strong>从根结点向下逐层进行遍历，且对同一层的结点为从左到右遍历</strong>。这个过程和BFS很像，因为BFS进行搜索总是以广度作为第一关键词，而对应到二叉树中广度又恰好体现在层次上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;		<span class="comment">// 注意队列里存的是地址</span></span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node* now = q.front();	<span class="comment">// 取队首元素</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, now-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>) q.push(now-&gt;lchild);	<span class="comment">// 左子树非空</span></span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>) q.push(now-&gt;rchild);	<span class="comment">// 右子树非空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4）从遍历序列中重建二叉树"><a href="#4）从遍历序列中重建二叉树" class="headerlink" title="4）从遍历序列中重建二叉树"></a><strong>4）从遍历序列中重建二叉树</strong></h4><p><strong>【结论】</strong></p>
<p>中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树，而后三者两两搭配或是三个一起上都无法构建唯一的二叉树。</p>
<p><strong>【示例】</strong></p>
<p>假设已知先序序列为 pre1, pre2, …, pren，中序序列为 in1, in2, …, inn，重建这棵二叉树。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307102538238.png" alt="image-20210307102538238" style="zoom:70%;" />

<p>如上图所示，可以首先通过先序序列确定根结点，在由中序序列将其划分为左子树和右子树，得到左右子树的结点个数，进而能够在先序序列中划分出左右子树，并对左右子树递归进行上述操作即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前先序序列区间为 [preL, preR]，中序序列区间为 [inL, inR]，返回根结点地址</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">// 先序序列长度小于等于0时，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;		<span class="comment">// 新建根结点</span></span><br><span class="line">    root-&gt;data = pre[preL];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = inL; k &lt;= inR; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k] == pre[preL]) &#123;	<span class="comment">// 在中序序列中找到根结点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inL;		<span class="comment">// 左子树的结点个数</span></span><br><span class="line">    <span class="comment">// 左子树的先序区间为 [preL + 1, preL + numLeft]，中序区间为 [inL, k-1]</span></span><br><span class="line">    root-&gt;lchild = create(preL + <span class="number">1</span>, preL + numLeft, inL, k - <span class="number">1</span>);	<span class="comment">// 返回左子树的根结点</span></span><br><span class="line">    <span class="comment">// 右子树的先序区间为 [preL + numLeft + 1, preR]，中序区间为 [k + 1, inR]</span></span><br><span class="line">    root-&gt;rchild = create(preL + numLeft + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);	<span class="comment">// 返回左子树的根结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;		<span class="comment">// 返回根结点地址 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5）从树的遍历看-DFS-与-BFS"><a href="#5）从树的遍历看-DFS-与-BFS" class="headerlink" title="5）从树的遍历看 DFS 与 BFS"></a>5）从树的遍历看 DFS 与 BFS</h4><p><strong>（1）深度优先搜索与先序遍历</strong></p>
<p>事实上，对所有合法的DFS求解过程，都可以把它画成树的形式，此时<strong>死胡同等价于树中的叶子结点</strong>，而<strong>岔道口等价于树中的非叶子结点</strong>，并且对这棵树的<strong>DFS遍历过程就是树的先序遍历的过程</strong>。</p>
<p>在DFS过程中，提到过<strong>剪枝</strong>的概念，即对某条可以确定不存在解的子树采取直接剪断的策略，前提是要保证剪枝的正确性，否则可能因减掉了有解的子树而最终获得了错误的答案。</p>
<p><strong>（2）广度优先搜索与层序遍历</strong></p>
<p>事实上，对所有合法的BFS求解过程，都可以把它画成树的形式，并将其转换为<strong>树的层序遍历的问题</strong>。</p>
<h3 id="5-树的延伸算法"><a href="#5-树的延伸算法" class="headerlink" title="5. 树的延伸算法"></a>5. 树的延伸算法</h3><h4 id="1）二叉查找树（BST）"><a href="#1）二叉查找树（BST）" class="headerlink" title="1）二叉查找树（BST）"></a>1）二叉查找树（BST）</h4><p>二叉查找树（Binary Search Tree，BST）是一种特殊的二叉树，又称为二叉搜索树。其核心思想是：左子树上所有结点均小于等于根结点，右子树上所有结点均大于根结点。</p>
<h5 id="（1）查找操作"><a href="#（1）查找操作" class="headerlink" title="（1）查找操作"></a><strong>（1）查找操作</strong></h5><p>BST的性质决定了每次只需要选择其中一棵子树进行遍历，因此查找将会是从树根到查找结点的一条路径，故最坏复杂度是 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search 函数查找二叉查找树中数据域为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;search failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);		<span class="comment">// 查找成功，访问之</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        search(root-&gt;lchild, x);		<span class="comment">// 往左子树搜索x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        search(root-&gt;rchild, x);		<span class="comment">// 往右子树搜索x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）插入操作"><a href="#（2）插入操作" class="headerlink" title="（2）插入操作"></a><strong>（2）插入操作</strong></h5><p>当需要查找的值在BST中查找失败时，说明这个地方一定是结点需要插入的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert 函数将在二叉树中插入一个数据域为x的新结点（注意参数root要加引用&amp;）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;		<span class="comment">// 空树，查找失败，亦即插入位置</span></span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;			<span class="comment">// 查找成功，结点已存在，返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        insert(root-&gt;lchild, x);		<span class="comment">// 往左子树搜索x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;rchild, x);		<span class="comment">// 往右子树搜索x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）创建操作"><a href="#（3）创建操作" class="headerlink" title="（3）创建操作"></a><strong>（3）创建操作</strong></h5><p>建立一棵二叉查找树，就是先后插入n个结点的过程，这和一般二叉树的建立是完全一样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉查找树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（4）删除操作"><a href="#（4）删除操作" class="headerlink" title="（4）删除操作"></a><strong>（4）删除操作</strong></h5><p>我们首先定义两个概念，对于二叉查找树中的某个结点 x，</p>
<ul>
<li>把<strong>比结点权值小的最大结点</strong>称为该结点的<strong>前驱</strong>；</li>
<li>把<strong>比结点权值大的最小结点</strong>称为该结点的<strong>后继</strong>。</li>
</ul>
<p>显然，结点的<strong>前驱是该结点左子树中的最右结点</strong>，而结点的<strong>后继则是该结点右子树中的最左结点</strong>。</p>
<p>当我们删除二叉查找树中的某个结点 x 时，为了保证删除操作之后仍然是一棵二叉查找树，需要用 x 的前驱结点或后继结点覆盖 x。</p>
<p>如下图，如果需要删掉根结点5，一种办法是用结点4（前驱）来覆盖结点5，另一种办法是用结点6（后继）来覆盖结点5。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307130118715.png" alt="image-20210307130118715" style="zoom:60%;" />



<p>下面两个函数用来寻找以 root 为根的树中最大或最小权值的结点，用以辅助寻找结点的前驱和和后继：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找以 root 为根结点的树中的最大权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;rchild;		<span class="comment">// 不断往右，直到没有右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找以 root 为根结点的树中的最小权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;lchild;		<span class="comment">// 不断往左，直到没有左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>假设决定用结点N的前驱P来替换N，那么删除操作的基本思路如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除以root为根结点的树中权值为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)	<span class="keyword">return</span>;		<span class="comment">// 不存在权值为 x 的结点</span></span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;			<span class="comment">// 找到欲删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 叶子结点，直接删除</span></span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 左子树不为空时，优先用前驱覆盖root</span></span><br><span class="line">            node* pre = findMax(root-&gt;lchild);</span><br><span class="line">            root-&gt;data = pre-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;lchild, pre-&gt;data);	<span class="comment">// 在左子树中删除结点pre</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左子树为空但右子树不为空时，用后继覆盖root</span></span><br><span class="line">            node* next = findMin(root-&gt;rchild);</span><br><span class="line">            root-&gt;data = next-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;rchild, next-&gt;data);	<span class="comment">// 在右子树中删除结点next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        deleteNode(root-&gt;lchild, x);<span class="comment">// 在左子树中删除x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteNode(root-&gt;rchild, x);<span class="comment">// 在右子树中删除x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>需要注意的是，总是优先删除前驱（或后继）容易导致树的左右子树高度极不平衡，使得二叉查找树退化成一条链。解决的办法有两种：</p>
<ol>
<li>每次交替删除前驱或后继；</li>
<li>记录子树高度，总是优先在高度较高地一棵子树里删除结点。</li>
</ol>
<p>当然，上述代码还可以通过很多手段优化。例如，找到欲删除结点5的后继结点6后，不进行递归，而是将结点6的右子树替代结点6，成为结点8的左子树。</p>
<h5 id="（5）二叉查找树的性质"><a href="#（5）二叉查找树的性质" class="headerlink" title="（5）二叉查找树的性质"></a><strong>（5）二叉查找树的性质</strong></h5><p>“<strong>对二叉查找树进行中序遍历，遍历的结果是有序的</strong>”。这是因为二叉查找树本身就具有 “左子树 &lt; 根结点 &lt; 右子树” 的特点，而中序遍历又是按照 “左子树 → 根结点 → 右子树” 的顺序进行访问的，因而中序遍历序列是有序的。</p>
<h4 id="2）平衡二叉树（AVL）"><a href="#2）平衡二叉树（AVL）" class="headerlink" title="2）平衡二叉树（AVL）"></a>2）平衡二叉树（AVL）</h4><p>首先考虑一下上一小节的二叉查找树有什么缺陷。考虑使用序列 {1,2, 3, 4, 5} 来构建二叉查找树，会得到如下图所示的BST：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307145811736.png" alt="image-20210307145811736" style="zoom:60%;" />



<p>显然，这棵二叉查找树是链式的，此时对这棵树中结点进行查找的复杂度就会达到 $O(n)$ 。为了能使树的高度在每次插入元素后仍然能爆出 $O(logn)$ 的级别，平衡二叉树（AVL）诞生了。</p>
<p>AVL仍然是一棵二叉查找树，只是增加了“<strong>平衡</strong>”的要求。</p>
<ul>
<li><strong>平衡</strong>：对AVL树的任意结点来说，其左子树与右子树的<strong>高度之差的绝对值不超过1</strong>。</li>
<li><strong>平衡因子</strong>：对AVL树的任意结点来说，其左子树与右子树的<strong>高度之差</strong>称为该节点的平衡因子。</li>
</ul>
<p>因此需要在树的结构中加入一个变量 height，用来记录以当前结点为根结点的子树的高度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, height;</span><br><span class="line">    node* lchild, rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，结点 root 所在子树的高度等于其左子树的 height 与右子树的 height 的较大值加1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取以root为根结点的子树的height</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新结点root的height</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// max(左孩子的height， 右孩子的height) + 1</span></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（1）查找操作-1"><a href="#（1）查找操作-1" class="headerlink" title="（1）查找操作"></a><strong>（1）查找操作</strong></h5><p>由于 AVL 是一棵二叉查找树，因此查找操作与 BST 相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search 函数查找二叉查找树中数据域为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;search failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);		<span class="comment">// 查找成功，访问之</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        search(root-&gt;lchild, x);		<span class="comment">// 往左子树搜索x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        search(root-&gt;rchild, x);		<span class="comment">// 往右子树搜索x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）旋转操作"><a href="#（2）旋转操作" class="headerlink" title="（2）旋转操作"></a><strong>（2）旋转操作</strong></h5><p>如下图，以<strong>左旋</strong>为例，假设B希望成为根结点，由于 A &lt; B，因而A将成为B的左子树，那么B原来的左子树 ◆ 呢？考虑到 A &lt; ◆ &lt; B，于是让 ◆ 成为A的右子树即可。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307154641717.png" alt="image-20210307154641717" style="zoom:60%;" />



<p>这个调整过程被称为<strong>左旋（Left Rotation）</strong>，可以分为三个步骤：</p>
<ol>
<li>让 B 的左子树 ◆ 成为 A 的右子树；</li>
<li>让 A 成为 B 的左子树；</li>
<li>将根结设定为结点 B。</li>
</ol>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307154851200.png" alt="image-20210307154851200" style="zoom:75%;" />



<p>对应的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋（Left Rotation）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root, node* temp)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">// root指向A，temp指向B</span></span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;	<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;lchild = root;			<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);		<span class="comment">// 更新结点A的高度</span></span><br><span class="line">    updateHeight(temp);		<span class="comment">// 更新结点B的高度</span></span><br><span class="line">    root = temp;					<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>右旋（Right Rotation）</strong>和左旋是对称的过程，即左旋的逆过程，实现步骤和左旋基本相同，直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右旋（Right Rotation）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root, node* temp)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">// root指向B，temp指向A</span></span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;	<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;rchild = root;			<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);		<span class="comment">// 更新结点B的高度</span></span><br><span class="line">    updateHeight(temp);		<span class="comment">// 更新结点A的高度</span></span><br><span class="line">    root = temp;					<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）插入操作"><a href="#（3）插入操作" class="headerlink" title="（3）插入操作"></a>（3）插入操作</h5><p>AVL 的插入操作比较复杂，且需要用到旋转操作，我们一步一步分析：</p>
<ul>
<li><p>在往 AVL 中插入一个结点时，一定会有结点的平衡因子发生变化，此时可能会有结点的平衡因子的<strong>绝对值大于1</strong>。</p>
<p>（且只可能是2或-2，因为只插入了一个结点，树的高度只可能变化1）</p>
</li>
<li><p>显然，只有在<strong>从根结点到该插入节点的路径上的结点</strong>才可能发生平衡因子变化，因此只需对这条路径上失衡的结点进行调整。</p>
</li>
<li><p>可以证明，“<strong>只要把最靠近插入节点的失衡结点调整到正常，路径上的所有结点就会平衡</strong>”。</p>
</li>
</ul>
<p>下举例说明：</p>
<p>假设最靠近插入结点的失衡结点是A，显然它的平衡因子只可能是2或者-2，这两种情况是完全对称的。</p>
<ul>
<li><p>假设A的平衡因子是2，即左子树的高度比右子树大2，那么以A为根结点的子树一定是下图 LL型与 LR型之一。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307164602382.png" alt="image-20210307164602382" style="zoom:75%;" />

<p>可以发现，<strong>当A的左孩子的平衡因子是1时为 LL型，是-1时为 LR型</strong> 。</p>
</li>
</ul>
<ul>
<li><p>假设A的平衡因子是-2，即左子树的高度比右子树小2，那么以A为根结点的子树一定是下图 RR型与 RL型之一。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307165656377.png" alt="image-20210307165656377" style="zoom:75%;" />

<p>可以发现，<strong>当A的右孩子的平衡因子是-1时为 RR型，是1时为 RL型</strong> 。</p>
</li>
</ul>
<p><strong>【调整】</strong></p>
<p>现在考虑怎样调整这四种树型，才能使树平衡。</p>
<ul>
<li><p>对于LL型，可以把以C为根结点的子树看作一个整体，然后以结点A作为root进行右旋，便可以达到平衡：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307165332820.png" alt="image-20210307165332820" style="zoom:75%;" />
</li>
<li><p>对于LR型，可以先忽略结点A，以C为root进行左旋，就可以把情况转化为LL型，然后按照上面LL型的做法进行一次右旋即可：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307165452611.png" alt="image-20210307165452611" style="zoom:75%;" />
</li>
<li><p>对于RR型，可以把以C为根结点的子树看作一个整体，然后以结点A作为root进行左旋，便可以达到平衡：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307165942851.png" alt="image-20210307165942851" style="zoom:75%;" />
</li>
<li><p>对于RL型，可以先忽略结点A，以C为root进行右旋，就可以把情况转化为RR型，然后按照上面RR型的做法进行一次左旋即可：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210307165959809.png" alt="image-20210307165959809" style="zoom:75%;" />



</li>
</ul>
<p><strong>【汇总】</strong></p>
<p>至此，对LL型、LR型、RR型、RL型的调整方法都已经讨论清楚，下面做个小小的汇总：</p>
<table>
<thead>
<tr>
<th align="center">树型</th>
<th align="center">判定条件</th>
<th align="center">调整方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LL</td>
<td align="center"><code>BF(root) = 2</code> 且 <code>BF(root-&gt;lchild) = 1</code></td>
<td align="center">对root进行右旋</td>
</tr>
<tr>
<td align="center">LR</td>
<td align="center"><code>BF(root) = 2</code> 且 <code>BF(root-&gt;lchild) = -1</code></td>
<td align="center">先对 <code>root-&gt;lchild</code> 进行左旋，再对root进行右旋</td>
</tr>
<tr>
<td align="center">RR</td>
<td align="center"><code>BF(root) = -2</code> 且 <code>BF(root-&gt;rchild) = -1</code></td>
<td align="center">对root进行左旋</td>
</tr>
<tr>
<td align="center">RL</td>
<td align="center"><code>BF(root) = -2</code> 且 <code>BF(root-&gt;rchild) = 1</code></td>
<td align="center">先对 <code>root-&gt;rchild</code> 进行右旋，再对root进行左旋</td>
</tr>
</tbody></table>
<p><strong>【代码】</strong></p>
<p>AVL树的插入代码需要在二叉查找树的插入代码的基础上增加平衡操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入权值为v的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = newNode(v);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v &lt; root-&gt;v) &#123;</span><br><span class="line">        insert(root-&gt;lchild, v);		<span class="comment">// 往左子树插入</span></span><br><span class="line">        updateHeight(root);				<span class="comment">// 更新树高</span></span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">1</span>) &#123;	<span class="comment">// LL型</span></span><br><span class="line">                R(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">-1</span>)	<span class="comment">// LR型</span></span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;rchild, v);		<span class="comment">// 往右子树插入</span></span><br><span class="line">        updateHeight(root);				<span class="comment">// 更新树高</span></span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">-1</span>) &#123;	<span class="comment">// RR型</span></span><br><span class="line">                L(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">1</span>)	<span class="comment">// RL型</span></span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（4）创建操作"><a href="#（4）创建操作" class="headerlink" title="（4）创建操作"></a><strong>（4）创建操作</strong></h5><p>有了插入操作的基础，AVL树的建立就非常简单了，只需依次插入n个结点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVL树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3）并查集"><a href="#3）并查集" class="headerlink" title="3）并查集"></a>3）并查集</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集</a></p>
</blockquote>
<p>在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题的特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，计算机无法承受。</p>
<p>并查集是一种树型的数据结构，它的名字中 “并”、“查”、“集” 分别取自 Union（合并）、Find（查找）、Set（集合）这三个词，用于处理这类<strong>不相交集合</strong>（disjoint sets）的<strong>合并及查询</strong>问题。</p>
<p>实际上，并查集就是一个数字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> father[N];</span><br></pre></td></tr></table></figure>
<p>其中 <code>father[i]</code> 表示元素 <code>i</code> 的父亲结点，而父亲结点本身也是这个集合内的元素。<strong>对于同一个集合来说只存在一个根结点，且将其作为所属集合的标识</strong>。</p>
<h5 id="（1）初始化"><a href="#（1）初始化" class="headerlink" title="（1）初始化"></a>（1）初始化</h5><p>一开始，每个元素都是独立的一个集合，因此需要令所有 <code>father[i] = i</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    father[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）查找"><a href="#（2）查找" class="headerlink" title="（2）查找"></a>（2）查找</h5><p>查找操作就是对给定的结点寻找其根结点的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* findFather函数返回元素x所在集合的根结点*/</span></span><br><span class="line"><span class="comment">// 1.递推算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;		<span class="comment">// 如果不是根结点，继续循环</span></span><br><span class="line">        x = father[x];			<span class="comment">// 获得自己的父亲结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])	<span class="keyword">return</span> x;	<span class="comment">// 如果找到根结点，返回根结点编号x</span></span><br><span class="line">    <span class="keyword">else</span>	<span class="keyword">return</span> findFather(father[x]);	<span class="comment">// 否则，递归判断x的父亲结点是否是根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）合并"><a href="#（3）合并" class="headerlink" title="（3）合并"></a>（3）合并</h5><p>合并是指把两个集合合并成一个集合。一般是先判断两个元素是否属于同一个集合，只有当它们属于不同集合时才合并，而合并的过程一般是把其中一个集合的根结点的父亲指向另一个集合的根结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210308201334299.png" alt="image-20210308201334299" style="zoom:80%;" />

<p>由于在合并的过程中，只对两个不同的集合进行合并，这就保证了在同一个集合中一定不会产生环，即<strong>并查集产生的每一个集合都是一棵树</strong>。</p>
<p><strong>（4）路径压缩</strong></p>
<p>前面提到的并查集查找函数是未经优化的，在极端情况（比如当元素数量很多且形成一条链时）下效率较低。</p>
<p>优化方法如下：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210308201515458.png" alt="image-20210308201515458" style="zoom:75%;" />

<p>这样相当于<strong>把当前查询结点的路径上的所有结点的父亲都指向根结点</strong>，查找时就不需要一直回溯了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span>(root != father[root]) &#123;	<span class="comment">// 寻找根结点</span></span><br><span class="line">        root = father[root];	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面把路径上的所有结点的father都改成根结点</span></span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = father[x];		<span class="comment">// 记录x的father</span></span><br><span class="line">        father[x] = root;		<span class="comment">// 把x的father结点指向root</span></span><br><span class="line">        x = a;					<span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（5）应用——亲戚问题"><a href="#（5）应用——亲戚问题" class="headerlink" title="（5）应用——亲戚问题"></a>（5）应用——亲戚问题</h5><blockquote>
<p><strong>题目背景</strong><br>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br><strong>题目描述</strong><br>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br><strong>输入格式</strong><br>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。<br><strong>输出格式</strong><br>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>
</blockquote>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5005</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXN], rank[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);</span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, p, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        merge(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(x) == find(y) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="4）堆"><a href="#4）堆" class="headerlink" title="4）堆"></a>4）堆</h4><p>堆是一棵<strong>完全二叉树</strong>，树中每个节点的值都不小于（或不大于）其左右孩子结点的值。</p>
<ul>
<li>如果父亲结点大于等于孩子结点，称为<strong>大顶堆</strong>，此时每个结点的值都是以它为根结点的子树的最大值；</li>
<li>如果父亲结点小于等于孩子结点，称为<strong>小顶堆</strong>，此时每个结点的值都是以它为根结点的子树的最小值；</li>
</ul>
<p>对于完全二叉树来说，可以使用数组来定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn], n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，第一个结点将存储于数组中的1号位，并且数组i号位表示的结点的左孩子就是2i号位，而右孩子则是2i+1号位。</p>
<h5 id="（1）建堆"><a href="#（1）建堆" class="headerlink" title="（1）建堆"></a>（1）建堆</h5><p>建堆是一个<strong>向下调整</strong>的过程：</p>
<ul>
<li>总是将当前节点 i 与它的左右孩子比较，若孩子的权值比 i 还大，就将两者交换；</li>
<li>交换完毕后继续让节点 i 和孩子比较，直到 i 的孩子的权值都比 i 的权值小或者不存在孩子结点。</li>
</ul>
<p>向下调整的代码如下，时间复杂度为 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对heap数组在[low, high]范围进行向下调整</span></span><br><span class="line"><span class="comment">// 其中low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = <span class="number">2</span> * i;		<span class="comment">// i为欲调整结点，j为其左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) &#123;			<span class="comment">// 存在孩子结点</span></span><br><span class="line">    	<span class="comment">// 如果右孩子存在，且右孩子的值大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">            j = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果孩子中最大的权值比欲调整节点i大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[j] &gt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);</span><br><span class="line">            i = j;				<span class="comment">// 保持i为欲调整节点、j为i的左孩子</span></span><br><span class="line">            j = i * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;				<span class="comment">// 孩子的权值均比欲调整节点i小，调整结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>那么<strong>建堆</strong>的过程也就很容易了。由于完全二叉树的叶子节点个数为 $\lceil n/2 \rceil$ ，因此数组下标在 $[1, \lfloor n/2 \rfloor]$ 范围内的都是非叶子节点。于是可以从 $\lfloor n/2 \rfloor$ 号位开始倒着枚举结点，对每个遍历到的结点 i 进行 $[i, n]$ 范围的调整。这种做法能够<strong>保证每个调整完的结点都是以其为根结点的子树中的权值最大的结点</strong>。</p>
<p>建堆的代码如下，时间复杂度为 $O(n)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）删除堆顶元素"><a href="#（2）删除堆顶元素" class="headerlink" title="（2）删除堆顶元素"></a>（2）删除堆顶元素</h5><p>如果要删除堆中的最大元素，即堆顶元素，并让其仍然保持堆的结构，只需要最后一个元素覆盖堆顶元素，然后对根结点进行调整即可。</p>
<p>代码如下，时间复杂度为 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];	<span class="comment">// 用最后一个元素覆盖堆顶元素，并让元素个数减1</span></span><br><span class="line">    downAdjust(<span class="number">1</span>, n);		<span class="comment">// 从上向下调整堆顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）向堆中添加元素"><a href="#（3）向堆中添加元素" class="headerlink" title="（3）向堆中添加元素"></a>（3）向堆中添加元素</h5><p>如果想要往堆里添加一个元素，可以吧其放在数组最后，然后进行<strong>向上调整</strong>操作。</p>
<ul>
<li>向上调整总是把欲调整结点与父亲结点比较，如果权值比父亲大，就交换之，反复此过程。</li>
</ul>
<p>向上调整的代码如下，时间复杂度为 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对heap数组在[low, high]范围内进行向上调整</span></span><br><span class="line"><span class="comment">// 其中low一般设置为1，high表示欲调整节点的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;	<span class="comment">// i为欲调整结点，j为其父亲</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= low) &#123;</span><br><span class="line">        <span class="comment">// 父亲权值小于欲调整结点i的权值</span></span><br><span class="line">        <span class="keyword">if</span>(heap[j] &lt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);	<span class="comment">// 交换父亲和欲调整结点</span></span><br><span class="line">            i = j;			<span class="comment">// 保持i为欲调整结点，j为i的父亲</span></span><br><span class="line">            j = i / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;			<span class="comment">// 父亲权值比与调整结点i的权值大，调整结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上，就很容易实现<strong>添加元素</strong>的代码了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（4）堆排序"><a href="#（4）堆排序" class="headerlink" title="（4）堆排序"></a>（4）堆排序</h5><p>堆排序是指<strong>使用堆结构对一个序列进行排序</strong>。</p>
<p>我们考虑递增排序的情况，对于一个大顶堆来说，堆排序的直观思路是：</p>
<ol>
<li>取出堆顶元素，然后将堆的最后一个元素替换至堆顶，再进行一次针对堆顶元素的向下调整；</li>
<li>如此重复，直到堆中只有一个元素为止。</li>
</ol>
<p>具体实现时，为了节省空间，可以倒着遍历数组：</p>
<ul>
<li>假设当前访问到 i号位，那么将堆顶元素与 i 号位的元素交换，接着在 $[1, i-1]$ 范围内对堆顶元素进行一次向下调整即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createHeap();		<span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(heap[i], heap[<span class="number">1</span>]);		<span class="comment">// 交换heap[i]与堆顶</span></span><br><span class="line">        downAdjust(<span class="number">1</span>, i<span class="number">-1</span>);			<span class="comment">// 调整堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="5）哈夫曼树"><a href="#5）哈夫曼树" class="headerlink" title="5）哈夫曼树"></a>5）哈夫曼树</h4><p>先介绍经典的合并果子问题：</p>
<blockquote>
<p>有n堆果子，每堆果子的质量已知，现在需要把这些果子合并成一堆，但是每次只能把两堆果子合并到一起，同时会消耗与两堆果子质量之和等值的体力。显然，在进行n-1次合并之后，就只剩下一堆了。为了尽可能节省体力，请设计出合并的次序方案，使得耗费的体力最少，并给出消耗的体力值。</p>
<p>例如有3堆果子，质量依次为1、2、9。那么可以先将质量为 1和2的果堆合并，新堆质量为3，因此耗费体力为3。接着，将新堆与原先的质量为9的果堆合并，又得到新的堆，质量为12，因此耗费体力为12。所以耗费体力之和为3+12=15。可以证明15为最小的体力耗费值。</p>
</blockquote>
<p>为了解决这个问题，我们把每堆果子都看作结点，果堆的质量视作结点的权值，这样合并两个果堆的过程可以视作给它们生成一个父结点，于是把n堆果子合并成一堆的过程可以用一棵树来表示。</p>
<p>如下图是将 1、2、3、4、5、6 进行合并的某一种方案。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210308224644236.png" alt="image-20210308224644236" style="zoom:80%;" />



<p>把叶子结点的权值乘以路径长度的结果称为这个叶子结点的<strong>带权路径长度（Weighted Path Length of Tree, WPL）</strong>。那么树的WPL就等于所有叶子结点的WPL之和。</p>
<p>我们称带权路径长度最小的树为<strong>哈夫曼树</strong>（又称为最优二叉树）。显然，哈夫曼树可以不唯一，但最小WPL一定是唯一的。</p>
<h5 id="（1）构造哈夫曼树"><a href="#（1）构造哈夫曼树" class="headerlink" title="（1）构造哈夫曼树"></a>（1）构造哈夫曼树</h5><p>下面介绍<strong>构造一棵哈夫曼树的算法</strong>：</p>
<ol>
<li>初始状态下共有n个结点（结点权值分别是给定的n个数），将它们视作n棵只有一个结点的树；</li>
<li>合并其中根结点权值最小的两棵树，生成两棵树根结点的父结点，权值为这两个根结点的权值之和，这样树的数量就少了一个；</li>
<li>重复操作2，直到只剩下一棵为止，这棵树就是哈夫曼树。</li>
</ol>
<p>事实上，在很多实际场景中，不需要真的去构建一棵哈夫曼树，只需要能得到最终的带权路径长度即可。因此我们需要着重掌握的是哈夫曼树的<strong>构建思想</strong>：</p>
<ul>
<li><strong>反复选择两个最小的元素，合并，直到只剩下一个元素</strong>。</li>
</ul>
<p>因此，一般可以使用<strong>优先队列（小顶堆）</strong>来执行这种策略。</p>
<ol>
<li>初始状态下降果堆的质量压入优先队列；</li>
<li>之后每次从优先队列顶部取出两个最小的数，将它们相加并重新压入优先队列；</li>
<li>重复操作2，直到只剩下一个数，此时就得到了消耗的最小体力。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表小顶堆的优先队列</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp, x, y, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;temp);</span><br><span class="line">        q.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>) &#123;	<span class="comment">// 优先队列中至少有两个元素</span></span><br><span class="line">        x = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        y = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        q.push(x + y);		<span class="comment">// 取出堆顶的两个元素，求和后压入优先队列</span></span><br><span class="line">        ans += (x + y);		<span class="comment">// 累计求和的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）哈夫曼编码"><a href="#（2）哈夫曼编码" class="headerlink" title="（2）哈夫曼编码"></a>（2）哈夫曼编码</h5><p>对于任意一棵二叉树来说，如果把二叉树上的所有分支都进行编号，且做分值标记为0，右分支标记为1，那么对树上的任意一个结点，都可以根据从根结点出发到达它的分支顺序得到一个编号，且这个编号是唯一的。并且，<strong>对于任何一个叶子结点，其编号一定不会成为其他任何一个结点编号的前缀</strong>。</p>
<p>这有什么用呢？我们考虑下面这个问题：</p>
<blockquote>
<p>假设现在有一个字符串，它由A、B、C、D这四个英文字符的一个或多个组成，例如 ABCAD。现在希望把它编码成一个01串，这样方便进行数据传输。能想到的一个办法是把A~D各自用一个01 串表示，然后拼接起来即可。</p>
<p>例如可以把A用0表示、B用1表示、C用 00表示、D用 01表示，这样 ABCAD就可以用0100001表示。但是很快就会发现，解码的时候无法知道开头的 01到底是 AB还是D（因为 AB和D的编码都是 01），因此这种编码方式是不行的。</p>
<p>为什么不行呢？这是因为<strong>存在一种字符的编码是另一种字符的编码的前缀</strong>，例如 A 的编码是 D的编码的前缀，于是一旦有某一种字符的编码拼接在 A的编码之后能产生D的编码，就会产生混淆，例如此处把B的编码拼接在A的编码之后能产生 D的编码。</p>
</blockquote>
<p>因此，需要寻找一套编码方式，使得其中<strong>任何一个字符的编码都不是另一个字符的编码的前缀</strong>，同时把满足这种编码方式的编码称为<strong>前缀编码</strong>。</p>
<p>考虑进一步的问题，对一个给定的字符串来说，肯定有多种前缀编码的方式，但为了信息传递的效率，需要尽量<strong>选择长度最短</strong>的编码方式。因此，我们希望出现<strong>频次最高的字符对应的编码长度应最短</strong>。而如果把频数作为叶子结点的权值，那么<strong>字符串编码成01串后的长度实际上就是这棵树的带权路径长度</strong>。</p>
<p>显然，这个问题已经得到解决——就是哈夫曼树。这种由哈夫曼树产生的编码方式被称为<strong>哈夫曼编码</strong>。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210308232052967.png" alt="image-20210308232052967" style="zoom:80%;" />



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span>	<span class="comment">// 树结点</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    TreeNode(<span class="keyword">char</span> x, <span class="keyword">int</span> f): ch(x), freq(f), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t1-&gt;freq &gt; t2-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">unionTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;	<span class="comment">// 合并两棵子树为一棵树</span></span><br><span class="line">	TreeNode* temp = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;#&#x27;</span>, t1-&gt;freq + t2-&gt;freq);</span><br><span class="line">    temp-&gt;left = t1;</span><br><span class="line">    temp-&gt;right = t2;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">getHuffmanTree</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt; V)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 优先队列建立哈夫曼树，结点权重为字符出现频次，显然出现频次越高，在树中的位置应该越浅</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;TreeNode*, <span class="built_in">vector</span>&lt;TreeNode*&gt;, cmp&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: V) &#123;</span><br><span class="line">       q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">       TreeNode* t1 = q.top(); q.pop();</span><br><span class="line">       TreeNode* t2 = q.top(); q.pop();</span><br><span class="line">       q.push(unionTree(t1, t2));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> q.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHuffmanCode</span><span class="params">(TreeNode* root, <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &amp;mp, <span class="built_in">string</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归哈夫曼树，统计得到哈夫曼编码的映射表mp</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        mp[root-&gt;ch] = code;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    getHuffmanCode(root-&gt;left, mp, code + <span class="string">&quot;0&quot;</span>);		<span class="comment">// 左子树为0</span></span><br><span class="line">    getHuffmanCode(root-&gt;right, mp, code + <span class="string">&quot;1&quot;</span>);	<span class="comment">// 右子树为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>需要注意的是，<strong>哈夫曼编码是针对确定的字符串来讲的</strong>。只有对确定的字符串才能根据其中各字符的出现次数建立哈夫曼树，才有对应的哈夫曼编码。</p>
<h2 id="0x04-图论专题"><a href="#0x04-图论专题" class="headerlink" title="0x04 图论专题"></a>0x04 图论专题</h2><h3 id="1-图的定义和相关术语"><a href="#1-图的定义和相关术语" class="headerlink" title="1. 图的定义和相关术语"></a>1. 图的定义和相关术语</h3><ul>
<li><p>图由<strong>顶点（Vertex）</strong>和<strong>边（Edge）</strong>组成，每条边的两端都必须是图的两个顶点（可以是<strong>相同</strong>的顶点），记号 $G(V, E)$ 表示图的顶点集为 $V$ 、边集为 $E$ 。</p>
</li>
<li><p>一般来说，图可分为<strong>有向图</strong>和<strong>无向图</strong>：</p>
<ul>
<li>有向图的所有边都有方向，即确定了顶点到顶点的一个指向；</li>
<li>无向图的所有边都是双向的，即无向边所连接的两个顶点可以互相到达。</li>
<li>在某些问题中，可以把无线图当作所有边都是两条有向边的有向图。</li>
</ul>
</li>
<li><p>顶点的<strong>度</strong>：指和该顶点相连的边的条数。</p>
<ul>
<li>对于有向图来说，顶点的出边条数称为<strong>出度</strong>，入边条数称为<strong>入度</strong>。</li>
</ul>
</li>
<li><p>顶点和边都可以有一定属性，而量化的属性称为<strong>权值</strong>，分别称为<strong>点权</strong>和<strong>边权</strong>。</p>
</li>
</ul>
<h3 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2. 图的存储"></a>2. 图的存储</h3><h4 id="1）邻接矩阵"><a href="#1）邻接矩阵" class="headerlink" title="1）邻接矩阵"></a>1）邻接矩阵</h4><p>设图 $G(V, E)$ 的顶点编号为 0,1, …, N-1，那么可以令二维数组 $G[N][N]$ 来存储，这个二维数组 $G[][] $ 被称为<strong>邻接矩阵</strong>。</p>
<ul>
<li>如果 $G[i][j]$ 为 1，说明从顶点 i 到顶点 j 之间有边。</li>
<li>如果存在边权，也可以令 $G[i][j]$ 存放边权，对不存在的边可以置为 0或-1。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210309101043767.png" alt="image-20210309101043767" style="zoom:80%;" />

<p>虽然邻接矩阵比较好些，但如果顶点数目太大，会爆栈，且对于稀疏矩阵来说会浪费大量空间。</p>
<h4 id="2）邻接表"><a href="#2）邻接表" class="headerlink" title="2）邻接表"></a>2）邻接表</h4><p>如果把同一个顶点的所有出边放在一个列表中，那么N个顶点就会有N个列表，这N个列表被称为图G的<strong>邻接表</strong>，记为 $Adj[N]$。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210309101241933.png" alt="image-20210309101241933" style="zoom:80%;" />



<p>如果邻接表只存放每条边的终点编号，而不存放边权，则可以定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<p>如果需要同时存放边的终点编号和边权，那么可以建立结构体 Node：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strcut Node &#123;</span><br><span class="line">    <span class="keyword">int</span> v;		<span class="comment">// 边的终点编号</span></span><br><span class="line">    <span class="keyword">int</span> w;		<span class="comment">// 边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br></pre></td></tr></table></figure>




<h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h3><p>首先介绍两个概念：</p>
<ul>
<li><strong>连通分量</strong>：<ul>
<li>在无向图中，如果两个顶点之间可以<strong>相互到达</strong>，那么就称这两个顶点连通；</li>
<li>如果任意两个顶点都连通，则称图 $G$ 为<strong>连通图</strong>；否则，称 $G$ 为<strong>非连通图</strong>，且称其中的极大连通子图为<strong>连通分量</strong>。</li>
</ul>
</li>
<li><strong>强连通分量</strong>：<ul>
<li>在有向图中，如果两个顶点可以各自通过一条<strong>有向路径</strong>到达另一个顶点，就称这两个顶点强连通。</li>
<li>如果任意两个顶点都强连通，则称图 $G$ 为<strong>强连通图</strong>；否则，称 $G$ 为<strong>非强连通图</strong>，且称其中的极大强连通子图为<strong>强连通分量</strong>。</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210309102337389.png" alt="image-20210309102337389" style="zoom:80%;" />



<p>为了叙述上的方便，可以把连通分量和强连通分量均称为<strong>连通块</strong>。</p>
<p>可以想象，如果要遍历整个图，就要对所有连通块分别进行遍历。</p>
<h4 id="1）深度优先搜索"><a href="#1）深度优先搜索" class="headerlink" title="1）深度优先搜索"></a>1）深度优先搜索</h4><p>DFS遍历图的基本思路：</p>
<ul>
<li>将经过的顶点设置为已访问，在下次递归碰到这个顶点时就不再去处理，直到整个图的顶点都被标记为已访问。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DFSTrave(G) &#123;	<span class="comment">// 遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u] == <span class="literal">false</span>)	<span class="comment">// 如果u未被访问</span></span><br><span class="line">            DFS(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFS(u) &#123;		<span class="comment">// 访问顶点u</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;	<span class="comment">// 设置u为已访问</span></span><br><span class="line">    <span class="keyword">for</span>(从u出发能到达的所有顶点v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] == <span class="literal">false</span>)	<span class="comment">// 如果v未被访问</span></span><br><span class="line">            DFS(v);	<span class="comment">// 递归访问v</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="2）广度优先搜索"><a href="#2）广度优先搜索" class="headerlink" title="2）广度优先搜索"></a>2）广度优先搜索</h4><p>和树的遍历一样，使用BFS遍历图需要使用一个队列，其基本思路是：</p>
<ul>
<li>通过反复取出队首顶点，将该顶点可到达的<strong>未曾加入过队列</strong>的顶点全部入队，直到队列为空时遍历结束。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BFSTrave(G) &#123;	<span class="comment">// 遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u] == <span class="literal">false</span>)	<span class="comment">// 如果u未曾加入过队列</span></span><br><span class="line">            BFS(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS(u) &#123;		<span class="comment">// 遍历u所在的连通块</span></span><br><span class="line">    <span class="built_in">queue</span> q;	</span><br><span class="line">    q.push(u);	<span class="comment">// 将初始点u入队</span></span><br><span class="line">    inq[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();	<span class="comment">// 取出队首元素</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(从u出发可达的所有顶点v) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v] == <span class="literal">false</span>) &#123;</span><br><span class="line">                q.push(v)	<span class="comment">// 将v入队</span></span><br><span class="line">                inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="4-最短路径"><a href="#4-最短路径" class="headerlink" title="4. 最短路径"></a>4. 最短路径</h3><p>最短路径是图论中一个很经典的问题：给定图 $G(V, E)$ ，求一条从起点到终点的路径，使得这条路径上经过的所有边的边权之和最小。</p>
<h4 id="1）Dijkstra-算法"><a href="#1）Dijkstra-算法" class="headerlink" title="1）Dijkstra 算法"></a>1）Dijkstra 算法</h4><p>Dijkstra 算法（迪杰斯特拉算法）用来解决<strong>单源最短路问题</strong>：</p>
<ul>
<li>给定图 G 和起点 s，通过算法得到 s 到达其他每个顶点的最短距离。</li>
</ul>
<p><strong>【基本思想】</strong>：</p>
<ul>
<li>对图 $G(V, E)$ 设置集合 S，存放已被访问的顶点，然后重复下面的操作 n 次，直到集合 S 已包含所有顶点。<ol>
<li>每次从集合 V-S 中选择<strong>与起点 s 的距离最小</strong>的一个顶点（记为u），访问并加入集合S。</li>
<li>之后，令顶点u为中介点，优化起点 s 与所有从 u 能到达的顶点 v 之间的最短距离。</li>
</ol>
</li>
<li>如果需要输出最短路径，则需要一个最短路径数组 $Spath$ ，<code>Spath[v]</code> 表示从源点s到顶点v的最短路径上，<strong>v的直接前驱结点</strong>。</li>
</ul>
<p><strong>【伪代码】</strong>：</p>
<ul>
<li>集合 S 可以使用一个 bool 型数组 <code>vis[]</code> 来实现；令 int 型数组 <code>d[]</code> 标识起点s到达其他顶点的最短距离；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra(G, d[], s) &#123;</span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环n次) &#123;</span><br><span class="line">        u = 使 d[u] 最小的还未被访问的定点的标号;</span><br><span class="line">            记u已被访问;</span><br><span class="line">            <span class="keyword">for</span>(从u出发能到达的所有顶点v) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v未被访问 &amp;&amp; 以u为中介点使s到顶点v的最短距离d[v]更优) &#123;</span><br><span class="line">                    优化 d[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>【邻接矩阵版】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;	<span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF  = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, G[MAXN][MAXN];		<span class="comment">// n为顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">// 标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    fill(d, d + MAXN, INF);	<span class="comment">// 将整个d数组赋为 INF</span></span><br><span class="line">    d[s] = <span class="number">0</span>;	<span class="comment">// 起点s到达自身的距离为0</span></span><br><span class="line">    <span class="comment">// 循环n次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到一个使d[u]最小的u，MIN存放该最小的d[u]</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;	</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找不到小于INF的d[u]，说明剩下的顶点和起点s不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>)	<span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 若找到了，则标记u为已访问过的，并以u为中介优化其余顶点</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果v未访问 &amp;&amp; u能到达v &amp;&amp; 以u为中介点可以使d[v]更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                d[v] = d[u] + G[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputPath</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s);</span><br><span class="line">		path.push_back(s);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outputPath(s, Spath[t], path);	<span class="comment">// 输出s-&gt;v的前驱结点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t);				<span class="comment">// 输出v</span></span><br><span class="line">	path.push_back(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>【堆优化版】</strong></p>
<p>前面介绍的算法时间复杂度为 $O(n^2)$ ，如果边数远小于 n^2 ，可以考虑使用小顶堆进行优化，这样每次取出距离s最小的结点的复杂度为 $O(1)$ ，每次更新进行调整的复杂度为 $O(elogn)$ 。</p>
<p>步骤如下：</p>
<ol>
<li>将源点s加入堆，并调整堆；</li>
<li>取出堆顶元素u（即距离源点s最近的结点），从堆中删除，并对堆进行调整；</li>
<li>对所有与u相邻的，未访问过的，满足三角不等式的顶点v进行一次松弛操作：<ul>
<li>若v在堆中，更新距离，并调整该元素在堆中的位置；</li>
<li>若点v不在堆中，加入堆，并调整堆。</li>
</ul>
</li>
<li>重复上述操作，直到所有结点都被松弛过。</li>
</ol>
<p><strong>【拓展拔高】</strong></p>
<p>前面介绍了Dijkstra算法的基本思想和用法，但实际上，题目肯定不会考得这么 “裸” ，更多时候会出现这样一种情况：</p>
<ul>
<li>即<strong>从起点到终点的最短距离最小的路径不止一条</strong>。</li>
</ul>
<p>此时，题目会给出一个第二标尺（第一标尺是距离），要求<strong>在所有最短路径中选择第二标尺最优的一条路径</strong>。</p>
<p>第二标尺常见有下面三种出题方法：</p>
<ol>
<li>给每条边再增加一个边权（比如花费），要求花费之和最小；</li>
<li>给每个点增加一个点权（例如每个城市能收集到的物资），要求点权之和最大；</li>
<li>直接问有多少条最短路径。</li>
</ol>
<h4 id="2）Bellman-Ford-算法和-SPFA-算法"><a href="#2）Bellman-Ford-算法和-SPFA-算法" class="headerlink" title="2）Bellman-Ford 算法和 SPFA 算法"></a>2）Bellman-Ford 算法和 SPFA 算法</h4><p>Dijkstra 算法可以很好地解决<strong>无负权图</strong>的最短路径问题，但如果出现了负权边，Dijkstra 算法就会失效。</p>
<p>为了解决这个问题，就需要使用 <strong>Bellman-Ford</strong> 算法（简称 BF 算法）。</p>
<p>现在考虑环，根据环中每条边的边权之和，可以将环分为<strong>零环、正环、负环</strong>，如下图所示。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210309135136002.png" alt="image-20210309135136002" style="zoom:80%;" />



<p>显然，</p>
<ul>
<li>图中的零环和正环不会影响最短路径的求解，因为零环和正环的存在不能使最短路径更短；</li>
<li>如果图中有负环，且<strong>从源点可以到达</strong>，那么就会影响最短路径的求解。但如果负环无法从源点出发到达，那么就最短路径不会受到影响。</li>
</ul>
<p>与 Dijkstra 算法相同，Bellman-Ford 算法设置一个数组d，用来存放从源点到达各个顶点的最短距离。同时 Bellman-Ford 算法返回一个bool值：如果其中<strong>存在从源点可达的负环</strong>，那么函数将返回 false。</p>
<p><strong>【基本思想】</strong></p>
<p>Bellman-Ford 算法的主要思路如下：</p>
<ul>
<li>需要对图中的边进行 <strong>V - 1</strong> 轮操作，每轮都遍历图中的所有边。</li>
<li>对每条边 u→v，如果以u为中介点可以使 d[v] 更小，即 d[u] + length[u-&gt;v] &lt; d[v] 乘以，就用 d[u] + length[u-&gt;v] 更新 d[v]。</li>
</ul>
<p>可以看出，Bellman-Ford 算法的时间复杂度为 $O(VE)$ 。</p>
<blockquote>
<p>关于Bellman-Ford 算法的正确性：</p>
<ul>
<li><p>如果把源点s作为一棵树的根结点，那么其他结点按照最短路径的结点顺序连接，就会生成一棵<strong>最短路径树</strong>。</p>
</li>
<li><p>显然，在最短路径树中，从源点s到达其余各顶点的路径就是原图中对应的最短路径。且<strong>一旦原图和源点确定，最短路径树也就确定了</strong>。此外，由于最短路径上的顶点不超过V个，因此<strong>最短路径树的层数一定不会超过V</strong>。</p>
</li>
</ul>
<p>那么为什么要执行 V-1轮呢？</p>
<ul>
<li>由于初始状态下 d[s] 为0，且之后不会再改变（即最短路径树中第一层结点的d值被确定）；</li>
<li>通过第一轮操作后，最短路径树中的第二层顶点（从源点s能够直达的点）的d值也会被确定下来；然后通过第二轮操作，第三层的值也会被确定下来，…，以此类推；</li>
<li>由于最短路径树的层数不超过V层，因此Bellman-Ford算法的<strong>松弛操作不会超过V-1轮</strong>。</li>
</ul>
</blockquote>
<p><strong>【伪代码】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;	<span class="comment">// 执行V-1轮</span></span><br><span class="line">    <span class="keyword">for</span>(each edge u-&gt;v) &#123;		<span class="comment">// 每轮操作都遍历所有边</span></span><br><span class="line">        <span class="keyword">if</span>(d[u] + length[u-&gt;v] &lt; d[v]) &#123;	<span class="comment">// 以u为中介点可以使d[v]更小</span></span><br><span class="line">            d[v] = d[u] + length[u-&gt;v];		<span class="comment">// 松弛操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果图中没有从源点可达的负环，那么d中的所有值都应当已经达到最优。</span></span><br><span class="line"><span class="keyword">for</span>(each edge u-&gt;v) &#123;		<span class="comment">// 对每条边进行判断</span></span><br><span class="line">    <span class="keyword">if</span>(d[u] + length[u-&gt;v] &lt; d[v]) &#123;	<span class="comment">// 如果仍然可以被松弛</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">// 说明图中有从源点可达的负环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<p><strong>【邻接表版】</strong></p>
<p>由于 Bellman-Ford 算法需要遍历所有边，显然使用邻接表会比较方便，如果使用邻接矩阵，则时间复杂度会上升到 $O(V^3)$ .</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;		<span class="comment">// v为邻接边的目标顶点，dis为邻接边的边权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];	<span class="comment">// 图G的邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    fill(d, d + MAXN, INF);		<span class="comment">// 将整个d数组赋为 F</span></span><br><span class="line">    d[s] = <span class="number">0</span>;		<span class="comment">// 起点s到达自身的距离为0</span></span><br><span class="line">    <span class="comment">// 以下为求解数组d的部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;	<span class="comment">// 执行n-1轮操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;	<span class="comment">// 每轮操作遍历所有边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Adj[u].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = Adj[u][j].v;	<span class="comment">// 邻接边的顶点</span></span><br><span class="line">                <span class="keyword">int</span> dis = Adj[u][j].dis;<span class="comment">// 邻接边的边权</span></span><br><span class="line">                <span class="keyword">if</span>(d[u] + dis &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[i] + dis;	<span class="comment">// 松弛操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下为判断负环的代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;	<span class="comment">// 对每条边进行判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Adj[u].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;	</span><br><span class="line">            <span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u] + dis &lt; d[v]) &#123;	<span class="comment">// 如果仍然可以被松弛</span></span><br><span class="line">                <span class="keyword">return</span> fasle;	<span class="comment">// 说明图中有从源点可达的负环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// 数组d的所有值都已经达到最优</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>【优化：SPFA算法】</strong></p>
<p> Bellman-Ford 算法的每轮操作都需要遍历所有边，显然这其中会有大量无意义的操作，严重影响了算法的性能。于是注意到：</p>
<ul>
<li>**只有当某个顶点 u 的 d[u] 值改变时，从它出发的边的邻接点 v 的 d[v] 值才有可能被改变 **。</li>
</ul>
<p>由此可以进行一个<strong>优化</strong>：</p>
<ol>
<li>建立一个队列，每次将队首顶点 u 取出，然后对从u出发的所有边 u→v 进行松弛操作，也就是判断 d[u] + length[u-&gt;v] &lt; d[v] 是否成立；如果成立，更新 d[v] ，此时如果 v 不在队列中，就把 v 加入队列。</li>
<li>重复这样的操作直到队列为空（说明图中没有从源点可达的负环），或是某个顶点的入队次数超过 V-1（说明图中存在从源点的可达的负环）。</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    取出队首元素u;</span><br><span class="line">    <span class="keyword">for</span>(u的所有邻接边u-&gt;v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u] + dis &lt; d[v]) &#123;	<span class="comment">// 松弛操作</span></span><br><span class="line">            d[v] = d[u] + dis;</span><br><span class="line">            <span class="keyword">if</span>(!inq[v]) &#123;	<span class="comment">// v不在队列中</span></span><br><span class="line">                v入队;</span><br><span class="line">                <span class="keyword">if</span>(v入队次数大于n<span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>	<span class="comment">// 说明有可达负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这种优化后的算法被称为 <strong>SPFA（Shortest Path Faster Algorithm）</strong>，它的期望时间复杂度是 $O(kE)$ ，且在很多情况下 k 不会超过2，因此十分高效。但如果图中存在从源点可达的负环，传统 SPFA 的时间复杂度就会退化成 $O(VE)$ 。</p>
<p><strong>理解 SPFA 的关键是理解它是如何从 Bellman-Ford算法优化得来的。</strong></p>
<p>邻接表版的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, d[MAXN], num[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN];		<span class="comment">// 顶点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化部分</span></span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    fill(d, d+MAXN, INF);</span><br><span class="line">    <span class="comment">// 源点入队部分</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);	</span><br><span class="line">    inq[s] = <span class="literal">true</span>;	<span class="comment">//源点已入队</span></span><br><span class="line">    num[s]++;		<span class="comment">//源点入队次数加1</span></span><br><span class="line">    d[s] = <span class="number">0</span>;		<span class="comment">//源点的d值为0</span></span><br><span class="line">    <span class="comment">// 主体部分</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();	<span class="comment">// 队首顶点编号为u</span></span><br><span class="line">        q.pop(u);</span><br><span class="line">        inq[u] = <span class="literal">false</span>;		<span class="comment">// 设置u不在队列中</span></span><br><span class="line">        <span class="comment">// 遍历u的所有邻接边v</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Adj[u].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line">            <span class="comment">// 松弛操作</span></span><br><span class="line">            <span class="keyword">if</span>(d[u] + dis &lt; d[v]) &#123;</span><br><span class="line">                d[v] = d[u] + dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;	<span class="comment">// v不在队列中</span></span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v] = <span class="literal">true</span>;</span><br><span class="line">                    num[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v] &gt;= n)	<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// 有可达负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// 无可达负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>SPFA 十分灵活，其内部写法可以根据具体场景的不同进行调整，例如把上面的FIFO队列替换成优先队列（priority_queue），以加快速度。除此之外，上面的代码是BFS版本，如果将队列替换成栈，则可以实现DFS版本的SPFA，对判环有奇效。</p>
<h4 id="3）Floyd算法"><a href="#3）Floyd算法" class="headerlink" title="3）Floyd算法"></a>3）Floyd算法</h4><p>Floyd 算法（弗洛伊德）用来解决<strong>全源最短路径问题</strong>，即对给定的图 $G(V, E)$，求任意两点u，v之间的最短路径长度，时间复杂度是 $O(n^3)$ 。</p>
<p>Floyd 算法基于这样一个事实：</p>
<ul>
<li><p>如果存在顶点k，使得以k作为中介点时，顶点i和顶点j的当前最短距离缩短，则使用顶点k作为i和j的中介点。</p>
<p>即当 $dis[i][k] + dis[k][j] &lt; dis[i][j]$ 时，令 $dis[i][j] = dis[i][k] + dis[k][j]$。</p>
</li>
</ul>
<p>由此，Floyd算法的流程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">枚举顶点 k in [<span class="number">1</span>, n]</span><br><span class="line">    以顶点k作为中介点，枚举所有顶点对i和j</span><br><span class="line">    	如果 dis[i][k] + dis[k][j] &lt; dis[i][j] 成立</span><br><span class="line">    		令 dis[i][j] = dis[i][k] + dis[k][j]</span><br></pre></td></tr></table></figure>
<p>可以看到，Floyd算法的思想异常简洁，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k] + dis[k][j] &lt; dis[i][j]) &#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于 Floyd 算法来说，需要注意的是：</p>
<ul>
<li><strong>不能将最外层的k循环放到内层</strong>，这会导致最后结果出错。</li>
<li>使用与 Dij 同样的 $path$ 输出的最短路径是结果不正确的，因为 k 只是保证了 i 经过 k 到达 j 路径最短，无法保证能从k直接到j。</li>
</ul>
<p>Floyd算法适用于APSP(AllPairsShortestPaths)，是一种动态规划算法，稠密图效果最佳，边权可正可负。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行 V 次Dijkstra算法。</p>
<h3 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5. 最小生成树"></a>5. 最小生成树</h3><p>最小生成树（Minimum Spanning Tree，MST）是在一个给定的<strong>无向图 G(V, E)</strong> 中求一棵树T，使得这棵树拥有图G中的所有顶点，且所有边都是来自图G中的边，并且满足<strong>整棵树的边权之和最小</strong>。</p>
<p>最小生成树有3个性质：</p>
<ol>
<li>最小生成树是树，因此其<strong>边数等于顶点数减1</strong>，且树内一定不会有环；</li>
<li>对给定的图 G(V, E)，其最<strong>小生成树可以不唯一</strong>，但其<strong>边权之和一定是唯一的</strong>；</li>
<li>由于最小生成树是在无向图上生成的，因此其根结点可以使这棵树上的任意一个节点。</li>
</ol>
<p>求解最小生成树一般由两种算法，即 prim 算法与 kruskal 算法那，均采用<strong>贪心法</strong>的思想。</p>
<h4 id="1）Prim-算法"><a href="#1）Prim-算法" class="headerlink" title="1）Prim 算法"></a>1）Prim 算法</h4><p>prim 算法（也称普里姆算法）用于解决最小生成树问题。</p>
<p><strong>【基本思想】</strong></p>
<p>对图 G(V, E) 设置集合S，存放已被访问的顶点，然后重复下面的操作n次，直到集合S已包含所有顶点：</p>
<ol>
<li>每次从集合 V-S 中选择 <strong>与集合S的最短距离最小</strong>的一个顶点（记为u），访问并加入集合S，同时把这条离集合S最近的边加入最小生成树中；</li>
<li>之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合S之间的最短距离。</li>
</ol>
<p>可以发现，prim与Dijkstra的算法思想几乎完全相同，区别在于涉及最短距离时<strong>使用了「集合S」代替 Dijkstra中的「起点s」</strong>。</p>
<p><strong>【具体实现】</strong></p>
<ul>
<li>集合S的实现方法与Dij相同，即使用一个 vis[] 表示顶点是否被访问；</li>
<li>使用 d[] 来存放顶点 $V_i$ 与集合S的最短距离。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Prim(G, d[]) &#123;</span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环n次) &#123;</span><br><span class="line">        u = 使d[u]最小的还未被访问的顶点</span><br><span class="line">        记u已被访问</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达地所有顶点v) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v未被访问 &amp;&amp; 以u为中介点使得v与集合S的最短距离d[v]更优) &#123;</span><br><span class="line">                令v与集合S的最短距离d[v] = G[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，prim与Dijkstra实际上是相同的思路，只不过是数组 d[] 的含义不同罢了。</p>
<p><strong>【邻接矩阵版】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, G[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];	<span class="comment">// 顶点与集合S的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">// 标记数组，相当于集合S</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;	<span class="comment">// 默认0号为初始点，函数返回最小生成树的边权之和</span></span><br><span class="line">	fill(d, d + MAXN, INF);	<span class="comment">// fill函数将整个d数组赋为INF</span></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, MIN = INF;	<span class="comment">// u使d[u]最小，MIN存放该最小的d[u]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若找不到小于INF的d[u]，则剩下的顶点和集合S不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;	<span class="comment">// 标记u为已访问过</span></span><br><span class="line">        ans += d[u];	<span class="comment">// 将与集合S举例最小的边加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="comment">// v未访问 &amp;&amp; 以u为中介可以使v离集合S更近</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                d[v] = G[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;	<span class="comment">// 返回最小生成树的边权之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>和 Dijkstra 算法一样，使用这种写法的时间复杂度为 $O(V^2)$ 。</p>
<h4 id="2）Kruskal-算法"><a href="#2）Kruskal-算法" class="headerlink" title="2）Kruskal 算法"></a>2）Kruskal 算法</h4><p>kruskal 算法（也称为克鲁斯卡尔算法），采用了<strong>边贪心</strong>的策略，其思想极其简洁，理解难度比prim要低很多。</p>
<p><strong>【基本思想】</strong></p>
<p>在初始状态时隐去图中的所有边，这样图中每个顶点都自成一个连通块。之后执行下面的步骤：</p>
<ol>
<li>对所有边按边权从小到大排序；</li>
<li>按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个连通块中，则把这条测试边加入当前最小生成树中；否则将边舍弃。</li>
<li>重复步骤2，直到最小生成树中的<strong>边数等于总顶点数减1</strong>或是测试完所有边时结束。如果结束时最小生成树的边数小于总顶点数减1，说明该图不连通。</li>
</ol>
<p>因此，kruskal 算法的思想简单来说就是：<strong>每次选择图中边权最小的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树中</strong>。</p>
<p><strong>【伪代码】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    令最小生成树的边权之和为ans、最小生成树的当前变数为Num_Edge;</span><br><span class="line">    将所有边按边权从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(从小到大枚举所有边) &#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中) &#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans += 测试边的边权;</span><br><span class="line">            最小生成树的当前边数Num_Edge加<span class="number">1</span>;</span><br><span class="line">            当边数Num_Edge等于顶点数减<span class="number">1</span>时结束循环;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这个伪代码里有两个细节似乎不太直观，即：</p>
<ol>
<li>如何判断测试边的两个端点是否在不同的连通块中。</li>
<li>如何将测试边加入最小生成树中。</li>
</ol>
<p>事实上，可以换一个角度来想。如果把每个连通块当作一个集合，那么就可以把问题转换为判断两个端点是否在同一个集合中，而这个问题在前面讨论过——对，就是<strong>并查集</strong>。</p>
<p>并查集可以通过查询两个结点所在集合的根结点是否相同来判断它们是否在同一个集合，而合并功能恰好可以把上面提到的第二个细节解决，即只要<strong>把测试边的两个端点所在集合合并</strong>，就能达到将边加入最小生成树的效果。</p>
<p><strong>【具体实现】</strong></p>
<p>于是可以根据上面的解释，把 kruskal 算法的代码写出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;	<span class="comment">// 边的两个端点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost;	<span class="comment">// 边权</span></span><br><span class="line">&#125;E[MAXE];		<span class="comment">// 最多有MAXE条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[N];	<span class="comment">// 并查集数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;		<span class="comment">// 并查集查询函数</span></span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kruskal函数返回最小生成树的边权之和，n为顶点个数，m为图的边数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, numEdge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;	<span class="comment">// 假设顶点范围是[1,n]</span></span><br><span class="line">    	father[i] = i;		<span class="comment">// 并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(E, E + m, cmp);	<span class="comment">// 所有边按边权从小到大排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;	<span class="comment">// 从小到大枚举所有边</span></span><br><span class="line">        edge e = E[i];</span><br><span class="line">        <span class="keyword">int</span> faU = findFather(e.u);</span><br><span class="line">        <span class="keyword">int</span> faV = findFather(e.v);</span><br><span class="line">        <span class="keyword">if</span>(faU != faV) &#123;			<span class="comment">// 如果两个</span></span><br><span class="line">            father[faU] = faV;</span><br><span class="line">            ans += e.cost;</span><br><span class="line">            numEdge++;</span><br><span class="line">            <span class="keyword">if</span>(numEdge == n<span class="number">-1</span>)	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，kruskal 算法的时间复杂度主要来源于对边进行排序，因此其时间复杂度是 $O(ElogE)$。显然，kruskal 算法适合顶点数较多、边数较少的情况。</p>
<p>于是，可以根据实际情况选择合适的算法：</p>
<ul>
<li>如果是<strong>稠密图（边多）</strong>，则用 prim 算法；如果是<strong>稀疏图（边少）</strong>，则用 kruskal 算法。</li>
</ul>
<h3 id="6-拓扑排序"><a href="#6-拓扑排序" class="headerlink" title="6. 拓扑排序"></a>6. 拓扑排序</h3><ul>
<li><p>如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为<strong>有向无环图</strong>（Directed Acyclic Graph, DAG）。</p>
</li>
<li><p><strong>拓扑排序</strong>是将有向无环图 G 的所有顶点排成一个线性序列，使得对图 G 中的任意两个顶点u、v，如果存在边 u-&gt;v，那么在序列中u一定在v前面。这个序列又被称为<strong>拓扑序列</strong>。</p>
</li>
</ul>
<p><strong>【算法步骤】</strong></p>
<ol>
<li>定义一个队列 Q，并把所有入度为0的结点加入队列；</li>
<li>取队首结点，输出。然后扇区所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点的入度减为0，则将其加入队列；</li>
<li>反复执行操作2，直到队列为空。如果队空时入过队的结点数目恰好为N，说明拓扑排序成功，图G为有向无环图；否则，失败，图G中有环。</li>
</ol>
<p>可使用邻接表实现拓扑排序，并用数组 inDegree[MAXN] 来计入结点的入度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];	<span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> n, m, inDegree[MAXN];	<span class="comment">// 顶点数、入度</span></span><br><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;	<span class="comment">// 记录加入拓扑排序的顶点数</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 初始化，将所有入度为0的结点入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 主过程</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();		<span class="comment">// 取队首顶点u</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, u);		<span class="comment">// 输出顶点u</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;	<span class="comment">// 遍历从u出发的所有边</span></span><br><span class="line">			<span class="keyword">int</span> v = G[u][i];	<span class="comment">// u的后继结点v</span></span><br><span class="line">			inDegree[v]--;</span><br><span class="line">			<span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>) &#123;	<span class="comment">// 如果顶点v的入度减为0，则入队</span></span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		G[u].clear();	<span class="comment">// 清空顶点u的所有出边（如无必要可不写）</span></span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num == n)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>拓扑排序一个很重要的应用就是<strong>判断一个给定的图是否是有向无环图（DAG）</strong>。</p>
<h3 id="7-关键路径"><a href="#7-关键路径" class="headerlink" title="7. 关键路径"></a>7. 关键路径</h3><h4 id="1）AOV网和AOE网"><a href="#1）AOV网和AOE网" class="headerlink" title="1）AOV网和AOE网"></a>1）AOV网和AOE网</h4><ul>
<li><p><strong>顶点活动（Activity On Vertex，AOV）网</strong>是指用<strong>顶点表示活动</strong>，而用<strong>边集表示活动间优先关系</strong>的有向图。</p>
<ul>
<li><p>如下图，顶点表示各项课程，也就是“活动”。</p>
</li>
<li><p>有向边表示活动的先导关系，也就是“活动的优先关系”。显然，图中不应当存在有向环，否则会让优先关系出现逻辑错误。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210309213000149.png" alt="image-20210309213000149" style="zoom:80%;" />
</li>
</ul>
</li>
<li><p><strong>边活动（Activity On Edge，AOE）网</strong>是指用<strong>带权的边集表示活动</strong>，而用<strong>顶点表示事件</strong>的有向图，其中边权表示完成活动需要的时间。</p>
<ul>
<li>如下图，边 $a_1-a_6$ 表示需要学习的课程，也就是 “活动”，边权表示需要学习的时间。</li>
<li>顶点 $V_1-V_6$ 表示到此刻为止，前面的课程已经学完，可以开始学习后面的课程了。显然”事件”仅代表一个中介状态。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210309212744080.png" alt="image-20210309212744080" style="zoom:80%;" />



</li>
</ul>
<p>AOE网是基于工程提出的概念，需要着重解决两个问题：</p>
<ol>
<li>工程起始到终止至少需要多少时间；</li>
<li>哪些路径上的活动是影响整个工程的关键。</li>
</ol>
<p>AOE网中的最长路径被称为关键路径（强调：<strong>关键路径就是AOE网的最长路径</strong>），而把关键路径上的活动称为<strong>关键活动</strong>。</p>
<h4 id="2）最长路径"><a href="#2）最长路径" class="headerlink" title="2）最长路径"></a>2）最长路径</h4><p>前面详细介绍过求解最短路径的三种算法，这里再简单介绍下如何求解最长路径。</p>
<p>对一个<strong>没有正环的图</strong>（指从源点可达的正环，下同），如果需要求最长路径长度，则可以把所有边的边权乘以-1，令其变为相反数，然后使用 Bellman-Ford 算法或 SPFA 算法求最短路径长度，将所得结果取反即可。</p>
<blockquote>
<p><strong>注意</strong>∶此处不能使用 Dijkstra 算法，原因是 Dijksta算法不能处理负边权的情况，即便原图的边权均为正，乘以-1 之后也会出现负权。</p>
</blockquote>
<p>显然，如果图中有正环，那么最长路径是不存在的。</p>
<p>但是，如果需要求<strong>最长简单路径</strong>（也就是每个顶点最多只经过一次的路径），那么虽然最长简单路径本身存在，却没有办法通过 Bellman-Ford 等算法来求解，原因是最长路径问题是 <strong>NP-Hard</strong> 问题（也就是没有多项式时间复杂度算法的问题）。</p>
<h4 id="3）关键路径"><a href="#3）关键路径" class="headerlink" title="3）关键路径"></a>3）关键路径</h4><p>由于关键路径是有向无环图（DAG）中的最长路径，因此求解关键路径实际上就是<strong>求解DAG中的最长路径</strong>。</p>
<ul>
<li>由于关键活动是那些不允许拖延的活动，因此这些活动的<strong>最早开始时间必须等于最迟开始时间</strong>。</li>
</ul>
<p>故可以设置数组 $e$ 和 $l$ ，其中 <strong>$e[r]$ 和 $l[r]$ 分别表示活动 $a_r$ 的最早开始时间和最迟开始时间</strong>，从而可以通过判断 <code>e[r] == l[r]</code> 是否成立来确定活动 r 是否是关键活动。</p>
<p>那么问题便转化为了<strong>「如何求解数组 $e$ 和 $l$ 」</strong>。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210310091937996.png" alt="image-20210310091937996" style="zoom:80%;" />

<ul>
<li>如上图，注意到顶点作为事件（一个中介状态），也有拖延的可能，因此会存在最早发生时间和最迟发生时间。其中，<ul>
<li><strong>事件的最早发生时间可以理解成就活动的最早结束时间</strong>；</li>
<li><strong>事件的最迟发生时间可以理解成新活动的最迟开始时间</strong>；</li>
</ul>
</li>
</ul>
<p>故可以设置数组 $ve$ 和 $vl$ ，其中 $ve[i]$ 和 $vl[i]$ 分别表示事件 $i$ 的最早发生时间和最迟发生时间。</p>
<ol>
<li>对于活动 $a_r$ 来说，只要在事件 $V_i$ 最早发生时马上开始，就可以使得活动 $a_r$ 的开始时间最早，因此 $e[r] = ve[i]$ ；</li>
<li>同样对于活动 $a_r$ ，它最迟必须在事件 $V_j$ 最迟发生时结束，即有 $l[r] + length[r] = vl[j]$ ，这样就得到了活动 $a_r$ 的最迟开始时间，$l[r] = vl[j] - length[r]$ 。</li>
</ol>
<p>这样问题便进一步转化为了<strong>「如何求解数组 $ve$ 和 $vl$ 」</strong>。</p>
<h5 id="（1）求解-ve"><a href="#（1）求解-ve" class="headerlink" title="（1）求解 ve"></a>（1）求解 ve</h5><p>如下图所示，有 k 个事件 $V_{i1} - V_{ik}$ 通过相应的活动 $a_{r1} - a_{rk}$ 到达事件 $V_j$  ，活动的边权为 $length[r1] - length[rk]$ 。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210310094842864.png" alt="image-20210310094842864" style="zoom:80%;" />



<p>对于当前事件 $V_j$ ，<strong>只有在所有到达 $V_j$ 的活动都完成之后，$V_j$ 才能被 “激活”。</strong></p>
<p>假设已经计算好了所有前驱事件 $V_{i1} - V_{ik}$ 的最早发生时间 $ve[i1] - ve[ik]$ ，那么事件 $V_j$ 的最早发生时间就是 $max(ve[ip] + length[rp])$  ，数学描述如下：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210310095629347.png" alt="image-20210310095629347" style="zoom:80%;" />

<p>于是我们知道，想要获得 $ve[j]$ 的值，必须保证 $ve[i1] - ve[ik]$ 都已得到，即<strong>在访问某个结点时要保证它的前驱结点都已经访问完毕</strong>。</p>
<p>显然，使用<strong>拓扑排序</strong>就可以办得到：</p>
<ul>
<li>当按照拓扑序列计算 $ve$ 数组时，总是能保证在计算 $ve[j]$ 的时候 $ve[i1] - ve[ik]$ 都已经得到。</li>
</ul>
<p>但这时又出现了「新的问题」：</p>
<ul>
<li>通过前驱结点去寻找所有后继结点很容易，但是通过后继结点 $V_j$ 去寻找它的前驱结点 $V_{i1} - V_{ik}$ 似乎没有那么直观。</li>
</ul>
<p>一个比较好的办法是：</p>
<ul>
<li>在拓扑排序访问到某个结点 $V_i$ 时，<strong>不是让它去找前驱结点来更新 $ve[i]$ ，而是使用 $ve[i]$ 去更新其所有后继结点的 $ve$ 值</strong>。</li>
</ul>
<p>通过这个方法，可以让拓扑排序访问到 $V_j$ 的时候，$V_{i1} - V_{ik}$一定都已经用来更新过$ve[j]$ ，此时的 $ve[j]$ 便是正确值，就可以用它去更新 $V_j$ 的所有后继结点的 $ve$ 值。</p>
<p>这部分的代码下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; topOrder;	<span class="comment">// 拓扑序列</span></span><br><span class="line"><span class="comment">// 拓扑排序，顺便求ve数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        topOrder.push(u);	<span class="comment">// 将u加入拓扑序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v;	<span class="comment">// 获得u的第i号后继结点v</span></span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用ve[u]来更新u的所有后继结点v</span></span><br><span class="line">            <span class="keyword">if</span>(ve[u] + G[u][i].w &gt; ve[v]) &#123;</span><br><span class="line">                ve[v] = ve[u] + G[u][i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(topOder.size() == n)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    esle 	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）求解-vl"><a href="#（2）求解-vl" class="headerlink" title="（2）求解 vl"></a>（2）求解 vl</h5><p>如下图所示，从事件 $V_j$  出发通过相应的活动 $a_{r1} - a_{rk}$  可以到达 k 个事件 $V_{i1} - V_{ik}$ ，活动的边权为 $length[r1] - length[rk]$ 。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210310101606113.png" alt="image-20210310101606113" style="zoom:80%;" />

<p>对于当前事件 $V_i$ ，<strong>必须保证 $V_{j1} - V_{jk}$ 的最迟发生时间 $vl[j1] - vl[jk]$ 能被满足</strong> 。</p>
<p>假设已经计算好了所有后继事件 $V_{j1} - V_{jk}$ 的最迟发生时间 $vl[j1] - vl[jk]$ ，那么事件 $V_j$ 的最迟发生时间就是 $min(vl[jp] - length[rp])$  ，数学描述如下：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210310102600515.png" alt="image-20210310102600515" style="zoom:80%;" />



<p>和 $ve$ 数组类似，想要获得 $vl[i]$ 的值，必须保证 $vl[j1] - vl[jk]$ 都已得到，即<strong>在访问某个结点时要保证它的后继结点都已经访问完毕</strong>，这个要求与 $ve$ 正好相反，而这个可以通过<strong>逆拓扑序列</strong>来实现。</p>
<p>实际上，我们上面在求解 $ve$ 时使用栈来存储拓扑序列，那么只需要按顺序出栈即可得到逆拓扑序列。</p>
<p>这部分的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fill(vl, vl + n, ve[n<span class="number">-1</span>]);	<span class="comment">// vl数组初始化，初始值为终点的ve值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用topOrder的出栈序列，求解vl数组</span></span><br><span class="line"><span class="keyword">while</span>(!topOrder.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = topOrder.top();	<span class="comment">// 栈顶元素为u</span></span><br><span class="line">    topOrder.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i].v;	<span class="comment">// u的后继结点v</span></span><br><span class="line">        <span class="comment">// 用u的所有后继结点v的vl值来更新vl[u]</span></span><br><span class="line">        <span class="keyword">if</span>(vl[v] - G[u][i].w &lt; vl[u]) &#123;</span><br><span class="line">            vl[u] = vl[v] - G[u][i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）求解关键活动"><a href="#（3）求解关键活动" class="headerlink" title="（3）求解关键活动"></a>（3）求解关键活动</h5><p>下面给出上面过程的步骤总结，即 “<strong>先求点，再夹边</strong>” ：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer Science/Algorithm/image-20210310104005527.png" alt="image-20210310104005527" style="zoom:80%;" />



<p>主体部分代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键路径，不是有向无环图返回-1.否则返回关键路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CriticalPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(ve));	<span class="comment">// ve数组初始化</span></span><br><span class="line">    <span class="keyword">if</span>(topologicalSort() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;		<span class="comment">// 不是有向无环图返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    fill(vl, vl + n, ve[n - <span class="number">1</span>]);	<span class="comment">// vl数组初始化，初始值为汇点的ve值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接使用topOrder的出栈序列，求解vl数组</span></span><br><span class="line">    <span class="keyword">while</span>(!topOrder.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = topOrder.top();	<span class="comment">// 栈顶元素为u</span></span><br><span class="line">        topOrder.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v;	<span class="comment">// u的后继结点v</span></span><br><span class="line">            <span class="comment">// 用u的所有后继结点v的vl值来更新vl[u]</span></span><br><span class="line">            <span class="keyword">if</span>(vl[v] - G[u][i].w &lt; vl[u]) &#123;</span><br><span class="line">                vl[u] = vl[v] - G[u][i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历邻接表的所有边，计算活动的最早开始时间e和最迟开始时间l</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v, w = G[u][i].w;</span><br><span class="line">            <span class="comment">// 活动的最早开始时间e和最迟开始时间l</span></span><br><span class="line">            <span class="keyword">int</span> e = ve[u], l = vl[v] - w;</span><br><span class="line">            <span class="comment">// 如果 e==l，说明活动u-&gt;v是关键活动</span></span><br><span class="line">            <span class="keyword">if</span>(e == l) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%d&quot;</span>, u, v);		<span class="comment">// 输出关键活动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ve[n - <span class="number">1</span>];	<span class="comment">// 返回关键路径长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>如果<strong>事先不知道汇点编号</strong>，取 $ve$ 数组的最大值即可。原因在于，$ve$ 的含义是事件的最早开始时间，因此所有事件中 ve 最大的一定是最后一个（或多个）事件，也就是汇点。 </p>
</li>
<li><p>如果要<strong>完整输出所有关键路径</strong>，就需要把关键活动存下来，可以用新建一个邻接表来存储，最后再DFS一下获取所有关键路径。 </p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jay1zhang.github.io/2021/03/05/Computer%20Science/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/">http://jay1zhang.github.io/2021/03/05/Computer%20Science/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="http://jayyy1.gitee.io/images/pictures/cartoons/020.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/10/Review/%E3%80%8C%E6%82%A6%E8%AF%BB%E6%84%9F%E6%82%9F%E3%80%8D%E4%BD%A0%E5%90%AC%E5%95%8A%EF%BC%8C%E7%A7%8B%E6%9C%AB%E7%9A%84%E8%90%BD%E5%8F%B6/"><img class="prev-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/018.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">「悦读感悟」你听啊，秋末的落叶 —— 《且听风吟》</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/03/BUAA/%E3%80%8CPaper%E3%80%8D%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"><img class="next-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/003.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">「Paper」一文解决参考文献格式问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/01/23/Computer Science/Algorithm/「LeetCode题解」数据结构专题/" title="「LeetCode题解」数据结构专题"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/017.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">「LeetCode题解」数据结构专题</div></div></a></div><div><a href="/2021/01/23/Computer Science/Algorithm/「算法思想」《编程珠玑》学习笔记/" title="「算法思想」《编程珠玑》学习笔记"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/040.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">「算法思想」《编程珠玑》学习笔记</div></div></a></div><div><a href="/2021/03/13/Computer Science/Algorithm/「算法进阶」《算法导论》高级算法设计与分析/" title="「算法进阶」《算法导论》高级算法设计与分析"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/032.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-13</div><div class="title">「算法进阶」《算法导论》高级算法设计与分析</div></div></a></div><div><a href="/2021/01/22/Computer Science/Algorithm/「LeetCode题解」算法设计专题/" title="「LeetCode题解」算法设计专题"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/023.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">「LeetCode题解」算法设计专题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-C-C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">0x00 C&#x2F;C++ 程序设计基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">黑盒测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E4%B8%93%E9%A2%98"><span class="toc-text">0x01 算法入门专题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98"><span class="toc-text">1. 表达式计算问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">1）中缀表达式计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2）后缀表达式转中缀表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-text">2. 字符串匹配问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0"><span class="toc-text">3. 快速线性筛法求素数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89"><span class="toc-text">0x02 C++ 标准模板库（STL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vector"><span class="toc-text">1. vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89vector%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1）vector的定义与初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89vector%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）vector容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89vector%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）vector常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-set"><span class="toc-text">2. set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-string"><span class="toc-text">3. string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89string%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）string的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89string-%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）string 中内容的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">3）string常用函数示例解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-map"><span class="toc-text">4. map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89map%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）map的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89map%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）map容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89map%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）map常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-queue"><span class="toc-text">5. queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89queue%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）queue的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）queue容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）queue常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-priority-queue"><span class="toc-text">6. priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89priority-queue%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）priority_queue的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89priority-queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）priority_queue容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89priority-queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）priority_queue常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89priority-queue%E5%86%85%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">4）priority_queue内元素优先级的设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-stack"><span class="toc-text">7. stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89stack%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）stack的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）stack容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）stack常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-pair"><span class="toc-text">8. pair</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89pair%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）pair的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89pair%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）pair中元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89pair%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）pair常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">9. algorithm头文件下的常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-text">1. 基本运算函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-next-permutation"><span class="toc-text">2. next_permutation()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-reverse"><span class="toc-text">3. reverse()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-fill"><span class="toc-text">4. fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-lower-bound-%E5%92%8C-upper-bound"><span class="toc-text">5. lower_bound() 和 upper_bound()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-sort"><span class="toc-text">6. sort()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-sort-%E6%8E%92%E5%BA%8F"><span class="toc-text">1）如何使用 sort 排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0-cmp"><span class="toc-text">2）如何实现比较函数 cmp</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98"><span class="toc-text">0x03 数据结构专题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-text">1. 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-text">2. 队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8"><span class="toc-text">3. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1）链表的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%B8%BA%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">2）为链表结点分配内存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">3）链表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4. 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8"><span class="toc-text">1）树的定义与性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">2）二叉树的存储结构与基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">3）二叉树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E4%BB%8E%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4）从遍历序列中重建二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E4%BB%8E%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%9C%8B-DFS-%E4%B8%8E-BFS"><span class="toc-text">5）从树的遍历看 DFS 与 BFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%91%E7%9A%84%E5%BB%B6%E4%BC%B8%E7%AE%97%E6%B3%95"><span class="toc-text">5. 树的延伸算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-text">1）二叉查找树（BST）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-text">（1）查找操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">（2）插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="toc-text">（3）创建操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">（4）删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">（5）二叉查找树的性质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="toc-text">2）平衡二叉树（AVL）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-1"><span class="toc-text">（1）查找操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">（2）旋转操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">（3）插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="toc-text">（4）创建操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">3）并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">（1）初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E6%89%BE"><span class="toc-text">（2）查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%90%88%E5%B9%B6"><span class="toc-text">（3）合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E4%BA%B2%E6%88%9A%E9%97%AE%E9%A2%98"><span class="toc-text">（5）应用——亲戚问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%A0%86"><span class="toc-text">4）堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BB%BA%E5%A0%86"><span class="toc-text">（1）建堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-text">（2）删除堆顶元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%90%91%E5%A0%86%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">（3）向堆中添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">（4）堆排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">5）哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">（1）构造哈夫曼树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">（2）哈夫曼编码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98"><span class="toc-text">0x04 图论专题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-text">1. 图的定义和相关术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">2. 图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">1）邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">2）邻接表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">3. 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">1）深度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">2）广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">4. 最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-text">1）Dijkstra 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89Bellman-Ford-%E7%AE%97%E6%B3%95%E5%92%8C-SPFA-%E7%AE%97%E6%B3%95"><span class="toc-text">2）Bellman-Ford 算法和 SPFA 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89Floyd%E7%AE%97%E6%B3%95"><span class="toc-text">3）Floyd算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">5. 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Prim-%E7%AE%97%E6%B3%95"><span class="toc-text">1）Prim 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89Kruskal-%E7%AE%97%E6%B3%95"><span class="toc-text">2）Kruskal 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">6. 拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">7. 关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89AOV%E7%BD%91%E5%92%8CAOE%E7%BD%91"><span class="toc-text">1）AOV网和AOE网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84"><span class="toc-text">2）最长路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">3）关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B1%82%E8%A7%A3-ve"><span class="toc-text">（1）求解 ve</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B1%82%E8%A7%A3-vl"><span class="toc-text">（2）求解 vl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%B1%82%E8%A7%A3%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8"><span class="toc-text">（3）求解关键活动</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/012.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
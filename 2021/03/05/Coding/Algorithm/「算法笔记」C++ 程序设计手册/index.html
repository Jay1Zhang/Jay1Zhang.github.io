<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「算法笔记」C/C++ 程序设计手册 | J1z's Blog</title><meta name="keywords" content="Algorithm"><meta name="author" content="Jay"><meta name="copyright" content="Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作「算法入门手册」使用。如需「进阶版」请移步「算法思想」系列。 0x00 C&#x2F;C++ 程序设计基础1#include&lt;bits&#x2F;stdc++.h&gt;   黑盒测试大部分在线评测系统都采用多点测试的方式，即将所有输入数据放在一个文件里，系统会让程序去读">
<meta property="og:type" content="article">
<meta property="og:title" content="「算法笔记」C&#x2F;C++ 程序设计手册">
<meta property="og:url" content="http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8DC++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="J1z&#39;s Blog">
<meta property="og:description" content="本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作「算法入门手册」使用。如需「进阶版」请移步「算法思想」系列。 0x00 C&#x2F;C++ 程序设计基础1#include&lt;bits&#x2F;stdc++.h&gt;   黑盒测试大部分在线评测系统都采用多点测试的方式，即将所有输入数据放在一个文件里，系统会让程序去读">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/029.jpg">
<meta property="article:published_time" content="2021-03-05T00:53:51.000Z">
<meta property="article:modified_time" content="2021-03-06T08:42:38.620Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/029.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8DC++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKEK6XV2V5","apiKey":"e093fbb9f29fdf5c7ddd56ec43e9ae05","indexName":"Jay","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-06 16:42:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/029.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1z's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「算法笔记」C/C++ 程序设计手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-05T00:53:51.000Z" title="Created 2021-03-05 08:53:51">2021-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-06T08:42:38.620Z" title="Updated 2021-03-06 16:42:38">2021-03-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding/">Coding</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>21min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作<strong>「算法入门手册」</strong>使用。如需「进阶版」请移步<strong>「算法思想」</strong>系列。</p>
<h2 id="0x00-C-C-程序设计基础"><a href="#0x00-C-C-程序设计基础" class="headerlink" title="0x00 C/C++ 程序设计基础"></a>0x00 C/C++ 程序设计基础</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>


<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>大部分在线评测系统都采用<strong>多点测试</strong>的方式，即将所有输入数据放在一个文件里，系统会让程序去读取这个文件，然后执行程序并输出结果。因此必须保证程序能够反复执行代码的核心部分，这就要用到循环。</p>
<p><strong>（1）while(T–) 型</strong></p>
<p>给定了测试数据的组数，因此只需要用一个变量T来存储，并在程序开始时读入即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）while…EOF 型</strong></p>
<p>没有给定测试数据的组数，因此需要反复读取，直至文件末尾。</p>
<ul>
<li>scanf 函数的返回值为其成功读入的参数的个数，当读到文件末尾时，scanf 函数会返回 -1，即 EOF。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="0x01-C-标准模板库（STL）"><a href="#0x01-C-标准模板库（STL）" class="headerlink" title="0x01 C++ 标准模板库（STL）"></a>0x01 C++ 标准模板库（STL）</h2><p>C++中为使用者提供了标准模板库（Standard Template Library，STL），其中封装了很多相当实用的容器，且定义与常用函数大同小异，在使用时都需要在宏定义下加上一句  <code>using namespace std;</code> 。</p>
<p>下面介绍一些较为常用的几个。</p>
<h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h3><p>vector翻译为向量，但这里使用「动态数组」的叫法更容易理解，作用类似于 Java 中的 <code>ArrayList</code>。</p>
<p>使用vector需要添加头文件 <code>#include&lt;vector&gt;</code> ，此外，还需要加上一句 <code>using namespace std;</code> 。</p>
<h4 id="1）vector的定义与初始化"><a href="#1）vector的定义与初始化" class="headerlink" title="1）vector的定义与初始化"></a>1）vector的定义与初始化</h4><p>单独定义一个 vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>
<p>typename 可以是基本类型（int、double、char、结构体），也可以是STL模板（vector、set、queue）。</p>
<p><strong>（1）不带参数的构造函数初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个size为0的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc;</span><br></pre></td></tr></table></figure>
<p><strong>（2）带参数的构造函数初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">abc</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">//初始化了10个默认值为0的元素</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cde</span><span class="params">(<span class="number">10</span>，<span class="number">1</span>)</span></span>;    <span class="comment">//初始化了10个值为1的元素</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）通过数组地址初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>（4）通过同类型的vector初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//通过a初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>（5）通过insert初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">6</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">vecot&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a[0]~a[2]插入到b中，b.size()由0变为3</span></span><br><span class="line">b.insert(b.begin(), a.begin(), a.begin() + <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>insert也可通过数组地址区间实现插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a的所有元素插入到b中，同样是左闭右开区间</span></span><br><span class="line">b.insert(b.begin(), a, a+<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>此外，insert还可以插入m个值为n的元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在b开始位置处插入6个6</span></span><br><span class="line">b.insert(b.begin(), <span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>


<h4 id="2）vector容器内元素的访问"><a href="#2）vector容器内元素的访问" class="headerlink" title="2）vector容器内元素的访问"></a>2）vector容器内元素的访问</h4><p>vector一般由两种访问方式：</p>
<p><strong>（1）通过下标访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi[index];</span><br></pre></td></tr></table></figure>


<p><strong>（2）通过迭代器访问</strong></p>
<p>迭代器（iterator）可以理解为一种类似指针的东西，定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;::iterator it = vi.begin();	<span class="comment">// begin()为vi的首元素地址</span></span><br></pre></td></tr></table></figure>
<p>易知 <code>vi[i]</code> 和 <code>vi.begin() + i</code> 是的等价的。</p>
<p>需要注意的是，<code>end()</code> 并不是 <code>vi</code> 的尾元素地址，而是<strong>尾元素的下一个地址</strong>。在 C++ 中，这种<strong>「左闭右开」</strong>的思维很常见，务必注意。</p>
<h4 id="3）vector常用函数"><a href="#3）vector常用函数" class="headerlink" title="3）vector常用函数"></a>3）vector常用函数</h4><p><strong>（1）push_back()</strong></p>
<p>顾名思义，<code>push_back(x)</code> 就是在 vector 后面添加一个元素 x，时间复杂度为 $O(1)$ 。</p>
<p><strong>（2）pop_back()</strong></p>
<p><code>pop_back()</code> 用于删除 vector 的尾元素， 时间复杂度为 $O(1)$ 。</p>
<p><strong>（3）size()</strong></p>
<p><code>size()</code> 用来获得 vector 中元素的个数， 时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）clear()</strong></p>
<p><code>clear()</code> 用来清空 vector 中的所有元素， 时间复杂度为 $O(N)$ 。</p>
<p><strong>（5）insert()</strong></p>
<p><code>insert(it, x)</code> 用来向 vector 的任意迭代器 it 处插入一个元素 x， 时间复杂度为 $O(N)$ 。</p>
<p><strong>（6）erase()</strong></p>
<ul>
<li>删除单个元素：<code>erase(it)</code> 即删除迭代器为 it 处的元素。</li>
<li>删除一个区间内的所有元素：<code>erase(first, last)</code> 即删除 <strong>[first, last)</strong> 区间内的所有元素。</li>
</ul>
<h3 id="2-set"><a href="#2-set" class="headerlink" title="2. set"></a>2. set</h3><p>set翻译为集合，是一个<strong>内部自动有序</strong>且<strong>不含重复元素</strong>的容器。</p>
<ul>
<li><p>使用set需要添加头文件 <code>#include&lt;set&gt;</code> 及 <code>using namespace std;</code> 。</p>
</li>
<li><p>set的定义及常见用法与vector大同小异，因此略。</p>
</li>
</ul>
<h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p>在 C 语言中，一般使用字符数组 <code>char str[]</code> 来存放字符串，为了方便字符串操作，C++ 在 STL 中对 string 类型进行了封装。</p>
<p>使用 string 需要添加头文件 <code>#include&lt;string&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）string的定义"><a href="#1）string的定义" class="headerlink" title="1）string的定义"></a>1）string的定义</h4><p>定义string的方式与基本类型相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br></pre></td></tr></table></figure>
<p>如果要初始化，可直接赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="2）string-中内容的访问"><a href="#2）string-中内容的访问" class="headerlink" title="2）string 中内容的访问"></a>2）string 中内容的访问</h4><p><strong>（1）通过下标访问</strong></p>
<ul>
<li><p>一般来说，可以直接像字符数组那样访问 string，即 <code>str[i]</code> ；</p>
</li>
<li><p>如果要读入和输出<strong>整个字符串</strong>，则只能使用 <code>cin</code> 和 <code>cout</code> 。但实际上也能使用 <code>c_str()</code> 将string类型转换为字符数组再进行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str.c_str());</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>（2）通过迭代器访问</strong></p>
<p>一般仅通过（1）即可满足访问的要求，但是有些函数比如 <code>insert()</code> 和 <code>erase()</code> 则要求以迭代器为参数，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it;</span><br></pre></td></tr></table></figure>


<h4 id="3）string常用函数示例解析"><a href="#3）string常用函数示例解析" class="headerlink" title="3）string常用函数示例解析"></a>3）string常用函数示例解析</h4><p><strong>（1）operator+=</strong></p>
<p>这是string的加法，可以直接将两个 string 拼接起来。</p>
<p><strong>（2）compare operator</strong></p>
<p>两个 string 类型可以直接使用 ==、!=、&lt;、&lt;=、&gt;、&gt;= 比较大小，比较规则是<strong>字典序</strong>。 </p>
<p><strong>（3）length() / size()</strong></p>
<p>返回 string 的长度，即存放的字符数，时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）insert()</strong></p>
<ul>
<li><p><code>insert(pos, string)</code> ： pos 位置插入字符串 string。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.insert(<span class="number">3</span>, str2);</span><br></pre></td></tr></table></figure></li>
<li><p><code>insert(it, it2, it3)</code> ：it 为原字符串的欲插入位置，it2 和 it3为待插字符串的首尾迭代器，表示串 [it2, it3) 将被插在 it 位置上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.insert(str.begin()+<span class="number">3</span>, str2.begin(), str2.end());	<span class="comment">// 把str2插入在str的3号位上</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>（5）erase()</strong></p>
<ul>
<li>删除单个元素：<code>str.erase(it)</code> </li>
<li>删除一个区间内的所有元素：<ol>
<li><code>str.erase(first, last)</code> ，即删除 [first, last) </li>
<li><code>str.erase(pos, length)</code> ，其中 pos 为需要开始删除的起始位置，length为删除的字符个数。 </li>
</ol>
</li>
</ul>
<p><strong>（6）clear()</strong></p>
<p>clear() 用于清空 string 中的数据，时间复杂度一般为 $O(1)$ 。</p>
<p><strong>（7）substr()</strong></p>
<p><code>substr(pos, len)</code> 返回从 pos 号位开始、长度为 len 的子串，时间复杂度为 $O(len)$ 。</p>
<p><strong>（8）find()</strong></p>
<p><code>str.find(str2)</code> ：</p>
<ul>
<li><p>当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置；</p>
</li>
<li><p>否则，返回 <code>string::npos</code> 。</p>
<p><code>string::npos</code> 是一个常数，其本身的值为 -1 或者 unsigned_int 的最大值，用以作为 find 函数失配时的返回值。</p>
</li>
</ul>
<p><strong>（9）replace()</strong></p>
<ul>
<li><code>str.replace(pos, len, str2)</code> 把 str 从 pos 号位开始、长度为 len 的子串替换为 str2；</li>
<li><code>str.replace(it1, it2, str2)</code>  把 str 的迭代器 [it1, it2) 范围的子串替换为 str2。</li>
</ul>
<h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map"></a>4. map</h3><p>map翻译为映射，可以将<strong>任何基本类型（包括STL容器）</strong>映射到<strong>任何基本类型（包括STL容器）</strong>。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;map&gt;</code> 及 <code>using namespace std</code> 。</p>
<p>map 会<strong>以键从小到大的顺序自动排序</strong>，这是由于 map 内部是使用<strong>红黑树</strong>实现的（set也是），在建立映射的过程中会自动实现从小到大的排序功能。</p>
<h4 id="1）map的定义"><a href="#1）map的定义" class="headerlink" title="1）map的定义"></a>1）map的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1, typename2&gt; mp;</span><br></pre></td></tr></table></figure>


<h4 id="2）map容器内元素的访问"><a href="#2）map容器内元素的访问" class="headerlink" title="2）map容器内元素的访问"></a>2）map容器内元素的访问</h4><p><strong>（1）通过下标访问</strong></p>
<p>和访问普通数组是一样的，可以直接使用 <code>mp[&#39;c&#39;]</code> 来访问它对应的 value。</p>
<p><strong>（2）通过迭代器访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1, typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>通过 <code>it-&gt;first</code> 和 <code>it-&gt;second</code> 来分别访问键和值。 </p>
<h4 id="3）map常用函数"><a href="#3）map常用函数" class="headerlink" title="3）map常用函数"></a>3）map常用函数</h4><p><strong>（1）find()</strong></p>
<p><code>find(key)</code> 返回键为 key 的映射的迭代器，时间复杂度为 $O(logN)$ 。</p>
<p><strong>（2）erase()</strong></p>
<ul>
<li>删除单个元素：<code>mp.erase(it)</code> 或 <code>mp.erase(key)</code> </li>
<li>删除一个区间内的所有元素：<code>mp.erase(first, last)</code> ，同样为左闭右开区间 [first, last) </li>
</ul>
<p><strong>（3）size()</strong></p>
<p><code>size()</code> 用来获取 map 中映射的对数，时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）clear()</strong></p>
<p><code>clear()</code> 用来清空 map 中的所有元素，复杂度为 $O(N)$ 。</p>
<h3 id="5-queue"><a href="#5-queue" class="headerlink" title="5. queue"></a>5. queue</h3><p>queue 翻译为队列，在 STL 中作为一个<strong>先进先出</strong>的容器。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;queue&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）queue的定义"><a href="#1）queue的定义" class="headerlink" title="1）queue的定义"></a>1）queue的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）queue容器内元素的访问"><a href="#2）queue容器内元素的访问" class="headerlink" title="2）queue容器内元素的访问"></a>2）queue容器内元素的访问</h4><p>由于队列（queue）本身就是一种先进先出的限制性数据结构，因此在 STL 中只能通过 <code>front()</code> 来访问队首元素，或通过 <code>back()</code> 来访问队尾元素。</p>
<h4 id="3）queue常用函数"><a href="#3）queue常用函数" class="headerlink" title="3）queue常用函数"></a>3）queue常用函数</h4><p><strong>（1）front()、back()</strong></p>
<p><code>front()</code> 和 <code>back()</code> 分别获得队首元素和队尾元素。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 将 x 插入队尾。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop()</code> 令队首元素出队。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 检查 queue 是否为空。在使用 <code>front()</code> 和 <code>back()</code> 前，务必判断队列是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回 queue 内元素的个数。</p>
<h3 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6. priority_queue"></a>6. priority_queue</h3><p>priority_queue 又称为<strong>优先队列</strong>，其底层使用<strong>堆</strong>来实现的。在任何时候，队首元素一定是当前队列中优先级最高的那一个。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;queue&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）priority-queue的定义"><a href="#1）priority-queue的定义" class="headerlink" title="1）priority_queue的定义"></a>1）priority_queue的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）priority-queue容器内元素的访问"><a href="#2）priority-queue容器内元素的访问" class="headerlink" title="2）priority_queue容器内元素的访问"></a>2）priority_queue容器内元素的访问</h4><p>和队列（queue）不同的是，优先队列只能通过 <code>top()</code> 来访问<strong>队首元素</strong>（也可以说是<strong>堆顶元素</strong>）。</p>
<h4 id="3）priority-queue常用函数"><a href="#3）priority-queue常用函数" class="headerlink" title="3）priority_queue常用函数"></a>3）priority_queue常用函数</h4><p><strong>（1）top()</strong></p>
<p><code>top()</code> 可以获得队首元素（即堆顶元素）。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 令 x 入队，并自动调整底层数据结构，时间复杂度为 $O(logN)$。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop()</code> 令队首元素出队。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 检查优先队列是否为空。在使用 <code>front()</code> 和 <code>back()</code> 前，务必判断队列是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回优先队列内元素的个数。</p>
<h4 id="4）priority-queue内元素优先级的设置"><a href="#4）priority-queue内元素优先级的设置" class="headerlink" title="4）priority_queue内元素优先级的设置"></a>4）priority_queue内元素优先级的设置</h4><p><strong>（1）基本数据类型的优先级设置</strong></p>
<p>优先队列的<strong>默认优先级是数字大的优先级越高（大顶堆）</strong>，即下面两种优先队列的定义是<strong>等价</strong>的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>在第二种定义方式中，</p>
<ul>
<li><code>vector&lt;int&gt;</code> 表示承载底层数据结构堆（heap）的容器；</li>
<li><code>less&lt;int&gt;</code> 是对第一个参数的比较类，<code>less&lt;int&gt;</code> 表示<strong>数字大的优先级越大</strong>，<code>greater&lt;int&gt;</code> 表示<strong>数字小的优先级越大</strong>。</li>
</ul>
<p>如果想把最小的元素放在队首（小顶堆），则只需如下定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>


<p><strong>（2）结构体的优先级设置</strong></p>
<p>我们不妨对水果的名称和价格建议一个结构体。现在希望<strong>按水果的价格高的为优先级高</strong>，则需要<strong>重载（overload）小于号 “&lt;”</strong> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>friend</code> 为友元，<code>bool operator &lt; (fruit f1, fruit f2)</code> 则对 fruit 类型的操作符 “&lt;” 进行了重载。</p>
<blockquote>
<p>这里务必注意，如果再重载大于号会导致编译出错。因为从数学上来说，f1 &gt; f2 等价于判断 f2 &lt; f1，因此只需要重载小于号即可。</p>
</blockquote>
<p>此时就可以直接定义 fruit 类型的优先队列，其内部就是以价格高的水果为优先级高：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;fruit&gt; q;</span><br></pre></td></tr></table></figure>
<p>同理，如果想要<strong>以价格低的水果为优先级高</strong>，那么只需要把 return 中的<strong>小于号改成大于号</strong>即可，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;	<span class="comment">// 改为大于号，表示价格更低的优先级更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里重载大于号 “&gt;” 也可以，但在定义时就需要：</p>
<p>priority_queue&lt;fruit, vector<int>, greater<int>&gt; q;</p>
<p>因为默认的定义方式中，优先级比较函数为 <code>less&lt;int&gt;</code> ，即小于号 “&lt;”。</p>
</blockquote>
<p>不难注意到，这里<strong>重载小于号</strong>和排序函数 sort() 中的 cmp 函数有些相似，只是效果看上去似乎是“相反”的。</p>
<p>比如对于 <code>return f1.price &gt; f2.price</code> ：</p>
<ul>
<li><p>在排序中，是按价格从高到低排序；</p>
<blockquote>
<p>符合正常思维，价格越高，优先级越高（返回1），因而应排在前面，所以是<strong>从高到低</strong>排序。</p>
</blockquote>
</li>
<li><p>在优先队列中，却是把价格低的放到队首。</p>
</li>
</ul>
<h3 id="7-stack"><a href="#7-stack" class="headerlink" title="7. stack"></a>7. stack</h3><p>stack 翻译为栈，是 STL 中实现的一个<strong>后进先出</strong>的容器。</p>
<p>使用 stack 需要添加头文件 <code>#include&lt;stack&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）stack的定义"><a href="#1）stack的定义" class="headerlink" title="1）stack的定义"></a>1）stack的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）stack容器内元素的访问"><a href="#2）stack容器内元素的访问" class="headerlink" title="2）stack容器内元素的访问"></a>2）stack容器内元素的访问</h4><p>由于栈（stack）本身就是一种后进先出的限制性数据结构，因此在 STL 中只能通过 <code>top()</code> 来访问栈顶元素。</p>
<h4 id="3）stack常用函数"><a href="#3）stack常用函数" class="headerlink" title="3）stack常用函数"></a>3）stack常用函数</h4><p><strong>（1）top()</strong></p>
<p><code>top()</code> 获得栈顶元素，时间复杂度为 $O(1)$ 。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 将 x 入栈，时间复杂度 $O(1)$ 。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop(x)</code> 弹出栈顶元素，时间复杂度 $O(1)$ 。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 可以检查栈是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回 stack 内元素的个数。</p>
<h3 id="8-pair"><a href="#8-pair" class="headerlink" title="8. pair"></a>8. pair</h3><p>pair 是一个很实用的“小玩意”，当想要将两个元素绑定在一起作为一个合成元素、又不像因此定义结构体时，使用 pair 可以很方便地作为一个替代品。实际上，pair 可以看做一个内部有两个元素的结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    typeName1 first;</span><br><span class="line">    typeName2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 pair 需要添加头文件 <code>#include&lt;utility&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）pair的定义"><a href="#1）pair的定义" class="headerlink" title="1）pair的定义"></a>1）pair的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;typename1, typename2&gt; name;</span><br></pre></td></tr></table></figure>
<p>如果想在定义 pair 时进行初始化，只需跟上一个小括号即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, int&gt; p(&quot;haha&quot;, 5);</span><br></pre></td></tr></table></figure>
<p>如果想要在代码中临时构建一个pair，有如下两种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将类型定义写在前面，后面用小括号内两个元素的方式</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; (<span class="string">&quot;haha&quot;</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2. 使用自带的 make_pair 函数</span></span><br><span class="line"><span class="built_in">make_pair</span>(<span class="string">&quot;haha&quot;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<h4 id="2）pair中元素的访问"><a href="#2）pair中元素的访问" class="headerlink" title="2）pair中元素的访问"></a>2）pair中元素的访问</h4><p>按正常结构体的方式访问即可，<code>p.first</code> 或 <code>p.second</code> 。</p>
<h4 id="3）pair常用函数"><a href="#3）pair常用函数" class="headerlink" title="3）pair常用函数"></a>3）pair常用函数</h4><p>两个pair类型数据可以直接使用 ==、!=、&lt;、&lt;=、&gt;、&gt;= 比较大小，比较规则是先以 first 的大小作为标准，只有当 first 相等时才去判别 second 的大小。</p>
<h2 id="0x02-algorithm头文件下的常用函数"><a href="#0x02-algorithm头文件下的常用函数" class="headerlink" title="0x02 algorithm头文件下的常用函数"></a>0x02 algorithm头文件下的常用函数</h2><p>使用 algorithm 头文件，需要添加头文件 <code>#include&lt;algorithm&gt;</code> 及 <code>using namespace std</code> 。</p>
<h3 id="1-基本运算函数"><a href="#1-基本运算函数" class="headerlink" title="1. 基本运算函数"></a>1. 基本运算函数</h3><ul>
<li><code>max(x, y)</code> 、<code>min(x, y)</code>：取 x 和 y 中的最大/小值，参数必须是两个，可以是浮点数。</li>
<li><code>abs(x)</code>：取绝对值，x 必须是整数，浮点型的绝对值可使用 <code>math.h</code> 下的 <code>fabs()</code> 函数。</li>
<li><code>swap(x, y)</code> ：交换 x 和 y 的值。</li>
</ul>
<h3 id="2-next-permutation"><a href="#2-next-permutation" class="headerlink" title="2. next_permutation()"></a>2. next_permutation()</h3><p><code>next_permutation()</code> ：给出一个序列在全排列中的<strong>下一个序列</strong>。</p>
<p>例如，当 n = 3 时的全排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>
<p>这样 231 的下一个序列就是 312。</p>
<p>对于下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(next_permutation(a, a+<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>


<h3 id="3-reverse"><a href="#3-reverse" class="headerlink" title="3. reverse()"></a>3. reverse()</h3><p><code>reverse(it1, it2)</code> ：将<strong>数组指针</strong>或<strong>容器的迭代器</strong>在 [it1, it2) 之间的元素进行反转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">reverse(a, a+<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 3, 2, 1, 0, 4, 5</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">reverse(str.begin() + <span class="number">2</span>, str.begin() + <span class="number">5</span>);</span><br><span class="line"><span class="comment">// abedcfg</span></span><br></pre></td></tr></table></figure>


<h3 id="4-fill"><a href="#4-fill" class="headerlink" title="4. fill()"></a>4. fill()</h3><p><code>fill()</code> 可以把数组或容器中的某一段区间赋为某个相同的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(a, a+<span class="number">5</span>, <span class="number">233</span>);	<span class="comment">// 将 a[0]~a[4]均赋值为233</span></span><br></pre></td></tr></table></figure>


<h3 id="5-lower-bound-和-upper-bound"><a href="#5-lower-bound-和-upper-bound" class="headerlink" title="5. lower_bound() 和 upper_bound()"></a>5. lower_bound() 和 upper_bound()</h3><p><code>lower_bound()</code> 和 <code>upper_bound()</code> 需要用在一个有序数组或容器中。</p>
<ul>
<li><p><code>lower_bound(first, last, val)</code> 用来寻找在数组或容器的 [first, last) 范围内<strong>第一个值大于等于 val</strong> 的元素的位置。</p>
</li>
<li><p><code>upper_bound(first, last, val)</code> 用来寻找在数组或容器的 [first, last) 范围内<strong>第一个值大于 val</strong> 的元素的位置。</p>
</li>
<li><p>如果是数组，则返回该位置的指针；如果是容器，返回该位置的迭代器。时间复杂度为 $O(log(last-first))$ 。</p>
</li>
</ul>
<p>显然，如果只是想要获得欲查元素的下标，就可以不使用临时指针，而<strong>直接令返回值减去数组首地址</strong>即可。</p>
<h3 id="6-sort"><a href="#6-sort" class="headerlink" title="6. sort()"></a>6. sort()</h3><p>顾名思义，<code>sort()</code> 就是用来排序的函数，它根据具体情形使用不同的排序方法，效率较高。</p>
<p>一般来说，不推荐使用 C 语言中的 <code>qsort()</code> 函数，原因是其用起来比较繁琐，涉及很多指针的操作。</p>
<p>而且 <code>sort()</code> 在实现中规避了经典快速排序中可能出现的会导致实际复杂度退化到 $O(n^2)$ 的极端情况。</p>
<h4 id="1）如何使用-sort-排序"><a href="#1）如何使用-sort-排序" class="headerlink" title="1）如何使用 sort 排序"></a>1）如何使用 sort 排序</h4><p>sort 函数的使用必须加上头文件 <code>#include&lt;algorithm&gt;</code> 和 <code>using namespace std;</code> ，其使用的方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(首元素地址， 尾元素地址的下一个地址， 比较函数（非必填）);</span><br></pre></td></tr></table></figure>
<p>当没有比较函数时，默认进行<strong>递增排序</strong>。</p>
<h4 id="2）如何实现比较函数-cmp"><a href="#2）如何实现比较函数-cmp" class="headerlink" title="2）如何实现比较函数 cmp"></a>2）如何实现比较函数 cmp</h4><p>比较函数 cmp 用来“告诉” sort 何时需要交换元素。</p>
<ul>
<li>当 <code>cmp(a, b)</code> 返回 true 时，表明 a 优先级高于 b，a 排在 b 的前面。</li>
</ul>
<p><strong>（1）基本数据类型数组的排序</strong></p>
<p>默认按照从小到大的顺序排序，如果想要从大到小排序，可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）结构体数组的排序</strong></p>
<p>现定义如下结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想先按 x 从大到小排序，但当 x 相等的情况下，按照 y 从小到大排序，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) </span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）容器的排序</strong></p>
<p>以 vector 为例，从大到小排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">sort(vi.begin(), vi.end(), cmp);	<span class="comment">// 对整个vector排序</span></span><br></pre></td></tr></table></figure>
<p>对于 string 来说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str[<span class="number">3</span>] = &#123;<span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aaa&quot;</span>&#125;</span><br><span class="line">sort(str, str + <span class="number">3</span>);		<span class="comment">// 将string型数组按字典序从大笑到输出</span></span><br></pre></td></tr></table></figure>


<h2 id="0x03-数据结构专题"><a href="#0x03-数据结构专题" class="headerlink" title="0x03 数据结构专题"></a>0x03 数据结构专题</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p>栈（stack）是一种<strong>后进先出</strong>的数据结构。栈顶指针是<strong>始终指向栈的最上方元素</strong>的一个标记，通常记为 <code>TOP</code>。</p>
<p>栈的常见操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空操作，将栈顶指针置为-1，表示栈中没有元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TOP = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈内元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TOP + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TOP == <span class="number">-1</span>)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s[++TOP] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TOP--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[TOP];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>队列（queue）是一种<strong>先进先出</strong>的数据结构，队列总是从队尾加入元素，而从队首移除元素。一般来说，需要一个<strong>队首指针 front</strong> 来指向<strong>队首元素的前一个位置</strong>，而使用<strong>队尾指针 rear</strong> 来指向<strong>队尾元素</strong>。</p>
<p>队列的常见操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空操作，还原为初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    front = rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈内元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear - front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == rear)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入队，排在队尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q[++rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出队，移除队首</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    front++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取队首元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[front + <span class="number">1</span>];	<span class="comment">// 注意需要+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取队尾元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[rear];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><h4 id="1）链表的概念"><a href="#1）链表的概念" class="headerlink" title="1）链表的概念"></a>1）链表的概念</h4><p>按正常方式定义一个数组时，计算机会从内存中取出块<strong>连续的地址</strong>来存放给定长度的数组；而链表由若干个节点组成，且结点在内存中的存储位置通常是<strong>不连续</strong>的。</p>
<p>链表的结点一般由两部分构成，即数据域和指针域；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;	<span class="comment">// 数据域</span></span><br><span class="line">    node* next;		<span class="comment">// 指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2）为链表结点分配内存空间"><a href="#2）为链表结点分配内存空间" class="headerlink" title="2）为链表结点分配内存空间"></a>2）为链表结点分配内存空间</h4><p>使用malloc函数或new运算法为链表结点分配内存空间。</p>
<p><strong>（1）malloc 函数</strong></p>
<p>malloc 函数时C语言中 <code>stdlib.h</code> 头文件下用于申请动态内存的函数，返回类型是申请的同变脸类型的指针，基本用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">node* p = (node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br></pre></td></tr></table></figure>
<p><strong>（2）new运算符</strong></p>
<p>new 是C++中用来申请动态空间的运算符，其返回类型同样是申请的同变脸类型的指针，基本用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">node* p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure>
<p>可以看到 new 的写法比 malloc 要简洁许多，只需要 <strong>“new + 类型名”</strong> 即可分配一块该类型的内存空间。</p>
<p><strong>（3）内存泄露</strong></p>
<blockquote>
<p>C/C++语言的设计者认为，程序员完全有能力自己控制内存的分配与释放，因此把对内存的控制操作全部交给了程序员。</p>
</blockquote>
<p>内存泄露是指使用 malloc 和 new 开辟出来的内存空间在使用过后没有释放，导致其在程序结束之前始终占据该内存空间。</p>
<ol>
<li>free 函数对应 malloc 函数：<code>free(p)</code> ；</li>
<li>delete 运算符对应 new 运算符：<code>delete(p)</code> 。</li>
</ol>
<h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><p><strong>（1）创建链表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Array)</span> </span>&#123;</span><br><span class="line">    node *p, *pre, *head;</span><br><span class="line">    head = <span class="keyword">new</span> node;	<span class="comment">// 创建头结点</span></span><br><span class="line">    </span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;	<span class="comment">// 头结点不需要数据域，指针域初始为 NULL</span></span><br><span class="line">    pre = head;			<span class="comment">// 头结点不需要数据域，指针域初始为 NULL</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.size(); i++) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node;	<span class="comment">// 新建结点</span></span><br><span class="line">        p-&gt;data = Array[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next = p;	<span class="comment">// 前驱结点链接当前结点</span></span><br><span class="line">        pre = p;		<span class="comment">// 把pre设为p，作为下个结点的前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;		<span class="comment">// 返回头结点指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）查找元素</strong></p>
<p>链表的查询操作每次都需要从头开始，时间复杂度为为 $O(N)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(node* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;		<span class="comment">// 计数器</span></span><br><span class="line">    node* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == x) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）插入元素</strong></p>
<p>将 x 插入到第pos个位置上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* head, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        p = p-&gt;next;	<span class="comment">// 保证pos位置不越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    node* q = <span class="keyword">new</span> node;</span><br><span class="line">    q-&gt;data = x;</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（4）删除元素</strong></p>
<p>对链表来说，删除元素是指删除链表上所有值为给定的数x。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(node* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = head-&gt;next;</span><br><span class="line">    node* pre = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == x) &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(p);</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="4-树与二叉树"><a href="#4-树与二叉树" class="headerlink" title="4. 树与二叉树"></a>4. 树与二叉树</h3><h2 id="0x04-图算法专题"><a href="#0x04-图算法专题" class="headerlink" title="0x04 图算法专题"></a>0x04 图算法专题</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8DC++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/">http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8DC++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="http://jayyy1.gitee.io/images/pictures/cartoons/029.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/03/03/BUAA/%E3%80%8CPaper%E3%80%8D%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"><img class="next-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/007.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">「Paper」一文解决参考文献格式问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/12/31/Coding/LeetCode/「算法」03-贪心思想/" title="「算法」03-贪心思想"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/017.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」03-贪心思想</div></div></a></div><div><a href="/2021/01/23/Coding/Algorithm/「LeetCode题解」数据结构相关/" title="「LeetCode题解」数据结构相关"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/036.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">「LeetCode题解」数据结构相关</div></div></a></div><div><a href="/2021/01/29/Coding/Algorithm/「算法思想」《算法导论》（四）之图算法-NP问题/" title="「算法思想」《算法导论》（四）之图算法-NP问题"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/017.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">「算法思想」《算法导论》（四）之图算法-NP问题</div></div></a></div><div><a href="/2021/01/23/Coding/Algorithm/「算法思想」《编程珠玑》学习笔记/" title="「算法思想」《编程珠玑》学习笔记"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/035.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">「算法思想」《编程珠玑》学习笔记</div></div></a></div><div><a href="/2020/12/31/Coding/LeetCode/「算法」01-双指针/" title="「算法」01-双指针"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/035.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」01-双指针</div></div></a></div><div><a href="/2020/12/31/Coding/LeetCode/「算法」02-排序/" title="「算法」02-排序"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」02-排序</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-C-C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">0x00 C&#x2F;C++ 程序设计基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">黑盒测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89"><span class="toc-text">0x01 C++ 标准模板库（STL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vector"><span class="toc-text">1. vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89vector%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1）vector的定义与初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89vector%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）vector容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89vector%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）vector常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-set"><span class="toc-text">2. set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-string"><span class="toc-text">3. string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89string%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）string的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89string-%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）string 中内容的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">3）string常用函数示例解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-map"><span class="toc-text">4. map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89map%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）map的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89map%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）map容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89map%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）map常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-queue"><span class="toc-text">5. queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89queue%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）queue的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）queue容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）queue常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-priority-queue"><span class="toc-text">6. priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89priority-queue%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）priority_queue的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89priority-queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）priority_queue容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89priority-queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）priority_queue常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89priority-queue%E5%86%85%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">4）priority_queue内元素优先级的设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-stack"><span class="toc-text">7. stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89stack%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）stack的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）stack容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）stack常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-pair"><span class="toc-text">8. pair</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89pair%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）pair的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89pair%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）pair中元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89pair%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）pair常用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">0x02 algorithm头文件下的常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-text">1. 基本运算函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-next-permutation"><span class="toc-text">2. next_permutation()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-reverse"><span class="toc-text">3. reverse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-fill"><span class="toc-text">4. fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-lower-bound-%E5%92%8C-upper-bound"><span class="toc-text">5. lower_bound() 和 upper_bound()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-sort"><span class="toc-text">6. sort()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-sort-%E6%8E%92%E5%BA%8F"><span class="toc-text">1）如何使用 sort 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0-cmp"><span class="toc-text">2）如何实现比较函数 cmp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98"><span class="toc-text">0x03 数据结构专题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-text">1. 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-text">2. 队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8"><span class="toc-text">3. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1）链表的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%B8%BA%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">2）为链表结点分配内存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">链表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4. 树与二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98"><span class="toc-text">0x04 图算法专题</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/012.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
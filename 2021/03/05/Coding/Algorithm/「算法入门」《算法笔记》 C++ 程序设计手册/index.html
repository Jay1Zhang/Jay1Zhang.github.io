<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「算法入门」《算法笔记》 C/C++ 程序设计手册 | J1z's Blog</title><meta name="keywords" content="Algorithm"><meta name="author" content="Jay"><meta name="copyright" content="Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作「算法入门手册」使用。如需「进阶版」请移步「算法思想」系列。 0x00 C&#x2F;C++ 程序设计基础1#include&lt;bits&#x2F;stdc++.h&gt;   黑盒测试大部分在线评测系统都采用多点测试的方式，即将所有输入数据放在一个文件里，系统会让程序去读">
<meta property="og:type" content="article">
<meta property="og:title" content="「算法入门」《算法笔记》 C&#x2F;C++ 程序设计手册">
<meta property="og:url" content="http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="J1z&#39;s Blog">
<meta property="og:description" content="本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作「算法入门手册」使用。如需「进阶版」请移步「算法思想」系列。 0x00 C&#x2F;C++ 程序设计基础1#include&lt;bits&#x2F;stdc++.h&gt;   黑盒测试大部分在线评测系统都采用多点测试的方式，即将所有输入数据放在一个文件里，系统会让程序去读">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/010.jpg">
<meta property="article:published_time" content="2021-03-05T00:53:51.000Z">
<meta property="article:modified_time" content="2021-03-08T15:22:21.562Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/010.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKEK6XV2V5","apiKey":"e093fbb9f29fdf5c7ddd56ec43e9ae05","indexName":"Jay","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-08 23:22:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/010.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1z's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「算法入门」《算法笔记》 C/C++ 程序设计手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-05T00:53:51.000Z" title="Created 2021-03-05 08:53:51">2021-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-08T15:22:21.562Z" title="Updated 2021-03-08 23:22:21">2021-03-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding/">Coding</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">15.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>55min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇内容整理自胡凡的《算法笔记》，主要目的是对C++程序设计做一个快速而又系统的回顾，因此只涉及到基础内容及应用，以及一些编程技巧，也可以当作<strong>「算法入门手册」</strong>使用。如需「进阶版」请移步<strong>「算法思想」</strong>系列。</p>
<h2 id="0x00-C-C-程序设计基础"><a href="#0x00-C-C-程序设计基础" class="headerlink" title="0x00 C/C++ 程序设计基础"></a>0x00 C/C++ 程序设计基础</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>


<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>大部分在线评测系统都采用<strong>多点测试</strong>的方式，即将所有输入数据放在一个文件里，系统会让程序去读取这个文件，然后执行程序并输出结果。因此必须保证程序能够反复执行代码的核心部分，这就要用到循环。</p>
<p><strong>（1）while(T–) 型</strong></p>
<p>给定了测试数据的组数，因此只需要用一个变量T来存储，并在程序开始时读入即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）while…EOF 型</strong></p>
<p>没有给定测试数据的组数，因此需要反复读取，直至文件末尾。</p>
<ul>
<li>scanf 函数的返回值为其成功读入的参数的个数，当读到文件末尾时，scanf 函数会返回 -1，即 EOF。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="0x01-C-标准模板库（STL）"><a href="#0x01-C-标准模板库（STL）" class="headerlink" title="0x01 C++ 标准模板库（STL）"></a>0x01 C++ 标准模板库（STL）</h2><p>C++中为使用者提供了标准模板库（Standard Template Library，STL），其中封装了很多相当实用的容器，且定义与常用函数大同小异，在使用时都需要在宏定义下加上一句  <code>using namespace std;</code> 。</p>
<p>下面介绍一些较为常用的几个。</p>
<h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h3><p>vector翻译为向量，但这里使用「动态数组」的叫法更容易理解，作用类似于 Java 中的 <code>ArrayList</code>。</p>
<p>使用vector需要添加头文件 <code>#include&lt;vector&gt;</code> ，此外，还需要加上一句 <code>using namespace std;</code> 。</p>
<h4 id="1）vector的定义与初始化"><a href="#1）vector的定义与初始化" class="headerlink" title="1）vector的定义与初始化"></a>1）vector的定义与初始化</h4><p>单独定义一个 vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>
<p>typename 可以是基本类型（int、double、char、结构体），也可以是STL模板（vector、set、queue）。</p>
<p><strong>（1）不带参数的构造函数初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个size为0的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; abc;</span><br></pre></td></tr></table></figure>
<p><strong>（2）带参数的构造函数初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化size,但每个元素值为默认值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">abc</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">//初始化了10个默认值为0的元素</span></span><br><span class="line"><span class="comment">//初始化size,并且设置初始值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cde</span><span class="params">(<span class="number">10</span>，<span class="number">1</span>)</span></span>;    <span class="comment">//初始化了10个值为1的元素</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）通过数组地址初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>（4）通过同类型的vector初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//通过a初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>（5）通过insert初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">6</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">vecot&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a[0]~a[2]插入到b中，b.size()由0变为3</span></span><br><span class="line">b.insert(b.begin(), a.begin(), a.begin() + <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>insert也可通过数组地址区间实现插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="comment">//将a的所有元素插入到b中，同样是左闭右开区间</span></span><br><span class="line">b.insert(b.begin(), a, a+<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>此外，insert还可以插入m个值为n的元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在b开始位置处插入6个6</span></span><br><span class="line">b.insert(b.begin(), <span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>


<h4 id="2）vector容器内元素的访问"><a href="#2）vector容器内元素的访问" class="headerlink" title="2）vector容器内元素的访问"></a>2）vector容器内元素的访问</h4><p>vector一般由两种访问方式：</p>
<p><strong>（1）通过下标访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi[index];</span><br></pre></td></tr></table></figure>


<p><strong>（2）通过迭代器访问</strong></p>
<p>迭代器（iterator）可以理解为一种类似指针的东西，定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;::iterator it = vi.begin();	<span class="comment">// begin()为vi的首元素地址</span></span><br></pre></td></tr></table></figure>
<p>易知 <code>vi[i]</code> 和 <code>vi.begin() + i</code> 是的等价的。</p>
<p>需要注意的是，<code>end()</code> 并不是 <code>vi</code> 的尾元素地址，而是<strong>尾元素的下一个地址</strong>。在 C++ 中，这种<strong>「左闭右开」</strong>的思维很常见，务必注意。</p>
<h4 id="3）vector常用函数"><a href="#3）vector常用函数" class="headerlink" title="3）vector常用函数"></a>3）vector常用函数</h4><p><strong>（1）push_back()</strong></p>
<p>顾名思义，<code>push_back(x)</code> 就是在 vector 后面添加一个元素 x，时间复杂度为 $O(1)$ 。</p>
<p><strong>（2）pop_back()</strong></p>
<p><code>pop_back()</code> 用于删除 vector 的尾元素， 时间复杂度为 $O(1)$ 。</p>
<p><strong>（3）size()</strong></p>
<p><code>size()</code> 用来获得 vector 中元素的个数， 时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）clear()</strong></p>
<p><code>clear()</code> 用来清空 vector 中的所有元素， 时间复杂度为 $O(N)$ 。</p>
<p><strong>（5）insert()</strong></p>
<p><code>insert(it, x)</code> 用来向 vector 的任意迭代器 it 处插入一个元素 x， 时间复杂度为 $O(N)$ 。</p>
<p><strong>（6）erase()</strong></p>
<ul>
<li>删除单个元素：<code>erase(it)</code> 即删除迭代器为 it 处的元素。</li>
<li>删除一个区间内的所有元素：<code>erase(first, last)</code> 即删除 <strong>[first, last)</strong> 区间内的所有元素。</li>
</ul>
<h3 id="2-set"><a href="#2-set" class="headerlink" title="2. set"></a>2. set</h3><p>set翻译为集合，是一个<strong>内部自动有序</strong>且<strong>不含重复元素</strong>的容器。</p>
<ul>
<li><p>使用set需要添加头文件 <code>#include&lt;set&gt;</code> 及 <code>using namespace std;</code> 。</p>
</li>
<li><p>set的定义及常见用法与vector大同小异，因此略。</p>
</li>
</ul>
<h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p>在 C 语言中，一般使用字符数组 <code>char str[]</code> 来存放字符串，为了方便字符串操作，C++ 在 STL 中对 string 类型进行了封装。</p>
<p>使用 string 需要添加头文件 <code>#include&lt;string&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）string的定义"><a href="#1）string的定义" class="headerlink" title="1）string的定义"></a>1）string的定义</h4><p>定义string的方式与基本类型相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br></pre></td></tr></table></figure>
<p>如果要初始化，可直接赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="2）string-中内容的访问"><a href="#2）string-中内容的访问" class="headerlink" title="2）string 中内容的访问"></a>2）string 中内容的访问</h4><p><strong>（1）通过下标访问</strong></p>
<ul>
<li><p>一般来说，可以直接像字符数组那样访问 string，即 <code>str[i]</code> ；</p>
</li>
<li><p>如果要读入和输出<strong>整个字符串</strong>，则只能使用 <code>cin</code> 和 <code>cout</code> 。但实际上也能使用 <code>c_str()</code> 将string类型转换为字符数组再进行输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str.c_str());</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>（2）通过迭代器访问</strong></p>
<p>一般仅通过（1）即可满足访问的要求，但是有些函数比如 <code>insert()</code> 和 <code>erase()</code> 则要求以迭代器为参数，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it;</span><br></pre></td></tr></table></figure>


<h4 id="3）string常用函数示例解析"><a href="#3）string常用函数示例解析" class="headerlink" title="3）string常用函数示例解析"></a>3）string常用函数示例解析</h4><p><strong>（1）operator+=</strong></p>
<p>这是string的加法，可以直接将两个 string 拼接起来。</p>
<p><strong>（2）compare operator</strong></p>
<p>两个 string 类型可以直接使用 ==、!=、&lt;、&lt;=、&gt;、&gt;= 比较大小，比较规则是<strong>字典序</strong>。 </p>
<p><strong>（3）length() / size()</strong></p>
<p>返回 string 的长度，即存放的字符数，时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）insert()</strong></p>
<ul>
<li><p><code>insert(pos, string)</code> ： pos 位置插入字符串 string。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.insert(<span class="number">3</span>, str2);</span><br></pre></td></tr></table></figure></li>
<li><p><code>insert(it, it2, it3)</code> ：it 为原字符串的欲插入位置，it2 和 it3为待插字符串的首尾迭代器，表示串 [it2, it3) 将被插在 it 位置上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.insert(str.begin()+<span class="number">3</span>, str2.begin(), str2.end());	<span class="comment">// 把str2插入在str的3号位上</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>（5）erase()</strong></p>
<ul>
<li>删除单个元素：<code>str.erase(it)</code> </li>
<li>删除一个区间内的所有元素：<ol>
<li><code>str.erase(first, last)</code> ，即删除 [first, last) </li>
<li><code>str.erase(pos, length)</code> ，其中 pos 为需要开始删除的起始位置，length为删除的字符个数。 </li>
</ol>
</li>
</ul>
<p><strong>（6）clear()</strong></p>
<p>clear() 用于清空 string 中的数据，时间复杂度一般为 $O(1)$ 。</p>
<p><strong>（7）substr()</strong></p>
<p><code>substr(pos, len)</code> 返回从 pos 号位开始、长度为 len 的子串，时间复杂度为 $O(len)$ 。</p>
<p><strong>（8）find()</strong></p>
<p><code>str.find(str2)</code> ：</p>
<ul>
<li><p>当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置；</p>
</li>
<li><p>否则，返回 <code>string::npos</code> 。</p>
<p><code>string::npos</code> 是一个常数，其本身的值为 -1 或者 unsigned_int 的最大值，用以作为 find 函数失配时的返回值。</p>
</li>
</ul>
<p><strong>（9）replace()</strong></p>
<ul>
<li><code>str.replace(pos, len, str2)</code> 把 str 从 pos 号位开始、长度为 len 的子串替换为 str2；</li>
<li><code>str.replace(it1, it2, str2)</code>  把 str 的迭代器 [it1, it2) 范围的子串替换为 str2。</li>
</ul>
<h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map"></a>4. map</h3><p>map翻译为映射，可以将<strong>任何基本类型（包括STL容器）</strong>映射到<strong>任何基本类型（包括STL容器）</strong>。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;map&gt;</code> 及 <code>using namespace std</code> 。</p>
<p>map 会<strong>以键从小到大的顺序自动排序</strong>，这是由于 map 内部是使用<strong>红黑树</strong>实现的（set也是），在建立映射的过程中会自动实现从小到大的排序功能。</p>
<h4 id="1）map的定义"><a href="#1）map的定义" class="headerlink" title="1）map的定义"></a>1）map的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1, typename2&gt; mp;</span><br></pre></td></tr></table></figure>


<h4 id="2）map容器内元素的访问"><a href="#2）map容器内元素的访问" class="headerlink" title="2）map容器内元素的访问"></a>2）map容器内元素的访问</h4><p><strong>（1）通过下标访问</strong></p>
<p>和访问普通数组是一样的，可以直接使用 <code>mp[&#39;c&#39;]</code> 来访问它对应的 value。</p>
<p><strong>（2）通过迭代器访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1, typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>通过 <code>it-&gt;first</code> 和 <code>it-&gt;second</code> 来分别访问键和值。 </p>
<h4 id="3）map常用函数"><a href="#3）map常用函数" class="headerlink" title="3）map常用函数"></a>3）map常用函数</h4><p><strong>（1）find()</strong></p>
<p><code>find(key)</code> 返回键为 key 的映射的迭代器，时间复杂度为 $O(logN)$ 。</p>
<p><strong>（2）erase()</strong></p>
<ul>
<li>删除单个元素：<code>mp.erase(it)</code> 或 <code>mp.erase(key)</code> </li>
<li>删除一个区间内的所有元素：<code>mp.erase(first, last)</code> ，同样为左闭右开区间 [first, last) </li>
</ul>
<p><strong>（3）size()</strong></p>
<p><code>size()</code> 用来获取 map 中映射的对数，时间复杂度为 $O(1)$ 。</p>
<p><strong>（4）clear()</strong></p>
<p><code>clear()</code> 用来清空 map 中的所有元素，复杂度为 $O(N)$ 。</p>
<h3 id="5-queue"><a href="#5-queue" class="headerlink" title="5. queue"></a>5. queue</h3><p>queue 翻译为队列，在 STL 中作为一个<strong>先进先出</strong>的容器。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;queue&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）queue的定义"><a href="#1）queue的定义" class="headerlink" title="1）queue的定义"></a>1）queue的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）queue容器内元素的访问"><a href="#2）queue容器内元素的访问" class="headerlink" title="2）queue容器内元素的访问"></a>2）queue容器内元素的访问</h4><p>由于队列（queue）本身就是一种先进先出的限制性数据结构，因此在 STL 中只能通过 <code>front()</code> 来访问队首元素，或通过 <code>back()</code> 来访问队尾元素。</p>
<h4 id="3）queue常用函数"><a href="#3）queue常用函数" class="headerlink" title="3）queue常用函数"></a>3）queue常用函数</h4><p><strong>（1）front()、back()</strong></p>
<p><code>front()</code> 和 <code>back()</code> 分别获得队首元素和队尾元素。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 将 x 插入队尾。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop()</code> 令队首元素出队。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 检查 queue 是否为空。在使用 <code>front()</code> 和 <code>back()</code> 前，务必判断队列是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回 queue 内元素的个数。</p>
<h3 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6. priority_queue"></a>6. priority_queue</h3><p>priority_queue 又称为<strong>优先队列</strong>，其底层使用<strong>堆</strong>来实现的。在任何时候，队首元素一定是当前队列中优先级最高的那一个。</p>
<p>使用 map 需要添加头文件 <code>#include&lt;queue&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）priority-queue的定义"><a href="#1）priority-queue的定义" class="headerlink" title="1）priority_queue的定义"></a>1）priority_queue的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）priority-queue容器内元素的访问"><a href="#2）priority-queue容器内元素的访问" class="headerlink" title="2）priority_queue容器内元素的访问"></a>2）priority_queue容器内元素的访问</h4><p>和队列（queue）不同的是，优先队列只能通过 <code>top()</code> 来访问<strong>队首元素</strong>（也可以说是<strong>堆顶元素</strong>）。</p>
<h4 id="3）priority-queue常用函数"><a href="#3）priority-queue常用函数" class="headerlink" title="3）priority_queue常用函数"></a>3）priority_queue常用函数</h4><p><strong>（1）top()</strong></p>
<p><code>top()</code> 可以获得队首元素（即堆顶元素）。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 令 x 入队，并自动调整底层数据结构，时间复杂度为 $O(logN)$。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop()</code> 令队首元素出队。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 检查优先队列是否为空。在使用 <code>front()</code> 和 <code>back()</code> 前，务必判断队列是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回优先队列内元素的个数。</p>
<h4 id="4）priority-queue内元素优先级的设置"><a href="#4）priority-queue内元素优先级的设置" class="headerlink" title="4）priority_queue内元素优先级的设置"></a>4）priority_queue内元素优先级的设置</h4><p><strong>（1）基本数据类型的优先级设置</strong></p>
<p>优先队列的<strong>默认优先级是数字大的优先级越高（大顶堆）</strong>，即下面两种优先队列的定义是<strong>等价</strong>的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>在第二种定义方式中，</p>
<ul>
<li><code>vector&lt;int&gt;</code> 表示承载底层数据结构堆（heap）的容器；</li>
<li><code>less&lt;int&gt;</code> 是对第一个参数的比较类，<code>less&lt;int&gt;</code> 表示<strong>数字大的优先级越大</strong>，<code>greater&lt;int&gt;</code> 表示<strong>数字小的优先级越大</strong>。</li>
</ul>
<p>如果想把最小的元素放在队首（小顶堆），则只需如下定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>


<p><strong>（2）结构体的优先级设置</strong></p>
<p>我们不妨对水果的名称和价格建议一个结构体。现在希望<strong>按水果的价格高的为优先级高</strong>，则需要<strong>重载（overload）小于号 “&lt;”</strong> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>friend</code> 为友元，<code>bool operator &lt; (fruit f1, fruit f2)</code> 则对 fruit 类型的操作符 “&lt;” 进行了重载。</p>
<blockquote>
<p>这里务必注意，如果再重载大于号会导致编译出错。因为从数学上来说，f1 &gt; f2 等价于判断 f2 &lt; f1，因此只需要重载小于号即可。</p>
</blockquote>
<p>此时就可以直接定义 fruit 类型的优先队列，其内部就是以价格高的水果为优先级高：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;fruit&gt; q;</span><br></pre></td></tr></table></figure>
<p>同理，如果想要<strong>以价格低的水果为优先级高</strong>，那么只需要把 return 中的<strong>小于号改成大于号</strong>即可，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;	<span class="comment">// 改为大于号，表示价格更低的优先级更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里重载大于号 “&gt;” 也可以，但在定义时就需要：</p>
<p>priority_queue&lt;fruit, vector<int>, greater<int>&gt; q;</p>
<p>因为默认的定义方式中，优先级比较函数为 <code>less&lt;int&gt;</code> ，即小于号 “&lt;”。</p>
</blockquote>
<p>不难注意到，这里<strong>重载小于号</strong>和排序函数 sort() 中的 cmp 函数有些相似，只是效果看上去似乎是“相反”的。</p>
<p>比如对于 <code>return f1.price &gt; f2.price</code> ：</p>
<ul>
<li><p>在排序中，是按价格从高到低排序；</p>
<blockquote>
<p>符合正常思维，价格越高，优先级越高（返回1），因而应排在前面，所以是<strong>从高到低</strong>排序。</p>
</blockquote>
</li>
<li><p>在优先队列中，却是把价格低的放到队首。</p>
</li>
</ul>
<h3 id="7-stack"><a href="#7-stack" class="headerlink" title="7. stack"></a>7. stack</h3><p>stack 翻译为栈，是 STL 中实现的一个<strong>后进先出</strong>的容器。</p>
<p>使用 stack 需要添加头文件 <code>#include&lt;stack&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）stack的定义"><a href="#1）stack的定义" class="headerlink" title="1）stack的定义"></a>1）stack的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure>


<h4 id="2）stack容器内元素的访问"><a href="#2）stack容器内元素的访问" class="headerlink" title="2）stack容器内元素的访问"></a>2）stack容器内元素的访问</h4><p>由于栈（stack）本身就是一种后进先出的限制性数据结构，因此在 STL 中只能通过 <code>top()</code> 来访问栈顶元素。</p>
<h4 id="3）stack常用函数"><a href="#3）stack常用函数" class="headerlink" title="3）stack常用函数"></a>3）stack常用函数</h4><p><strong>（1）top()</strong></p>
<p><code>top()</code> 获得栈顶元素，时间复杂度为 $O(1)$ 。</p>
<p><strong>（2）push()</strong></p>
<p><code>push(x)</code> 将 x 入栈，时间复杂度 $O(1)$ 。</p>
<p><strong>（3）pop()</strong></p>
<p><code>pop(x)</code> 弹出栈顶元素，时间复杂度 $O(1)$ 。</p>
<p><strong>（4）empty()</strong></p>
<p><code>empty()</code> 可以检查栈是否为空。</p>
<p><strong>（5）size()</strong></p>
<p><code>size()</code> 返回 stack 内元素的个数。</p>
<h3 id="8-pair"><a href="#8-pair" class="headerlink" title="8. pair"></a>8. pair</h3><p>pair 是一个很实用的“小玩意”，当想要将两个元素绑定在一起作为一个合成元素、又不像因此定义结构体时，使用 pair 可以很方便地作为一个替代品。实际上，pair 可以看做一个内部有两个元素的结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    typeName1 first;</span><br><span class="line">    typeName2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 pair 需要添加头文件 <code>#include&lt;utility&gt;</code> 及 <code>using namespace std</code> 。</p>
<h4 id="1）pair的定义"><a href="#1）pair的定义" class="headerlink" title="1）pair的定义"></a>1）pair的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;typename1, typename2&gt; name;</span><br></pre></td></tr></table></figure>
<p>如果想在定义 pair 时进行初始化，只需跟上一个小括号即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, int&gt; p(&quot;haha&quot;, 5);</span><br></pre></td></tr></table></figure>
<p>如果想要在代码中临时构建一个pair，有如下两种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将类型定义写在前面，后面用小括号内两个元素的方式</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; (<span class="string">&quot;haha&quot;</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 2. 使用自带的 make_pair 函数</span></span><br><span class="line"><span class="built_in">make_pair</span>(<span class="string">&quot;haha&quot;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<h4 id="2）pair中元素的访问"><a href="#2）pair中元素的访问" class="headerlink" title="2）pair中元素的访问"></a>2）pair中元素的访问</h4><p>按正常结构体的方式访问即可，<code>p.first</code> 或 <code>p.second</code> 。</p>
<h4 id="3）pair常用函数"><a href="#3）pair常用函数" class="headerlink" title="3）pair常用函数"></a>3）pair常用函数</h4><p>两个pair类型数据可以直接使用 ==、!=、&lt;、&lt;=、&gt;、&gt;= 比较大小，比较规则是先以 first 的大小作为标准，只有当 first 相等时才去判别 second 的大小。</p>
<h2 id="0x02-algorithm头文件下的常用函数"><a href="#0x02-algorithm头文件下的常用函数" class="headerlink" title="0x02 algorithm头文件下的常用函数"></a>0x02 algorithm头文件下的常用函数</h2><p>使用 algorithm 头文件，需要添加头文件 <code>#include&lt;algorithm&gt;</code> 及 <code>using namespace std</code> 。</p>
<h3 id="1-基本运算函数"><a href="#1-基本运算函数" class="headerlink" title="1. 基本运算函数"></a>1. 基本运算函数</h3><ul>
<li><code>max(x, y)</code> 、<code>min(x, y)</code>：取 x 和 y 中的最大/小值，参数必须是两个，可以是浮点数。</li>
<li><code>abs(x)</code>：取绝对值，x 必须是整数，浮点型的绝对值可使用 <code>math.h</code> 下的 <code>fabs()</code> 函数。</li>
<li><code>swap(x, y)</code> ：交换 x 和 y 的值。</li>
</ul>
<h3 id="2-next-permutation"><a href="#2-next-permutation" class="headerlink" title="2. next_permutation()"></a>2. next_permutation()</h3><p><code>next_permutation()</code> ：给出一个序列在全排列中的<strong>下一个序列</strong>。</p>
<p>例如，当 n = 3 时的全排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>
<p>这样 231 的下一个序列就是 312。</p>
<p>对于下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(next_permutation(a, a+<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>


<h3 id="3-reverse"><a href="#3-reverse" class="headerlink" title="3. reverse()"></a>3. reverse()</h3><p><code>reverse(it1, it2)</code> ：将<strong>数组指针</strong>或<strong>容器的迭代器</strong>在 [it1, it2) 之间的元素进行反转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">reverse(a, a+<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 3, 2, 1, 0, 4, 5</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">reverse(str.begin() + <span class="number">2</span>, str.begin() + <span class="number">5</span>);</span><br><span class="line"><span class="comment">// abedcfg</span></span><br></pre></td></tr></table></figure>


<h3 id="4-fill"><a href="#4-fill" class="headerlink" title="4. fill()"></a>4. fill()</h3><p><code>fill()</code> 可以把数组或容器中的某一段区间赋为某个相同的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(a, a+<span class="number">5</span>, <span class="number">233</span>);	<span class="comment">// 将 a[0]~a[4]均赋值为233</span></span><br></pre></td></tr></table></figure>


<h3 id="5-lower-bound-和-upper-bound"><a href="#5-lower-bound-和-upper-bound" class="headerlink" title="5. lower_bound() 和 upper_bound()"></a>5. lower_bound() 和 upper_bound()</h3><p><code>lower_bound()</code> 和 <code>upper_bound()</code> 需要用在一个有序数组或容器中。</p>
<ul>
<li><p><code>lower_bound(first, last, val)</code> 用来寻找在数组或容器的 [first, last) 范围内<strong>第一个值大于等于 val</strong> 的元素的位置。</p>
</li>
<li><p><code>upper_bound(first, last, val)</code> 用来寻找在数组或容器的 [first, last) 范围内<strong>第一个值大于 val</strong> 的元素的位置。</p>
</li>
<li><p>如果是数组，则返回该位置的指针；如果是容器，返回该位置的迭代器。时间复杂度为 $O(log(last-first))$ 。</p>
</li>
</ul>
<p>显然，如果只是想要获得欲查元素的下标，就可以不使用临时指针，而<strong>直接令返回值减去数组首地址</strong>即可。</p>
<h3 id="6-sort"><a href="#6-sort" class="headerlink" title="6. sort()"></a>6. sort()</h3><p>顾名思义，<code>sort()</code> 就是用来排序的函数，它根据具体情形使用不同的排序方法，效率较高。</p>
<p>一般来说，不推荐使用 C 语言中的 <code>qsort()</code> 函数，原因是其用起来比较繁琐，涉及很多指针的操作。</p>
<p>而且 <code>sort()</code> 在实现中规避了经典快速排序中可能出现的会导致实际复杂度退化到 $O(n^2)$ 的极端情况。</p>
<h4 id="1）如何使用-sort-排序"><a href="#1）如何使用-sort-排序" class="headerlink" title="1）如何使用 sort 排序"></a>1）如何使用 sort 排序</h4><p>sort 函数的使用必须加上头文件 <code>#include&lt;algorithm&gt;</code> 和 <code>using namespace std;</code> ，其使用的方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(首元素地址， 尾元素地址的下一个地址， 比较函数（非必填）);</span><br></pre></td></tr></table></figure>
<p>当没有比较函数时，默认进行<strong>递增排序</strong>。</p>
<h4 id="2）如何实现比较函数-cmp"><a href="#2）如何实现比较函数-cmp" class="headerlink" title="2）如何实现比较函数 cmp"></a>2）如何实现比较函数 cmp</h4><p>比较函数 cmp 用来“告诉” sort 何时需要交换元素。</p>
<ul>
<li>当 <code>cmp(a, b)</code> 返回 true 时，表明 a 优先级高于 b，a 排在 b 的前面。</li>
</ul>
<p><strong>（1）基本数据类型数组的排序</strong></p>
<p>默认按照从小到大的顺序排序，如果想要从大到小排序，可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）结构体数组的排序</strong></p>
<p>现定义如下结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想先按 x 从大到小排序，但当 x 相等的情况下，按照 y 从小到大排序，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) </span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）容器的排序</strong></p>
<p>以 vector 为例，从大到小排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">sort(vi.begin(), vi.end(), cmp);	<span class="comment">// 对整个vector排序</span></span><br></pre></td></tr></table></figure>
<p>对于 string 来说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str[<span class="number">3</span>] = &#123;<span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aaa&quot;</span>&#125;</span><br><span class="line">sort(str, str + <span class="number">3</span>);		<span class="comment">// 将string型数组按字典序从大笑到输出</span></span><br></pre></td></tr></table></figure>


<h2 id="0x03-数据结构专题"><a href="#0x03-数据结构专题" class="headerlink" title="0x03 数据结构专题"></a>0x03 数据结构专题</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p>栈（stack）是一种<strong>后进先出</strong>的数据结构。栈顶指针是<strong>始终指向栈的最上方元素</strong>的一个标记，通常记为 <code>TOP</code>。</p>
<p>栈的常见操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空操作，将栈顶指针置为-1，表示栈中没有元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TOP = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈内元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TOP + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TOP == <span class="number">-1</span>)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s[++TOP] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TOP--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[TOP];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>队列（queue）是一种<strong>先进先出</strong>的数据结构，队列总是从队尾加入元素，而从队首移除元素。一般来说，需要一个<strong>队首指针 front</strong> 来指向<strong>队首元素的前一个位置</strong>，而使用<strong>队尾指针 rear</strong> 来指向<strong>队尾元素</strong>。</p>
<p>队列的常见操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空操作，还原为初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    front = rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取栈内元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear - front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == rear)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入队，排在队尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    q[++rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出队，移除队首</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    front++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取队首元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[front + <span class="number">1</span>];	<span class="comment">// 注意需要+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取队尾元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[rear];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><h4 id="1）链表的概念"><a href="#1）链表的概念" class="headerlink" title="1）链表的概念"></a>1）链表的概念</h4><p>按正常方式定义一个数组时，计算机会从内存中取出块<strong>连续的地址</strong>来存放给定长度的数组；而链表由若干个节点组成，且结点在内存中的存储位置通常是<strong>不连续</strong>的。</p>
<p>链表的结点一般由两部分构成，即数据域和指针域；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;	<span class="comment">// 数据域</span></span><br><span class="line">    node* next;		<span class="comment">// 指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2）为链表结点分配内存空间"><a href="#2）为链表结点分配内存空间" class="headerlink" title="2）为链表结点分配内存空间"></a>2）为链表结点分配内存空间</h4><p>使用malloc函数或new运算法为链表结点分配内存空间。</p>
<p><strong>（1）malloc 函数</strong></p>
<p>malloc 函数时C语言中 <code>stdlib.h</code> 头文件下用于申请动态内存的函数，返回类型是申请的同变脸类型的指针，基本用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">node* p = (node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br></pre></td></tr></table></figure>
<p><strong>（2）new运算符</strong></p>
<p>new 是C++中用来申请动态空间的运算符，其返回类型同样是申请的同变脸类型的指针，基本用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">node* p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure>
<p>可以看到 new 的写法比 malloc 要简洁许多，只需要 <strong>“new + 类型名”</strong> 即可分配一块该类型的内存空间。</p>
<p><strong>（3）内存泄露</strong></p>
<blockquote>
<p>C/C++语言的设计者认为，程序员完全有能力自己控制内存的分配与释放，因此把对内存的控制操作全部交给了程序员。</p>
</blockquote>
<p>内存泄露是指使用 malloc 和 new 开辟出来的内存空间在使用过后没有释放，导致其在程序结束之前始终占据该内存空间。</p>
<ol>
<li>free 函数对应 malloc 函数：<code>free(p)</code> ；</li>
<li>delete 运算符对应 new 运算符：<code>delete(p)</code> 。</li>
</ol>
<h4 id="3）链表的基本操作"><a href="#3）链表的基本操作" class="headerlink" title="3）链表的基本操作"></a>3）链表的基本操作</h4><p><strong>（1）创建链表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Array)</span> </span>&#123;</span><br><span class="line">    node *p, *pre, *head;</span><br><span class="line">    head = <span class="keyword">new</span> node;	<span class="comment">// 创建头结点</span></span><br><span class="line">    </span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;	<span class="comment">// 头结点不需要数据域，指针域初始为 NULL</span></span><br><span class="line">    pre = head;			<span class="comment">// 头结点不需要数据域，指针域初始为 NULL</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.size(); i++) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> node;	<span class="comment">// 新建结点</span></span><br><span class="line">        p-&gt;data = Array[i];</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;next = p;	<span class="comment">// 前驱结点链接当前结点</span></span><br><span class="line">        pre = p;		<span class="comment">// 把pre设为p，作为下个结点的前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;		<span class="comment">// 返回头结点指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）查找元素</strong></p>
<p>链表的查询操作每次都需要从头开始，时间复杂度为为 $O(N)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(node* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;		<span class="comment">// 计数器</span></span><br><span class="line">    node* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == x) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）插入元素</strong></p>
<p>将 x 插入到第pos个位置上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* head, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        p = p-&gt;next;	<span class="comment">// 保证pos位置不越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    node* q = <span class="keyword">new</span> node;</span><br><span class="line">    q-&gt;data = x;</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（4）删除元素</strong></p>
<p>对链表来说，删除元素是指删除链表上所有值为给定的数x。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(node* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    node* p = head-&gt;next;</span><br><span class="line">    node* pre = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == x) &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(p);</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="4-树与二叉树"><a href="#4-树与二叉树" class="headerlink" title="4. 树与二叉树"></a>4. 树与二叉树</h3><h4 id="1）树的定义与性质"><a href="#1）树的定义与性质" class="headerlink" title="1）树的定义与性质"></a>1）树的定义与性质</h4><p><strong>（1）树的定义</strong></p>
<ul>
<li>树的<strong>层次（layer）</strong>从根结点开始算起，即根结点为第一层。</li>
<li>把结点的子树棵树称为结点的<strong>度（degree）</strong>，而树中结点最大的度称为树的度。<strong>叶子结点</strong>被定义为度为0的结点。</li>
<li>由于一条边连接两个结点，且树种不存在环，因此对有n个结点的树，边数一定是n-1。且<strong>满足连通、边数等于顶点数减1</strong>的结构一定是一棵树。</li>
<li>多棵树组合在一起称为<strong>森林（forest）</strong>，即森林是若干棵树的集合。</li>
</ul>
<p><strong>（2）二叉树的定义</strong></p>
<p>二叉树由根结点、左子树、右子树组成，且左子树和右子树都是二叉树。</p>
<p>注意区分<strong>二叉树</strong>与<strong>度为2的树</strong>的区别。</p>
<ul>
<li>度不同<ul>
<li>度为2的树要求每个节点<strong>最多</strong>只能有两棵子树，并且<strong>至少</strong>有一个节点有两棵子树。</li>
<li>二叉树的要求是度不超过2，节点最多有两个叉，可以是1或者0。</li>
</ul>
</li>
<li>次序不同<ul>
<li>度为2的树从形式上看与二叉树很相似，但它的子树是无序的，而二叉树是有序的。</li>
</ul>
</li>
</ul>
<p>在任意一棵二叉树中，<strong>度为0的结点（即叶子结点）总是比度为2的结点多一个</strong>。</p>
<p>下面介绍两种特殊的二叉树：</p>
<ol>
<li><strong>满二叉树</strong>：每一层的结点个数都达到了当层能达到的最大结点数。</li>
<li><strong>完全二叉树</strong>：<strong>除了最下面的一层外</strong>，其余层的结点个数都达到了当层能达到的最大结点数，且最下面一层只<strong>从左至右</strong>连续存在若干结点。</li>
</ol>
<h4 id="2）二叉树的存储结构与基本操作"><a href="#2）二叉树的存储结构与基本操作" class="headerlink" title="2）二叉树的存储结构与基本操作"></a>2）二叉树的存储结构与基本操作</h4><p><strong>（1）二叉树的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;	<span class="comment">// 数据域</span></span><br><span class="line">    node* lchild;	<span class="comment">// 指向左子树根结点的指针</span></span><br><span class="line">    node* rchild<span class="number">&#x27;</span>	<span class="comment">// 指向右子树根结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建结点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个新结点，v为结点权值</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;data = v;</span><br><span class="line">    Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;	<span class="comment">// 初始状态下没有左右孩子</span></span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）二叉树结点的查找、修改</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x, <span class="keyword">int</span> newdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == x) &#123;</span><br><span class="line">        root-&gt;data = newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(root-&gt;lchild, x, newdata);</span><br><span class="line">    search(root-&gt;rchild, x, newdata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（3）二叉树结点的插入</strong></p>
<p>结点的插入位置一般取决于数据域需要在二叉树中存放的位置，且对给定的结点来说，它在二叉树中的插入位置只会有一个。因此可以得到结论：<strong>二叉树结点的插入位置就是数据域在二叉树中查找失败的位置</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert函数将在二叉树中插入一个数据域为x的新结点</span></span><br><span class="line"><span class="comment">// 注意根结点指针root要使用引用，否则插入不会成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;		<span class="comment">// 空树，说明查找失败，也即插入位置（递归边界）</span></span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(由二叉树的性质，x应该插在左子树) &#123;</span><br><span class="line">        insert(root-&gt;lchild, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isnert(root-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很关键的一点是**根结点指针root使用了引用&amp;**。如果不使用引用，<code>root = new node</code> 这个语句对root的修改就无法作用到原变量上（即上一层的 <code>root-&gt;lchild</code> 与 <code>root-&gt;rchild</code>）上去，也就不能把新结点接到二叉树上面。</p>
<p><strong>（4）二叉树的创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;	</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（5）完全二叉树的存储结构</strong></p>
<p>对完全二叉树来说，除了采用二叉链表的存储结构歪，还有更方便的存储方法。</p>
<p>对一棵完全二叉树，如果给它的所有结点按<strong>从上到下、从左到右</strong>的顺序进行编号。</p>
<p>那么对完全二叉树当中的任何一个结点x，其左孩子的编号一定是2x，而右孩子的编号一定是2x+1。</p>
<h4 id="3）二叉树的遍历"><a href="#3）二叉树的遍历" class="headerlink" title="3）二叉树的遍历"></a>3）二叉树的遍历</h4><p>二叉树的遍历有四种：先序遍历、中序遍历、后序遍历，以及层次遍历。其中，前三种都是用DFS实现，而层次遍历一般用BFS实现。</p>
<p>对于前三种遍历方式，<strong>左子树一定先于右子树</strong>，且所谓的“先中后”都是指<strong>根结点root在遍历中的位置</strong>。</p>
<p><strong>（1）先序遍历</strong></p>
<p>先序遍历的顺序是 “ 根结点 → 左子树 → 右子树 ”。对于一棵二叉树的先序遍历序列，<strong>序列的第一个一定是根结点</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;		<span class="comment">// 到达空树，递归边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问根结点 root，例如将其数据域输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    preorder(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    preorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（2）中序遍历</strong></p>
<p>中序遍历的顺序是 “ 左子树 → 根结点 → 右子树 ”。因此，只要知道根结点，就可以<strong>通过根结点在中序遍历序列中的位置区分出左子树和右子树</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// 访问根结点 root，例如将其数据域输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p><strong>（3）后序遍历</strong></p>
<p>后序遍历的顺序是 “ 左子树 → 右子树 → 根结点”。对后序遍历来说，<strong>序列的最后一个一定是根结点</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    postorder(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    postorder(root-&gt;rchild);</span><br><span class="line">    <span class="comment">// 访问根结点 root，例如将其数据域输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>总的来说，<strong>必须知道中序遍历序列才能唯一地确定一棵树</strong>。因为只有通过中序遍历序列才能利用根结点把左右自述分开，从而递归生成一棵二叉树。</p>
<p><strong>（4）层序遍历</strong></p>
<p>层序遍历是指按层次的顺序<strong>从根结点向下逐层进行遍历，且对同一层的结点为从左到右遍历</strong>。这个过程和BFS很像，因为BFS进行搜索总是以广度作为第一关键词，而对应到二叉树中广度又恰好体现在层次上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;		<span class="comment">// 注意队列里存的是地址</span></span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node* now = q.front();	<span class="comment">// 取队首元素</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, now-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>) q.push(now-&gt;lchild);	<span class="comment">// 左子树非空</span></span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>) q.push(now-&gt;rchild);	<span class="comment">// 右子树非空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4）从遍历序列中重建二叉树"><a href="#4）从遍历序列中重建二叉树" class="headerlink" title="4）从遍历序列中重建二叉树"></a><strong>4）从遍历序列中重建二叉树</strong></h4><p><strong>【结论】</strong></p>
<p>中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树，而后三者两两搭配或是三个一起上都无法构建唯一的二叉树。</p>
<p><strong>【示例】</strong></p>
<p>假设已知先序序列为 pre1, pre2, …, pren，中序序列为 in1, in2, …, inn，重建这棵二叉树。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307102538238.png" alt="image-20210307102538238" style="zoom:70%;" />

<p>如上图所示，可以首先通过先序序列确定根结点，在由中序序列将其划分为左子树和右子树，得到左右子树的结点个数，进而能够在先序序列中划分出左右子树，并对左右子树递归进行上述操作即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前先序序列区间为 [preL, preR]，中序序列区间为 [inL, inR]，返回根结点地址</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">// 先序序列长度小于等于0时，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;		<span class="comment">// 新建根结点</span></span><br><span class="line">    root-&gt;data = pre[preL];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = inL; k &lt;= inR; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k] == pre[preL]) &#123;	<span class="comment">// 在中序序列中找到根结点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inL;		<span class="comment">// 左子树的结点个数</span></span><br><span class="line">    <span class="comment">// 左子树的先序区间为 [preL + 1, preL + numLeft]，中序区间为 [inL, k-1]</span></span><br><span class="line">    root-&gt;lchild = create(preL + <span class="number">1</span>, preL + numLeft, inL, k - <span class="number">1</span>);	<span class="comment">// 返回左子树的根结点</span></span><br><span class="line">    <span class="comment">// 右子树的先序区间为 [preL + numLeft + 1, preR]，中序区间为 [k + 1, inR]</span></span><br><span class="line">    root-&gt;lchild = create(preL + numLeft + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);	<span class="comment">// 返回左子树的根结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;		<span class="comment">// 返回根结点地址 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5）从树的遍历看-DFS-与-BFS"><a href="#5）从树的遍历看-DFS-与-BFS" class="headerlink" title="5）从树的遍历看 DFS 与 BFS"></a>5）从树的遍历看 DFS 与 BFS</h4><p><strong>（1）深度优先搜索与先序遍历</strong></p>
<p>事实上，对所有合法的DFS求解过程，都可以把它画成树的形式，此时<strong>死胡同等价于树中的叶子结点</strong>，而<strong>岔道口等价于树中的非叶子结点</strong>，并且对这棵树的<strong>DFS遍历过程就是树的先序遍历的过程</strong>。</p>
<p>在DFS过程中，提到过<strong>剪枝</strong>的概念，即对某条可以确定不存在解的子树采取直接剪断的策略，前提是要保证剪枝的正确性，否则可能因减掉了有解的子树而最终获得了错误的答案。</p>
<p><strong>（2）广度优先搜索与层序遍历</strong></p>
<p>事实上，对所有合法的BFS求解过程，都可以把它画成树的形式，并将其转换为<strong>树的层序遍历的问题</strong>。</p>
<h3 id="5-树的延伸算法"><a href="#5-树的延伸算法" class="headerlink" title="5. 树的延伸算法"></a>5. 树的延伸算法</h3><h4 id="1）二叉查找树（BST）"><a href="#1）二叉查找树（BST）" class="headerlink" title="1）二叉查找树（BST）"></a>1）二叉查找树（BST）</h4><p>二叉查找树（Binary Search Tree，BST）是一种特殊的二叉树，又称为二叉搜索树。其核心思想是：左子树上所有结点均小于等于根结点，右子树上所有结点均大于根结点。</p>
<h5 id="（1）查找操作"><a href="#（1）查找操作" class="headerlink" title="（1）查找操作"></a><strong>（1）查找操作</strong></h5><p>BST的性质决定了可以只选择其中一棵子树进行遍历，因此查找将会是从树根到查找结点的一条路径，故最坏复杂度是 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search 函数查找二叉查找树中数据域为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;search failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);		<span class="comment">// 查找成功，访问之</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        search(root-&gt;lchild, x);		<span class="comment">// 往左子树搜索x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        search(root-&gt;rchild, x);		<span class="comment">// 往右子树搜索x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）插入操作"><a href="#（2）插入操作" class="headerlink" title="（2）插入操作"></a><strong>（2）插入操作</strong></h5><p>当需要查找的值在BST中查找失败时，说明这个地方一定是结点需要插入的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert 函数将在二叉树中插入一个数据域为x的新结点（注意参数root要加引用&amp;）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;		<span class="comment">// 空树，查找失败，亦即插入位置</span></span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;			<span class="comment">// 查找成功，结点已存在，返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        insert(root-&gt;lchild, x);		<span class="comment">// 往左子树搜索x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;rchild, x);		<span class="comment">// 往右子树搜索x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）创建操作"><a href="#（3）创建操作" class="headerlink" title="（3）创建操作"></a><strong>（3）创建操作</strong></h5><p>建议一棵二叉查找树，就是先后插入n个结点的过程，这和一般二叉树的建立是完全一样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉查找树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（4）删除操作"><a href="#（4）删除操作" class="headerlink" title="（4）删除操作"></a><strong>（4）删除操作</strong></h5><p>我们首先定义两个概念，对于二叉查找树中的某个结点 x，</p>
<ul>
<li>把<strong>比结点权值小的最大结点</strong>称为该结点的<strong>前驱</strong>；</li>
<li>把<strong>比结点权值大的最小结点</strong>称为该结点的<strong>后继</strong>。</li>
</ul>
<p>显然，结点的<strong>前驱是该结点左子树中的最右结点</strong>，而结点的<strong>后继则是该结点右子树中的最左结点</strong>。</p>
<p>当我们删除二叉查找树中的某个结点 x 时，为了保证删除操作之后仍然是一棵二叉查找树，需要用 x 的前驱结点或后继结点覆盖 x。</p>
<p>如下图，如果需要删掉根结点5，一种办法是用结点4（前驱）来覆盖结点5，另一种办法是用结点6（后继）来覆盖结点5。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307130118715.png" alt="image-20210307130118715" style="zoom:60%;" />



<p>下面两个函数用来寻找以 root 为根的树中最大或最小权值的结点，用以辅助寻找结点的前驱和和后继：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找以 root 为根结点的树中的最大权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;rchild;		<span class="comment">// 不断往右，直到没有右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找以 root 为根结点的树中的最小权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;lchild;		<span class="comment">// 不断往左，直到没有左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>假设决定用结点N的前驱P来替换N，那么删除操作的基本思路如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除以root为根结点的树中权值为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)	<span class="keyword">return</span>;		<span class="comment">// 不存在权值为 x 的结点</span></span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;			<span class="comment">// 找到欲删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 叶子结点，直接删除</span></span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 左子树不为空时，优先用前驱覆盖root</span></span><br><span class="line">            node* pre = findMax(root-&gt;lchild);</span><br><span class="line">            root-&gt;data = pre-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;lchild, pre-&gt;data);	<span class="comment">// 在左子树中删除结点pre</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左子树为空但右子树不为空时，用后继覆盖root</span></span><br><span class="line">            node* next = findMin(root-&gt;rchild);</span><br><span class="line">            root-&gt;data = next-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;rchild, next-&gt;data);	<span class="comment">// 在右子树中删除结点next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        deleteNode(root-&gt;lchild, x);<span class="comment">// 在左子树中删除x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteNode(root-&gt;rchild, x);<span class="comment">// 在右子树中删除x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>需要注意的是，总是优先删除前驱（或后继）容易导致树的左右子树高度极不平衡，使得二叉查找树退化成一条链。解决的办法有两种：</p>
<ol>
<li>每次交替删除前驱或后继；</li>
<li>记录子树高度，总是优先在高度较高地一棵子树里删除结点。</li>
</ol>
<p>当然，上述代码还可以通过很多手段优化。例如，找到欲删除结点5的后继结点6后，不进行递归，而是将结点6的右子树替代结点6，成为结点8的左子树。</p>
<h5 id="（5）二叉查找树的性质"><a href="#（5）二叉查找树的性质" class="headerlink" title="（5）二叉查找树的性质"></a><strong>（5）二叉查找树的性质</strong></h5><p>“<strong>对二叉查找树进行中序遍历，遍历的结果是有序的</strong>”。这是因为二叉查找树本身就具有 “左子树 &lt; 根结点 &lt; 右子树” 的特点，而中序遍历又是按照 “左子树 → 根结点 → 右子树” 的顺序进行访问的，因而中序遍历序列是有序的。</p>
<h4 id="2）平衡二叉树（AVL）"><a href="#2）平衡二叉树（AVL）" class="headerlink" title="2）平衡二叉树（AVL）"></a>2）平衡二叉树（AVL）</h4><p>首先考虑一下上一小节的二叉查找树有什么缺陷。考虑使用序列 {1,2, 3, 4, 5} 来构建二叉查找树，会得到如下图所示的BST：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307145811736.png" alt="image-20210307145811736" style="zoom:60%;" />



<p>显然，这棵二叉查找树是链式的，此时对这棵树中结点进行查找的复杂度就会达到 $O(n)$ 。为了能使树的高度在每次插入元素后仍然能爆出 $O(logn)$ 的级别，平衡二叉树（AVL）诞生了。</p>
<p>AVL仍然是一棵二叉查找树，只是增加了“<strong>平衡</strong>”的要求。</p>
<ul>
<li><strong>平衡</strong>：对AVL树的任意结点来说，其左子树与右子树的<strong>高度之差的绝对值不超过1</strong>。</li>
<li><strong>平衡因子</strong>：对AVL树的任意结点来说，其左子树与右子树的<strong>高度之差</strong>称为该节点的平衡因子。</li>
</ul>
<p>因此需要在树的结构中加入一个变量 height，用来记录以当前结点为根结点的子树的高度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, height;</span><br><span class="line">    node* lchild, rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，结点 root 所在子树的高度等于其左子树的 height 与右子树的 height 的较大值加1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取以root为根结点的子树的height</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新结点root的height</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// max(左孩子的height， 右孩子的height) + 1</span></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（1）查找操作-1"><a href="#（1）查找操作-1" class="headerlink" title="（1）查找操作"></a><strong>（1）查找操作</strong></h5><p>由于 AVL 是一棵二叉查找树，因此查找操作与 BST 相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search 函数查找二叉查找树中数据域为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;search failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data);		<span class="comment">// 查找成功，访问之</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">        search(root-&gt;lchild, x);		<span class="comment">// 往左子树搜索x</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        search(root-&gt;rchild, x);		<span class="comment">// 往右子树搜索x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）旋转操作"><a href="#（2）旋转操作" class="headerlink" title="（2）旋转操作"></a><strong>（2）旋转操作</strong></h5><p>如下图，以<strong>左旋</strong>为例，假设B希望成为根结点，由于 A &lt; B，因而A将成为B的左子树，那么B原来的左子树 ◆ 呢？考虑到 A &lt; ◆ &lt; B，于是让 ◆ 成为A的右子树即可。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307154641717.png" alt="image-20210307154641717" style="zoom:60%;" />



<p>这个调整过程被称为<strong>左旋（Left Rotation）</strong>，可以分为三个步骤：</p>
<ol>
<li>让 B 的左子树 ◆ 成为 A 的右子树；</li>
<li>让 A 成为 B 的左子树；</li>
<li>将根结设定为结点 B。</li>
</ol>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307154851200.png" alt="image-20210307154851200" style="zoom:75%;" />



<p>对应的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋（Left Rotation）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root, node* temp)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">// root指向A，temp指向B</span></span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;	<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;lchild = root;			<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);		<span class="comment">// 更新结点A的高度</span></span><br><span class="line">    updateHeight(temp);		<span class="comment">// 更新结点B的高度</span></span><br><span class="line">    root = temp;					<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>右旋（Right Rotation）</strong>和左旋是对称的过程，即左旋的逆过程，实现步骤和左旋基本相同，直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右旋（Right Rotation）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root, node* temp)</span> </span>&#123;	</span><br><span class="line">    <span class="comment">// root指向B，temp指向A</span></span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;	<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;rchild = root;			<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);		<span class="comment">// 更新结点B的高度</span></span><br><span class="line">    updateHeight(temp);		<span class="comment">// 更新结点A的高度</span></span><br><span class="line">    root = temp;					<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）插入操作"><a href="#（3）插入操作" class="headerlink" title="（3）插入操作"></a>（3）插入操作</h5><p>AVL 的插入操作比较复杂，且需要用到旋转操作，我们一步一步分析：</p>
<ul>
<li><p>在往 AVL 中插入一个结点时，一定会有结点的平衡因子发生变化，此时可能会有结点的平衡因子的<strong>绝对值大于1</strong>。</p>
<p>（且只可能是2或-2，因为只插入了一个结点，树的高度只可能变化1）</p>
</li>
<li><p>显然，只有在<strong>从根结点到该插入节点的路径上的结点</strong>才可能发生平衡因子变化，因此只需对这条路径上失衡的结点进行调整。</p>
</li>
<li><p>可以证明，“<strong>只要把最靠近插入节点的失衡结点调整到正常，路径上的所有结点就会平衡</strong>”。</p>
</li>
</ul>
<p>下举例说明：</p>
<p>假设最靠近插入结点的失衡结点是A，显然它的平衡因子只可能是2或者-2，这两种情况是完全对称的。</p>
<ul>
<li><p>假设A的平衡因子是2，即左子树的高度比右子树大2，那么以A为根结点的子树一定是下图 LL型与 LR型之一。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307164602382.png" alt="image-20210307164602382" style="zoom:75%;" />

<p>可以发现，<strong>当A的左孩子的平衡因子是1时为 LL型，是-1时为 LR型</strong> 。</p>
</li>
</ul>
<ul>
<li><p>假设A的平衡因子是-2，即左子树的高度比右子树小2，那么以A为根结点的子树一定是下图 RR型与 RL型之一。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307165656377.png" alt="image-20210307165656377" style="zoom:75%;" />

<p>可以发现，<strong>当A的右孩子的平衡因子是-1时为 RR型，是1时为 RL型</strong> 。</p>
</li>
</ul>
<p><strong>【调整】</strong></p>
<p>现在考虑怎样调整这四种树型，才能使树平衡。</p>
<ul>
<li><p>对于LL型，可以把以C为根结点的子树看作一个整体，然后以结点A作为root进行右旋，便可以达到平衡：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307165332820.png" alt="image-20210307165332820" style="zoom:75%;" />
</li>
<li><p>对于LR型，可以先忽略结点A，以C为root进行左旋，就可以把情况转化为LL型，然后按照上面LL型的做法进行一次右旋即可：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307165452611.png" alt="image-20210307165452611" style="zoom:75%;" />
</li>
<li><p>对于RR型，可以把以C为根结点的子树看作一个整体，然后以结点A作为root进行左旋，便可以达到平衡：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307165942851.png" alt="image-20210307165942851" style="zoom:75%;" />
</li>
<li><p>对于RL型，可以先忽略结点A，以C为root进行右旋，就可以把情况转化为RR型，然后按照上面RR型的做法进行一次左旋即可：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210307165959809.png" alt="image-20210307165959809" style="zoom:75%;" />



</li>
</ul>
<p><strong>【汇总】</strong></p>
<p>至此，对LL型、LR型、RR型、RL型的调整方法都已经讨论清楚，下面做个小小的汇总：</p>
<table>
<thead>
<tr>
<th align="center">树型</th>
<th align="center">判定条件</th>
<th align="center">调整方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LL</td>
<td align="center"><code>BF(root) = 2</code> 且 <code>BF(root-&gt;lchild) = 1</code></td>
<td align="center">对root进行右旋</td>
</tr>
<tr>
<td align="center">LR</td>
<td align="center"><code>BF(root) = 2</code> 且 <code>BF(root-&gt;lchild) = -1</code></td>
<td align="center">先对 <code>root-&gt;lchild</code> 进行左旋，再对root进行右旋</td>
</tr>
<tr>
<td align="center">RR</td>
<td align="center"><code>BF(root) = -2</code> 且 <code>BF(root-&gt;rchild) = -1</code></td>
<td align="center">对root进行左旋</td>
</tr>
<tr>
<td align="center">RL</td>
<td align="center"><code>BF(root) = -2</code> 且 <code>BF(root-&gt;rchild) = 1</code></td>
<td align="center">先对 <code>root-&gt;rchild</code> 进行右旋，再对root进行左旋</td>
</tr>
</tbody></table>
<p><strong>【代码】</strong></p>
<p>AVL树的插入代码需要在二叉查找树的插入代码的基础上增加平衡操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入权值为v的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = newNode(v);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v &lt; root-&gt;v) &#123;</span><br><span class="line">        insert(root-&gt;lchild, v);		<span class="comment">// 往左子树插入</span></span><br><span class="line">        updateHeight(root);				<span class="comment">// 更新树高</span></span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">1</span>) &#123;	<span class="comment">// LL型</span></span><br><span class="line">                R(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">-1</span>)	<span class="comment">// LR型</span></span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(root-&gt;rchild, v);		<span class="comment">// 往右子树插入</span></span><br><span class="line">        updateHeight(root);				<span class="comment">// 更新树高</span></span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">-1</span>) &#123;	<span class="comment">// RR型</span></span><br><span class="line">                L(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">1</span>)	<span class="comment">// RL型</span></span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（4）创建操作"><a href="#（4）创建操作" class="headerlink" title="（4）创建操作"></a><strong>（4）创建操作</strong></h5><p>有了插入操作的基础，AVL树的建立就非常简单了，只需依次插入n个结点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVL树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3）并查集"><a href="#3）并查集" class="headerlink" title="3）并查集"></a>3）并查集</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集</a></p>
</blockquote>
<p>在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题的特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，计算机无法承受。</p>
<p>并查集是一种树型的数据结构，它的名字中 “并”、“查”、“集” 分别取自 Union（合并）、Find（查找）、Set（集合）这三个词，用于处理这类<strong>不相交集合</strong>（disjoint sets）的<strong>合并及查询</strong>问题。</p>
<p>实际上，并查集就是一个数字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> father[N];</span><br></pre></td></tr></table></figure>
<p>其中 <code>father[i]</code> 表示元素 <code>i</code> 的父亲结点，而父亲结点本身也是这个集合内的元素。<strong>对于同一个集合来说只存在一个根结点，且将其作为所属集合的标识</strong>。</p>
<h5 id="（1）初始化"><a href="#（1）初始化" class="headerlink" title="（1）初始化"></a>（1）初始化</h5><p>一开始，每个元素都是独立的一个集合，因此需要令所有 <code>father[i] = i</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    father[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）查找"><a href="#（2）查找" class="headerlink" title="（2）查找"></a>（2）查找</h5><p>查找操作就是对给定的结点寻找其根结点的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* findFather函数返回元素x所在集合的根结点*/</span></span><br><span class="line"><span class="comment">// 1.递推算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;		<span class="comment">// 如果不是根结点，继续循环</span></span><br><span class="line">        x = father[x];			<span class="comment">// 获得自己的父亲结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])	<span class="keyword">return</span> x;	<span class="comment">// 如果找到根结点，返回根结点编号x</span></span><br><span class="line">    <span class="keyword">else</span>	<span class="keyword">return</span> findFather(father[x]);	<span class="comment">// 否则，递归判断x的父亲结点是否是根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）合并"><a href="#（3）合并" class="headerlink" title="（3）合并"></a>（3）合并</h5><p>合并是指把两个集合合并成一个集合。一般是先判断两个元素是否属于同一个集合，只有当它们属于不同集合时才合并，而合并的过程一般是把其中一个集合的根结点的父亲指向另一个集合的根结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210308201334299.png" alt="image-20210308201334299" style="zoom:80%;" />

<p>由于在合并的过程中，只对两个不同的集合进行合并，这就保证了在同一个集合中一定不会产生环，即<strong>并查集产生的每一个集合都是一棵树</strong>。</p>
<p><strong>（4）路径压缩</strong></p>
<p>前面提到的并查集查找函数是未经优化的，在极端情况（比如当元素数量很多且形成一条链时）下效率较低。</p>
<p>优化方法如下：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210308201515458.png" alt="image-20210308201515458" style="zoom:75%;" />

<p>这样相当于<strong>把当前查询结点的路径上的所有结点的父亲都指向根结点</strong>，查找时就不需要一直回溯了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span>(root != father[root]) &#123;	<span class="comment">// 寻找根结点</span></span><br><span class="line">        root = father[root];	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面把路径上的所有结点的father都改成根结点</span></span><br><span class="line">    <span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = father[x];		<span class="comment">// 记录x的father</span></span><br><span class="line">        father[x] = root;		<span class="comment">// 把x的father结点指向root</span></span><br><span class="line">        x = a;					<span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（5）应用——亲戚问题"><a href="#（5）应用——亲戚问题" class="headerlink" title="（5）应用——亲戚问题"></a>（5）应用——亲戚问题</h5><blockquote>
<p><strong>题目背景</strong><br>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br><strong>题目描述</strong><br>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br><strong>输入格式</strong><br>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。<br><strong>输出格式</strong><br>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>
</blockquote>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5005</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXN], rank[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);</span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, p, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        merge(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(x) == find(y) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="4）堆"><a href="#4）堆" class="headerlink" title="4）堆"></a>4）堆</h4><p>堆是一棵<strong>完全二叉树</strong>，树中每个节点的值都不小于（或不大于）其左右孩子结点的值。</p>
<ul>
<li>如果父亲结点大于等于孩子结点，称为<strong>大顶堆</strong>，此时每个结点的值都是以它为根结点的子树的最大值；</li>
<li>如果父亲结点小于等于孩子结点，称为<strong>小顶堆</strong>，此时每个结点的值都是以它为根结点的子树的最小值；</li>
</ul>
<p>对于完全二叉树来说，可以使用数组来定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn], n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，第一个结点将存储于数组中的1号位，并且数组i号位表示的结点的左孩子就是2i号位，而右孩子则是2i+1号位。</p>
<h5 id="（1）建堆"><a href="#（1）建堆" class="headerlink" title="（1）建堆"></a>（1）建堆</h5><p>建堆是一个<strong>向下调整</strong>的过程：</p>
<ul>
<li>总是将当前节点 i 与它的左右孩子比较，若孩子的权值比 i 还大，就将两者交换；</li>
<li>交换完毕后继续让节点 i 和孩子比较，直到 i 的孩子的权值都比 i的权值小或者不存在孩子结点。</li>
</ul>
<p>向下调整的代码如下，时间复杂度为 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对heap数组在[low, high]范围进行向下调整</span></span><br><span class="line"><span class="comment">// 其中low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = <span class="number">2</span> * i;		<span class="comment">// i为欲调整结点，j为其左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) &#123;			<span class="comment">// 存在孩子结点</span></span><br><span class="line">    	<span class="comment">// 如果右孩子存在，且右孩子的值大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">            j = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果孩子中最大的权值比欲调整节点i大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[j] &gt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);</span><br><span class="line">            i = j;				<span class="comment">// 保持i为欲调整节点、j为i的左孩子</span></span><br><span class="line">            j = i * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;				<span class="comment">// 孩子的权值均比欲调整节点i小，调整结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>那么<strong>建堆</strong>的过程也就很容易了。由于完全二叉树的叶子节点个数为 $\lceil n/2 \rceil$ ，因此数组下标在 $[1, \lfloor n/2 \rfloor]$ 范围内的都是非叶子节点。于是可以从 $\lfloor n/2 \rfloor$ 号位开始倒着枚举结点，对每个遍历到的结点 i 进行 $[i, n]$ 范围的调整。这种做法能够<strong>保证每个调整完的结点都是以其为根结点的子树汇总的全职最大的结点</strong>。</p>
<p>建堆的代码如下，时间复杂度为 $O(n)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）删除堆顶元素"><a href="#（2）删除堆顶元素" class="headerlink" title="（2）删除堆顶元素"></a>（2）删除堆顶元素</h5><p>如果要删除堆中的最大元素，即堆顶元素，并让其仍然保持堆的结构，只需要最后一个元素覆盖堆顶元素，然后对根结点进行调整即可。</p>
<p>代码如下，时间复杂度为 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];	<span class="comment">// 用最后一个元素覆盖堆顶元素，并让元素个数减1</span></span><br><span class="line">    downAdjust(<span class="number">1</span>, n);		<span class="comment">// 从上向下调整堆顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（3）向堆中添加元素"><a href="#（3）向堆中添加元素" class="headerlink" title="（3）向堆中添加元素"></a>（3）向堆中添加元素</h5><p>如果想要往堆里添加一个元素，可以吧其放在数组最后，然后进行<strong>向上调整</strong>操作。</p>
<ul>
<li>向上调整总是把欲调整结点与父亲结点比较，如果权值比父亲大，就交换之，反复此过程。</li>
</ul>
<p>向上调整的代码如下，时间复杂度为 $O(logn)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对heap数组在[low, high]范围内进行向上调整</span></span><br><span class="line"><span class="comment">// 其中low一般设置为1，high表示欲调整节点的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;	<span class="comment">// i为欲调整结点，j为其父亲</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= low) &#123;</span><br><span class="line">        <span class="comment">// 父亲权值小于欲调整结点i的权值</span></span><br><span class="line">        <span class="keyword">if</span>(heap[j] &lt; heap[i]) &#123;</span><br><span class="line">            swap(heap[j], heap[i]);	<span class="comment">// 交换父亲和欲调整结点</span></span><br><span class="line">            i = j;			<span class="comment">// 保持i为欲调整结点，j为i的父亲</span></span><br><span class="line">            j = i / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;			<span class="comment">// 父亲权值比与调整结点i的权值大，调整结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上，就很容易实现<strong>添加元素</strong>的代码了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（4）堆排序"><a href="#（4）堆排序" class="headerlink" title="（4）堆排序"></a>（4）堆排序</h5><p>堆排序是指<strong>使用堆结构对一个序列进行排序</strong>。</p>
<p>我们考虑递增排序的情况，对于一个大顶堆来说，堆排序的直观思路是：</p>
<ol>
<li>取出堆顶元素，然后将堆的最后一个元素替换至堆顶，再进行一次针对堆顶元素的向下调整；</li>
<li>如此重复，直到堆中只有一个元素为止。</li>
</ol>
<p>具体实现时，为了节省空间，可以倒着遍历数组：</p>
<ul>
<li>假设当前访问到 i号位，那么将堆顶元素与 i 号位的元素交换，接着在 $[1, i-1]$ 范围内对堆顶元素进行一次向下调整即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createHeap();		<span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(heap[i], heap[<span class="number">1</span>]);		<span class="comment">// 交换heap[i]与堆顶</span></span><br><span class="line">        downAdjust(<span class="number">1</span>, i<span class="number">-1</span>);			<span class="comment">// 调整堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="5）哈夫曼树"><a href="#5）哈夫曼树" class="headerlink" title="5）哈夫曼树"></a>5）哈夫曼树</h4><p>先介绍经典的合并果子问题：</p>
<blockquote>
<p>有n堆果子，每堆果子的质量已知，现在需要把这些果子合并成一堆，但是每次只能把两堆果子合并到一起，同时会消耗与两堆果子质量之和等值的体力。显然，在进行n-1次合并之后，就只剩下一堆了。为了尽可能节省体力，请设计出合并的次序方案，使得耗费的体力最少，并给出消耗的体力值。</p>
<p>例如有3堆果子，质量依次为1、2、9。那么可以先将质量为 1和2的果堆合并，新堆质量为3，因此耗费体力为3。接着，将新堆与原先的质量为9的果堆合并，又得到新的堆，质量为12，因此耗费体力为12。所以耗费体力之和为3+12=15。可以证明15为最小的体力耗费值。</p>
</blockquote>
<p>为了解决这个问题，我们把每堆果子都看作结点，果堆的质量视作结点的权值，这样合并两个果堆的过程可以视作给它们生成一个父结点，于是把n堆果子合并成一堆的过程可以用一棵树来表示。</p>
<p>如下图是将 1、2、3、4、5、6 进行合并的某一种方案。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210308224644236.png" alt="image-20210308224644236" style="zoom:80%;" />



<p>把叶子结点的权值乘以路径长度的结果称为这个叶子结点的<strong>带权路径长度（Weighted Path Length of Tree, WPL）</strong>。那么树的WPL就等于所有叶子结点的WPL之和。</p>
<p>我们称带权路径长度最小的树为<strong>哈夫曼树</strong>（又称为最由二叉树）。显然，哈夫曼树可以不唯一，但最小WPL一定是唯一的。</p>
<h5 id="（1）构造哈夫曼树"><a href="#（1）构造哈夫曼树" class="headerlink" title="（1）构造哈夫曼树"></a>（1）构造哈夫曼树</h5><p>下面介绍<strong>构造一棵哈夫曼树的算法</strong>：</p>
<ol>
<li>初始状态下共有n个结点（结点权值分别是给定的n个数），将它们视作n棵只有一个结点的树；</li>
<li>合并其中根结点权值最小的两棵树，生成两棵树根结点的父结点，权值为这两个根结点的权值之和，这样树的数量就少了一个；</li>
<li>重复操作2，直到只剩下一棵为止，这棵树就是哈夫曼树。</li>
</ol>
<p>事实上，在很多实际场景中，不需要真的去构建一棵哈夫曼树，只需要能得到最终的带权路径长度即可。因此我们需要着重掌握的是哈夫曼树的<strong>构建思想</strong>：</p>
<ul>
<li><strong>反复选择两个最小的元素，合并，直到只剩下一个元素</strong>。</li>
</ul>
<p>因此，一般可以使用<strong>优先队列（小顶堆）</strong>来执行这种策略。</p>
<ol>
<li>初始状态下降果堆的质量压入优先队列；</li>
<li>之后每次从优先队列顶部取出两个最小的数，将它们相加并重新压入优先队列；</li>
<li>重复操作2，直到只剩下一个数，此时就得到了消耗的最小体力。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表小顶堆的优先队列</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp, x, y, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;temp);</span><br><span class="line">        q.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>) &#123;	<span class="comment">// 优先队列中至少有两个元素</span></span><br><span class="line">        x = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        y = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        q.push(x + y);		<span class="comment">// 取出堆顶的两个元素，求和后压入优先队列</span></span><br><span class="line">        ans += (x + y);		<span class="comment">// 累计求和的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）哈夫曼编码"><a href="#（2）哈夫曼编码" class="headerlink" title="（2）哈夫曼编码"></a>（2）哈夫曼编码</h5><p>对于任意一棵二叉树来说，如果把二叉树上的所有分支都进行编号，且做分值标记为0，右分支标记为1，那么对树上的任意一个结点，都可以根据从根结点出发到达它的分支顺序得到一个编号，且这个编号是唯一的。并且，<strong>对于任何一个叶子结点，其编号一定不会成为其他任何一个结点编号的前缀</strong>。</p>
<p>这有什么用呢？我们考虑下面这个问题：</p>
<blockquote>
<p>假设现在有一个字符串，它由A、B、C、D这四个英文字符的一个或多个组成，例如 ABCAD。现在希望把它编码成一个01串，这样方便进行数据传输。能想到的一个办法是把A~D各自用一个01 串表示，然后拼接起来即可。</p>
<p>例如可以把A用0表示、B用1表示、C用 00表示、D用 01表示，这样 ABCAD就可以用0100001表示。但是很快就会发现，解码的时候无法知道开头的 01到底是 AB还是D（因为 AB和D的编码都是 01），因此这种编码方式是不行的。</p>
<p>为什么不行呢？这是因为<strong>存在一种字符的编码是另一种字符的编码的前缀</strong>，例如 A 的编码是 D的编码的前缀，于是一旦有某一种字符的编码拼接在 A的编码之后能产生D的编码，就会产生混淆，例如此处把B的编码拼接在A的编码之后能产生 D的编码。</p>
</blockquote>
<p>因此，需要寻找一套编码方式，使得其中<strong>任何一个字符的编码都不是另一个字符的编码的前缀</strong>，同时把满足这种编码方式的编码称为<strong>前缀编码</strong>。</p>
<p>考虑进一步的问题，对一个给定的字符串来说，肯定有多种前缀编码的方式，但为了信息传递的效率，需要尽量<strong>选择长度最短</strong>的编码方式。因此，我们希望出现<strong>频次最高的字符对应的编码长度应最短</strong>。而如果把频数作为叶子结点的权值，那么<strong>字符串编码成01串后的长度实际上就是这棵树的带权路径长度</strong>。</p>
<p>显然，这个问题已经得到解决——就是哈夫曼树。这种由哈夫曼树产生的编码方式被称为<strong>哈夫曼编码</strong>。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/image-20210308232052967.png" alt="image-20210308232052967" style="zoom:80%;" />



<p>需要注意的是，<strong>哈夫曼编码是针对确定的字符串来讲的</strong>。只有对确定的字符串才能根据其中各字符的出现次数建立哈夫曼树，才有对应的哈夫曼编码。</p>
<h2 id="0x04-图算法专题"><a href="#0x04-图算法专题" class="headerlink" title="0x04 图算法专题"></a>0x04 图算法专题</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/">http://jay1zhang.github.io/2021/03/05/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%20C++%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="http://jayyy1.gitee.io/images/pictures/cartoons/010.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/03/03/BUAA/%E3%80%8CPaper%E3%80%8D%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"><img class="next-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/002.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">「Paper」一文解决参考文献格式问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/12/31/Coding/LeetCode/「算法」03-贪心思想/" title="「算法」03-贪心思想"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/006.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」03-贪心思想</div></div></a></div><div><a href="/2021/01/23/Coding/Algorithm/「LeetCode题解」数据结构相关/" title="「LeetCode题解」数据结构相关"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/038.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">「LeetCode题解」数据结构相关</div></div></a></div><div><a href="/2021/01/29/Coding/Algorithm/「算法进阶」《算法导论》（三）之数据结构问题/" title="「算法进阶」《算法导论》（三）之数据结构问题"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/006.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">「算法进阶」《算法导论》（三）之数据结构问题</div></div></a></div><div><a href="/2021/01/29/Coding/Algorithm/「算法进阶」《算法导论》（四）之图算法-NP问题/" title="「算法进阶」《算法导论》（四）之图算法-NP问题"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/038.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">「算法进阶」《算法导论》（四）之图算法-NP问题</div></div></a></div><div><a href="/2020/12/31/Coding/LeetCode/「算法」01-双指针/" title="「算法」01-双指针"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/017.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」01-双指针</div></div></a></div><div><a href="/2020/12/31/Coding/LeetCode/「算法」02-排序/" title="「算法」02-排序"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/033.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」02-排序</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-C-C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">0x00 C&#x2F;C++ 程序设计基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">黑盒测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89"><span class="toc-text">0x01 C++ 标准模板库（STL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vector"><span class="toc-text">1. vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89vector%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1）vector的定义与初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89vector%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）vector容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89vector%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）vector常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-set"><span class="toc-text">2. set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-string"><span class="toc-text">3. string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89string%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）string的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89string-%E4%B8%AD%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）string 中内容的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">3）string常用函数示例解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-map"><span class="toc-text">4. map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89map%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）map的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89map%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）map容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89map%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）map常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-queue"><span class="toc-text">5. queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89queue%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）queue的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）queue容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）queue常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-priority-queue"><span class="toc-text">6. priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89priority-queue%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）priority_queue的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89priority-queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）priority_queue容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89priority-queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）priority_queue常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89priority-queue%E5%86%85%E5%85%83%E7%B4%A0%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">4）priority_queue内元素优先级的设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-stack"><span class="toc-text">7. stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89stack%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）stack的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）stack容器内元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）stack常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-pair"><span class="toc-text">8. pair</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89pair%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1）pair的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89pair%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">2）pair中元素的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89pair%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3）pair常用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-algorithm%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">0x02 algorithm头文件下的常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-text">1. 基本运算函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-next-permutation"><span class="toc-text">2. next_permutation()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-reverse"><span class="toc-text">3. reverse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-fill"><span class="toc-text">4. fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-lower-bound-%E5%92%8C-upper-bound"><span class="toc-text">5. lower_bound() 和 upper_bound()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-sort"><span class="toc-text">6. sort()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-sort-%E6%8E%92%E5%BA%8F"><span class="toc-text">1）如何使用 sort 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0-cmp"><span class="toc-text">2）如何实现比较函数 cmp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98"><span class="toc-text">0x03 数据结构专题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-text">1. 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-text">2. 队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8"><span class="toc-text">3. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1）链表的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%B8%BA%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">2）为链表结点分配内存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">3）链表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4. 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8"><span class="toc-text">1）树的定义与性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">2）二叉树的存储结构与基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">3）二叉树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E4%BB%8E%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4）从遍历序列中重建二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E4%BB%8E%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%9C%8B-DFS-%E4%B8%8E-BFS"><span class="toc-text">5）从树的遍历看 DFS 与 BFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%91%E7%9A%84%E5%BB%B6%E4%BC%B8%E7%AE%97%E6%B3%95"><span class="toc-text">5. 树的延伸算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-text">1）二叉查找树（BST）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-text">（1）查找操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">（2）插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="toc-text">（3）创建操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">（4）删除操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">（5）二叉查找树的性质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="toc-text">2）平衡二叉树（AVL）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-1"><span class="toc-text">（1）查找操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">（2）旋转操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">（3）插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="toc-text">（4）创建操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">3）并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">（1）初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E6%89%BE"><span class="toc-text">（2）查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%90%88%E5%B9%B6"><span class="toc-text">（3）合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E4%BA%B2%E6%88%9A%E9%97%AE%E9%A2%98"><span class="toc-text">（5）应用——亲戚问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%A0%86"><span class="toc-text">4）堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BB%BA%E5%A0%86"><span class="toc-text">（1）建堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-text">（2）删除堆顶元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%90%91%E5%A0%86%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">（3）向堆中添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">（4）堆排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">5）哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">（1）构造哈夫曼树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">（2）哈夫曼编码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E5%9B%BE%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98"><span class="toc-text">0x04 图算法专题</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/012.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
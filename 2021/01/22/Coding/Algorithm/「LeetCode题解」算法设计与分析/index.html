<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「LeetCode题解」算法设计与分析 | J1z's Blog</title><meta name="keywords" content="Algorithm"><meta name="author" content="Jay"><meta name="copyright" content="Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="0x00 前言本文在 CS-Notes&#x2F;LeetCode 的基础上又进一步做了整理与补充。  双指针 排序 贪心思想 二分查找 分治 搜索 动态规划 数学  0x01 双指针双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 1. 有序数组的 Two Sum167. Two Sum II - Input array is sorted (Easy) 【题目描述】 在有序数组中找出两">
<meta property="og:type" content="article">
<meta property="og:title" content="「LeetCode题解」算法设计与分析">
<meta property="og:url" content="http://jay1zhang.github.io/2021/01/22/Coding/Algorithm/%E3%80%8CLeetCode%E9%A2%98%E8%A7%A3%E3%80%8D%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="J1z&#39;s Blog">
<meta property="og:description" content="0x00 前言本文在 CS-Notes&#x2F;LeetCode 的基础上又进一步做了整理与补充。  双指针 排序 贪心思想 二分查找 分治 搜索 动态规划 数学  0x01 双指针双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 1. 有序数组的 Two Sum167. Two Sum II - Input array is sorted (Easy) 【题目描述】 在有序数组中找出两">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/033.jpg">
<meta property="article:published_time" content="2021-01-22T08:09:01.000Z">
<meta property="article:modified_time" content="2021-03-04T13:36:01.896Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/033.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jay1zhang.github.io/2021/01/22/Coding/Algorithm/%E3%80%8CLeetCode%E9%A2%98%E8%A7%A3%E3%80%8D%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKEK6XV2V5","apiKey":"e093fbb9f29fdf5c7ddd56ec43e9ae05","indexName":"Jay","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-04 21:36:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/033.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1z's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「LeetCode题解」算法设计与分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-01-22T08:09:01.000Z" title="Created 2021-01-22 16:09:01">2021-01-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-04T13:36:01.896Z" title="Updated 2021-03-04 21:36:01">2021-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding/">Coding</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>75min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文在 <a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">CS-Notes/LeetCode</a> 的基础上又进一步做了整理与补充。</p>
<ul>
<li>双指针</li>
<li>排序</li>
<li>贪心思想</li>
<li>二分查找</li>
<li>分治</li>
<li>搜索</li>
<li>动态规划</li>
<li>数学</li>
</ul>
<h2 id="0x01-双指针"><a href="#0x01-双指针" class="headerlink" title="0x01 双指针"></a>0x01 双指针</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p>
<h3 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1. 有序数组的 Two Sum"></a>1. 有序数组的 Two Sum</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">167. Two Sum II - Input array is sorted (Easy)</a></p>
<p><strong>【题目描述】</strong></p>
<p>在有序数组中找出两个数，使它们的和为 target。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers=&#123;2, 7, 11, 15&#125;, target=9</span><br><span class="line">Output: index1=1, index2=2</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<p>数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为  O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j  = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i+<span class="number">1</span>, j+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【拓展】</strong>若 <code>nums</code> 为无序数组呢？</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">1.Two Sum</a></p>
<p><strong>【题解 - 1】</strong>暴力法</p>
<ul>
<li>由于target已给出，故对每个nums[i]，我们希望找到这样一个j，使得nums[j] = target - nums[i]。因而最简单的便是两层 for 循环了。查找复杂度为 $O(n)$ ，总复杂度为 $O(n^2)$ ；</li>
</ul>
<p><strong>【题解 - 2】</strong>利用STL的Hash表改善查找算法</p>
<ul>
<li><p>可以利用STL中的 <code>unordered_map</code> 实现，<code>&lt;key, value&gt; -&gt; &lt;nums[j], j&gt;</code>。</p>
<ul>
<li>C++ 中map是基于红黑树实现的，unordered_map则基于哈希表实现。</li>
</ul>
</li>
<li><p>注意到，该问题具有对称性，即由nums[i]查nums[j]和由nums[j]查nums[i]是等价的。因此，每访问一个元素，</p>
<ol>
<li>在hash表中查询是否存在对应的j，若找到，则直接return。</li>
<li>将当前项加入hash表中。</li>
</ol>
</li>
<li><p>由于hash表的查询效率为 $O(1)$ ，故总复杂度为 $O(n)$ 。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(hash.count(target - nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> &#123;i, hash[target - nums[i]]&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">           hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">633. Sum of Square Numbers (Easy)</a></p>
<p><strong>【题目描述】</strong>判断一个非负整数是否为两个整数的平方和。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<ul>
<li><p>本题和 Two Sum 类似，可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target。</p>
</li>
<li><p>本题有几个关键点：</p>
<ol>
<li>右指针的初始化，实现剪枝，从而降低时间复杂度。</li>
<li>i与j是可以相同的，如 $2 = 1^2 + 1^2$ 。 </li>
<li>因为牵涉到平方，所以要用long long代替，防止爆int。</li>
</ol>
</li>
<li><p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> j = sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*i + j*j == c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i*i + j*j &lt; c) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/">345. Reverse Vowels of a String (Easy)</a></p>
<p><strong>【题目描述】</strong>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<ul>
<li><p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p>
</li>
<li><p>交换时可以新开一个string，也可以直接用STL里提供的swap函数由于内部实现为引用传递，故这里可以直接对s本身进行修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 O(N)：只需要遍历所有元素一次；空间复杂度 O(1)：只需要使用两个额外变量</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> ||</span><br><span class="line">           c == <span class="string">&#x27;A&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVowel(s[i])) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!isVowel(s[j])) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(s[i++], s[j--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/description/">680. Valid Palindrome II (Easy)</a></p>
<p><strong>【题目描述】</strong>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<ul>
<li><p>所谓回文字符串，是指具有左右对称特点的字符串，例如 “abcba” 就是一个回文字符串</p>
</li>
<li><p>本题的关键在于<strong>最多可以删除一个字符</strong>，因而本题可以用双指针来判断s是否为回文串，但如果出现两个指针指向的字符不相等的情况，我们可以删除左字符或右字符，<strong>直接判断子串是否为回文串</strong>即可。</p>
</li>
<li><p>时间复杂度O(N)；采用<strong>引用传递</strong>的方式将大大减少空间复杂度。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bool isPalindrome(string s, int i, int j) &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i++] != s[j--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.length()<span class="number">-1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s, i+<span class="number">1</span>, j) | isPalindrome(s, i, j<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="5-归并两个有序数组"><a href="#5-归并两个有序数组" class="headerlink" title="5. 归并两个有序数组"></a>5. 归并两个有序数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/description/">88. Merge Sorted Array (Easy)</a></p>
<p><strong>【题目描述】</strong>把归并结果存到第一个数组上。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p><strong>【题解 - 1】</strong></p>
<p>常规思路，简单的归并问题，要熟悉vector的使用。</p>
<ul>
<li><p>对于本题来说，由于 <code>nums1</code> 的大小本来就是 m+n，因而如果使用vector的insert操作，还需要删除最后一个元素。</p>
</li>
<li><p><code>iterator insert(iterator it,const T&amp; x)</code> ：向量中迭代器指向元素前增加一个元素x</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">                nums1.insert(nums1.begin() + i, nums2[j]);	<span class="comment">// 在i之前插入一个元素</span></span><br><span class="line">                nums1.pop_back();   <span class="comment">// 删除vector最后的一个元素</span></span><br><span class="line">                i++, j++, m++;      <span class="comment">// 由于插入了一个元素，m增大</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">            nums1[i++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【题解 - 2】</strong> </p>
<p>正向遍历时需要插入和删除操作，十分冗余，不妨直接覆盖原值。这就需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m<span class="number">-1</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = m+n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[index--] = nums2[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[index--] = nums1[i--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[index--] = nums1[i--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[index--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/description/">141. Linked List Cycle (Easy)</a></p>
<p><strong>【题目描述】</strong>给定一个链表，判断链表中是否有环</p>
<p><strong>【题解 - 1】快慢指针法</strong></p>
<p>通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。</p>
<ul>
<li>如果链表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。</li>
<li>如果链表中存在环，快指针一定会追上慢指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *l1 = head, *l2 = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span> &amp;&amp; l2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 == l2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【题解 - 2】</strong>标记法</p>
<p>用一个map标记走过的地方，每访问一个结点，查看是否已经访问过。</p>
<ul>
<li>但这种方法耗时是解法1的二倍，应该是 <code>visited.count(l)</code> 要比 <code>l1 == l2</code> 更加耗时。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; visited;</span><br><span class="line">        visited[head] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(ListNode *l = head-&gt;next; l != <span class="literal">NULL</span>; l = l-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.count(l) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="7-最长子序列（中）"><a href="#7-最长子序列（中）" class="headerlink" title="7. 最长子序列（中）"></a>7. 最长子序列（中）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/">524. Longest Word in Dictionary through Deleting (Medium)</a></p>
<p><strong>【题目描述】</strong>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。</p>
<ul>
<li>如果答案不止一个，返回<strong>长度最长且字典顺序最小</strong>的字符串。</li>
<li>如果答案不存在，则返回空字符串。</li>
</ul>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line">输出: &quot;apple&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">输出: &quot;a&quot;</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>简单的公共子串问题，双指针解决，注意最终答案优先级的比较即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubstr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j]) &#123;</span><br><span class="line">                i++, j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j==n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较优先级大小 - 长度最长，且字典序最小的优先级最高</span></span><br><span class="line"><span class="comment">     *  若s1优先级高于s2，则返回1</span></span><br><span class="line"><span class="comment">     *  若s1优先级低于s2，则返回-1</span></span><br><span class="line"><span class="comment">     *  不存在s1与s2的优先级相同的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len1 &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 长度相同，判断字典序大小</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i] &lt; s2[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] &gt; s2[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++, j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 该行永远不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> longestWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = d.begin(); iter != d.end(); iter++) &#123;</span><br><span class="line">            <span class="built_in">string</span> word = *iter;</span><br><span class="line">            <span class="keyword">if</span>(isSubstr(s, word) &amp;&amp; compare(longestWord, word) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                longestWord = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="0x02-排序"><a href="#0x02-排序" class="headerlink" title="0x02 排序"></a>0x02 排序</h2><h3 id="1-快排序与堆排序（中）"><a href="#1-快排序与堆排序（中）" class="headerlink" title="1. 快排序与堆排序（中）"></a>1. 快排序与堆排序（中）</h3><p>用于求解 <strong>Kth Element</strong> 问题，也就是第K个元素的问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">215. Kth Largest Element in an Array (Medium)</a></p>
<p><strong>【题目描述】</strong>在未排序的数组中找到第 k 个最大的元素。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p><strong>【题解 - 1】</strong> 快速选择法</p>
<p>在快速排序中，每次经过「划分」操作后，我们一定可以<strong>确定一个元素的最终位置</strong>，即 $x$ 的最终位置为 $q$ ，所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。</p>
<ul>
<li><p>注意到第 k 个最大元素也就是第 N - k 个最小元素，方便起见我们采用第 k 小算法来解决本问题。</p>
<blockquote>
<p>之所以说第k小算法更简洁，是因为这时候k是从0开始的，这样k与下标恰好一一对应；</p>
<p>而对于第k大元素，k则从1开始，这样第一大的元素，恰好是第 N-1 小的元素。</p>
</blockquote>
</li>
</ul>
<p>算法步骤：</p>
<ol>
<li>随机选择一个枢轴。</li>
<li>使用<strong>划分算法</strong>将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边，确定枢轴的最终位置 $pos$。</li>
<li>比较 $pos$ 和 $target = N - k$ 的大小<ul>
<li>如果划分得到的 $pos$ 正好就是我们需要的下标，就直接返回 $a[q]$ ；</li>
<li>否则，如果 $pos$ 比目标下标小，就递归右子区间，否则递归左子区间。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>快速选择算法</strong> 的平均时间复杂度为 O(N)。</p>
<blockquote>
<p>直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n - 1，每次递归的时候又向 n - 1 的集合中递归，这种情况是最坏的，时间代价是 O(n^2)。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(a[i], a[r]);</span><br><span class="line">        <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= key) &#123;</span><br><span class="line">                swap(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[++i], a[r]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSelectKthMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = randomPartition(a, l, r);</span><br><span class="line">        <span class="comment">//int pos = partition(a, l, r);</span></span><br><span class="line">        <span class="keyword">if</span> (pos == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[pos];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pos &lt; target ? quickSelectKthMin(a, pos + <span class="number">1</span>, r, target) </span><br><span class="line">                                : quickSelectKthMin(a, l, pos - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelectKthMin(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>【题解 - 2】</strong>堆排序</p>
<p>维护一个大小为K的大顶堆，则堆顶元素就是第K大的元素。</p>
<ul>
<li>利用C++的priority_queue实现，复杂度为 O(Nlogk)，实际用时与快排相差无几。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(q.size() &gt; k) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2. 桶排序"></a>2. 桶排序</h3><h4 id="2-1-出现频率最多的-k-个元素（中）"><a href="#2-1-出现频率最多的-k-个元素（中）" class="headerlink" title="2.1 出现频率最多的 k 个元素（中）"></a>2.1 出现频率最多的 k 个元素（中）</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/description/">347. Top K Frequent Elements (Medium)</a></p>
<p><strong>【题目描述】</strong> 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong>桶排序</p>
<ol>
<li>统计各元素出现的次数</li>
<li>设置若干个桶，<strong>每个桶存储出现频率相同的数</strong>，桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</li>
<li>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 统计各元素出现次数, &lt;统计元素，出现次数&gt;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">            freq[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 设置bucket，用一个每个元素都是list&lt;int&gt;的数组实现</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; buckets[nums.size() + <span class="number">1</span>];   <span class="comment">// 务必注意大小要+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = freq.begin(); iter != freq.end(); iter++) &#123;</span><br><span class="line">            buckets[iter-&gt;second].push_back(iter-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 输出result集合，大小为k</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num: buckets[i]) &#123;</span><br><span class="line">                res[cnt++] = num;</span><br><span class="line">                <span class="keyword">if</span>(cnt == k) <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-按照字符出现次数对字符串排序（中）"><a href="#2-2-按照字符出现次数对字符串排序（中）" class="headerlink" title="2.2 按照字符出现次数对字符串排序（中）"></a>2.2 按照字符出现次数对字符串排序（中）</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency/description/">451. Sort Characters By Frequency (Medium)</a></p>
<p><strong>【题目描述】</strong>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<ul>
<li>要求：<ol>
<li>相同的字母必须放在一起</li>
<li>‘A’ 和 ‘a’ 看作两种不同的字符</li>
<li>显然，答案可以不唯一</li>
</ol>
</li>
</ul>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;tree&quot;</span><br><span class="line">输出: &quot;eert&quot;</span><br><span class="line">解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong>桶排序</p>
<p>同上一题。</p>
<ol>
<li>统计每个字符的频率</li>
<li>设置若干个桶，<strong>每个桶存储出现频率相同的字符</strong>，桶的下标表示数出现的频率，即第 i 个桶中存储的字符出现的频率为 i。</li>
<li>把字符都放到桶之后，从后向前遍历桶，注意输出相同字符。</li>
</ol>
<p>【我的桶排序】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 统计各元素出现次数, &lt;统计元素，出现次数&gt;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            freq[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. list实现，数组下标为统计次数</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; buckets[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = freq.begin(); iter != freq.end(); iter++) &#123;</span><br><span class="line">            buckets[iter-&gt;second].push_back(iter-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 输出res</span></span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: buckets[i]) &#123;</span><br><span class="line">                <span class="comment">// 每个字符c，出现频率为i，因此要输出i个。</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    ss &lt;&lt; c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【别人家的桶排序】</p>
<p>利用二维vector实现buckets，似乎也还不错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">counts</span><span class="params">(<span class="number">129</span>, <span class="number">0</span>)</span></span>;	<span class="comment">// 初始化129个值为0的int</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) </span><br><span class="line">            ++counts[c];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; buckets(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">128</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counts[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buckets[counts[i]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : buckets[i]) &#123;</span><br><span class="line">                res.append(i, c);	<span class="comment">// i输出c次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="3-荷兰国旗问题-三向切分快排（中）"><a href="#3-荷兰国旗问题-三向切分快排（中）" class="headerlink" title="3. 荷兰国旗问题 - 三向切分快排（中）"></a>3. 荷兰国旗问题 - 三向切分快排（中）</h3><p>荷兰国旗包含三种颜色：红、白、蓝。</p>
<p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是<strong>三向切分快速排序</strong>的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/description/">75. Sort Colors (Medium)</a></p>
<p><strong>【题目描述】</strong>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p> <strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>我们用三个指针（p0, p2 和cur）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。</p>
<p><img src="https://gitee.com/Jayyy1/images/raw/master/posts/Coding/Algorithm/Snipaste_2020-02-03_00-51-16.png"></p>
<p>本解法的思路是沿着数组移动 <code>cur</code> 指针，若 <code>nums[cur] = 0</code>，则将其与 <code>nums[p0]</code> 互换；若 <code>nums[curr] = 2</code> ，则与 <code>nums[p2]</code> 互换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, cur = <span class="number">0</span>, p2 = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt;= p2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums[cur++], nums[p0++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[cur] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums[cur], nums[p2--]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="0x03-贪心思想"><a href="#0x03-贪心思想" class="headerlink" title="0x03 贪心思想"></a>0x03 贪心思想</h2><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>
<h3 id="1-分配饼干"><a href="#1-分配饼干" class="headerlink" title="1. 分配饼干"></a>1. 分配饼干</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/description/">455. Assign Cookies (Easy)</a></p>
<p><strong>【题目描述】</strong> 每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid[1,3], size[1,2,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<ol>
<li>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</li>
<li>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; g.size() &amp;&amp; j &lt; s.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i] &lt;= s[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【贪心策略的证明】</strong></p>
<blockquote>
<p>在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解，下用反证法证明。</p>
</blockquote>
<p>假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p>
<h3 id="2-不重叠的区间个数（中）"><a href="#2-不重叠的区间个数（中）" class="headerlink" title="2. 不重叠的区间个数（中）"></a>2. 不重叠的区间个数（中）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/description/">435. Non-overlapping Intervals (Medium)</a></p>
<p><strong>【题目描述】</strong>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong> 按照贪心的思想，在每次选择中，区间的结尾最为重要，因为选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; end) &#123;</span><br><span class="line">                <span class="comment">/** 区间2的左端点小于区间1的右端点，即区间重叠</span></span><br><span class="line"><span class="comment">                 *  注意这里有两种情况</span></span><br><span class="line"><span class="comment">                 *  1. 两区间交叉重叠，则舍弃第二个</span></span><br><span class="line"><span class="comment">                 *  2. 第二个区间整个被包含在第一个区间内，则舍弃第一个</span></span><br><span class="line"><span class="comment">                 *  总之，一定要移除一个区间。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                end = min(end, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="3-投飞镖刺破气球（中）"><a href="#3-投飞镖刺破气球（中）" class="headerlink" title="3. 投飞镖刺破气球（中）"></a>3. 投飞镖刺破气球（中）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/">452. Minimum Number of Arrows to Burst Balloons (Medium)</a></p>
<p><strong>【题目描述】</strong> 气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>同前一题，计算不重叠的区间个数，区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.empty())  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        sort(points.begin(), points.end());</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &lt;= end) &#123;</span><br><span class="line">                <span class="comment">// 两种情况</span></span><br><span class="line">                end = min(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="4-根据身高和序号重组队列（难）"><a href="#4-根据身高和序号重组队列（难）" class="headerlink" title="4. 根据身高和序号重组队列（难）"></a>4. 根据身高和序号重组队列（难）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/">406. Queue Reconstruction by Height(Medium)</a></p>
<p><strong>【题目描述】</strong> 给定一组打乱的队列，每个人用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个人的身高比他高或者和他一样高，请据此重组队列。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line">Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>插入排序：</p>
<ul>
<li>为了使插入操作不影响后续的操作，<strong>身高较高的学生应该先做插入操作</strong>，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</li>
<li>当身高相同时，按照k升序排序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 身高越高，优先级越高；身高相同，k越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]);</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="keyword">if</span>(people.empty())  <span class="keyword">return</span> people;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort(people.begin(), people.end(), greater&lt;int&gt;());</span></span><br><span class="line">        sort(people.begin(), people.end(), compare);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> person: people) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.insert(<span class="built_in">queue</span>.begin() + person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="5-买卖股票的最大收益"><a href="#5-买卖股票的最大收益" class="headerlink" title="5. 买卖股票的最大收益"></a>5. 买卖股票的最大收益</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock (Easy)</a></p>
<p>**【题目描述】 **给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<ul>
<li>记录前面最小的价格，并将这个最小价格作为买入价格；</li>
<li>然后将当前收益作为售出价格，与最大收益比较。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min_price = prices[<span class="number">0</span>], max_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            max_profit = max(max_profit, prices[i] - min_price);</span><br><span class="line">            min_price = min(min_price, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="6-买卖股票的最大收益-‖"><a href="#6-买卖股票的最大收益-‖" class="headerlink" title="6. 买卖股票的最大收益 ‖"></a>6. 买卖股票的最大收益 ‖</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/">122. Best Time to Buy and Sell Stock II (Easy)</a></p>
<p><strong>【题目描述】</strong> 可以进行多次交易，但多次交易之间不能交叉进行。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>有一说一，这个真没想到…</p>
<ul>
<li>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                profit += (prices[i] - prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="7-种植花朵"><a href="#7-种植花朵" class="headerlink" title="7.  种植花朵"></a>7.  种植花朵</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-place-flowers/description/">605. Can Place Flowers (Easy)</a>    </p>
<p><strong>【题目描述】</strong></p>
<p>flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解能否再种下 n 朵花。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>考虑当前位能否种花，即考虑相邻两位是否为1即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = flowerbed.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> last = i == <span class="number">0</span>? <span class="number">0</span> : flowerbed[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> next = i == len<span class="number">-1</span>? <span class="number">0</span> : flowerbed[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(last == <span class="number">0</span> &amp;&amp; next == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="8-判断是否为子序列（中）"><a href="#8-判断是否为子序列（中）" class="headerlink" title="8. 判断是否为子序列（中）"></a>8. 判断是否为子序列（中）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/description/">392. Is Subsequence (Medium)</a>    略</p>
<h3 id="9-修改一个数成为非递减数组"><a href="#9-修改一个数成为非递减数组" class="headerlink" title="9. 修改一个数成为非递减数组"></a>9. 修改一个数成为非递减数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/description/">665. Non-decreasing Array (Easy)</a></p>
<p><strong>【题目描述】</strong> 判断一个数组是否能只修改一个数就成为非递减数组。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>当出现 <code>nums[i-1] &gt; nums[i]</code> 时，有两种修改方案，我们不妨优先令  <code>nums[i-1] = nums[i]</code>  ，即把前一个数放小，但可能会出现 <code>nums[i-1]</code> 比其前面的数（如 <code>nums[i-2]</code> ）更小的情况。</p>
<p>为了探索其中的规律，我们考虑下面三种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4，2，3</span><br><span class="line">-1，4，2，3</span><br><span class="line">2，3，3，2，4</span><br></pre></td></tr></table></figure>
<ul>
<li>如果再前面的数不存在，如case1，直接修改 <code>nums[i-1]=2</code> 即可.</li>
<li>如果再前面的数存在，且小于当前数时，如case2，-1 &lt; 2，修改 <code>nums[i-1]=2 </code>即可。</li>
<li>如果再前面的数存在，但大于当前数时，如case3，3 &gt; 2，若把 <code>nums[i-1]=2</code> 会使得 <code>nums[i-2] &gt; nums[i-1]</code> ，因此只能修改 <code>nums[i]=3</code> 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size() &amp;&amp; cnt &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i<span class="number">-1</span>] &lt;= nums[i]) &#123;</span><br><span class="line">			    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (i<span class="number">-2</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i<span class="number">-2</span>] &gt; nums[i]) &#123;</span><br><span class="line">                nums[i] = nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i<span class="number">-1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="10-子数组最大的和"><a href="#10-子数组最大的和" class="headerlink" title="10. 子数组最大的和"></a>10. 子数组最大的和</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/description/">53. Maximum Subarray (Easy)</a></p>
<p><strong>【题目描述】</strong> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>重点在于连续子数组，故主要是看<strong>前面的和</strong>。若大于0，则加上，否则，从当前开始重新计算和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> preSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSum = preSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            preSum = preSum &gt; <span class="number">0</span>? preSum+nums[i] : nums[i];</span><br><span class="line">            maxSum = max(maxSum, preSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="11-分隔字符串使同种字符出现在一起（难）"><a href="#11-分隔字符串使同种字符出现在一起（难）" class="headerlink" title="11. 分隔字符串使同种字符出现在一起（难）"></a>11. 分隔字符串使同种字符出现在一起（难）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/description/">763. Partition Labels (Medium)</a></p>
<p><strong>【题目描述】</strong> </p>
<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>从第一个字母开始分析，假设第一个字母是 ‘a’，那么第一个区间一定包含最后一次出现的 ‘a’。但第一个出现的 ‘a’ 和最后一个出现的 ‘a’ 之间可能还有其他字母，而这些字母会让区间变大。</p>
<p>因此， 对于遇到的每一个字母，我们可以先找到这个字母最后一次出现的位置，再以此更新当前的最小区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 初始化各个字母最后一次出现的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            end[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            right = max(right, end[s[i] - <span class="string">&#x27;a&#x27;</span>]);    <span class="comment">// 更新当前区间右端点</span></span><br><span class="line">            <span class="keyword">if</span>(i == right) &#123;</span><br><span class="line">                res.push_back(right - left);</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="0x04-二分查找"><a href="#0x04-二分查找" class="headerlink" title="0x04 二分查找"></a>0x04 二分查找</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p>
<p><strong>【伪代码】</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; nums[m]) &#123;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>【注意】</strong></p>
<p>有两种计算中值 m 的方式：</p>
<ul>
<li>m = (l + h) / 2</li>
<li>m = l + (h - l) / 2</li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p>
<p><strong>【变式】</strong></p>
<blockquote>
<p>二分思想很简单，但细节真的是魔鬼…</p>
</blockquote>
<p>当使用二分查找的思想解决问题时，需仔细分析两点：</p>
<ul>
<li>如何确定index在左子区间还是右？</li>
<li>跳出循环的条件？应返回什么？</li>
</ul>
<h3 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/description/">69. Sqrt(x) (Easy)</a></p>
<p><strong>【题目描述】</strong> 实现 <code>int sqrt(int x)</code> 函数。计算并返回 <em>x</em> 的平方根，结果只保留整数的部分，其中 <em>x</em> 是非负整数。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，且非负整数 sqrt 必满足  ，因此可以利用二分查找，每一轮查询比较 m 和 x/m 的大小，即令 key = x/m。</p>
<ul>
<li><p>当 x 的平方根恰为整数时，有 sqrt*sqrt = x，因此当 m = x/m 时返回m即可。</p>
</li>
<li><p>当 x 的平方根为小数时，如 x=8，有 $sqrt^2 &lt; x &lt; (sqrt+1)^2$ ，可见查询的最后阶段一定是</p>
<ol>
<li>l = sqrt, h = sqrt+1, m = sqrt，此时必有 m &lt; x/m，因而 l = m+1；</li>
<li>l = sqrt+1, h = sqrt+1, m = sqrt+1，此时必有 m &gt; x/m，因而 h = m-1 = sqrt。</li>
</ol>
<p>因而返回 h。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>)  <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, h = x;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> key = x / m;</span><br><span class="line">            <span class="keyword">if</span>(key == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; m) &#123;</span><br><span class="line">                h = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/">744. Find Smallest Letter Greater Than Target (Easy)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个有序的字符数组 letters 和一个字符 target，要求在找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;c&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;a&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;k&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>当循环条件不成立时，l 总是比 r 大1，因为要找的是比target大的字母，所以取 l 。 </p>
<p>考虑两种特殊情况：</p>
<ul>
<li>如果<strong>符合条件的字母</strong>比letters中的字母都小，则最后一定是 l = 0, r = -1，所以取 l 。</li>
<li>如果<strong>符合条件的字母</strong>比letters中的字母都大，则最后一定是 l = n, r = n-1, 所以取 0。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = letters.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[m] &lt;= target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l &lt; n ? letters[l] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="3-有序数组的-Single-Element（中）"><a href="#3-有序数组的-Single-Element（中）" class="headerlink" title="3. 有序数组的 Single Element（中）"></a>3. 有序数组的 Single Element（中）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/">540. Single Element in a Sorted Array (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>假设 index 为 Single Element 在数组中的位置，显然 <strong>index 一定是偶数</strong>，且在 index 之后，数组中原来存在的成对状态将被改变。</p>
<p>如果 m 是偶数：</p>
<ul>
<li>当 m &lt; index 时，必有 <code>nums[m] == nums[m+1]</code> ；</li>
<li>当 m &gt;= index 时，必有 <code>nums[m] != nums[m+1]</code> 。</li>
</ul>
<p>可由此二分区间。<em>（第一次做的时候又是m+1又是m-1的，一堆if-else嵌套，逻辑混乱不说还做不对，难想啊啊啊）</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                m--;	<span class="comment">// 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(nums[m] == nums[m+<span class="number">1</span>]) &#123;</span><br><span class="line">                l = m + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/description/">278. First Bad Version (Easy)</a></p>
<p><strong>【题目描述】</strong> 给定一个元素 n 代表有 [1, 2, …, n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 <code>isBadVersion(int x)</code> 知道某个版本是否错误，要求找到第一个错误的版本。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。 </span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<ul>
<li>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；</li>
<li>否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。</li>
</ul>
<p>又因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(m)) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="5-旋转数组的最小数字（中）"><a href="#5-旋转数组的最小数字（中）" class="headerlink" title="5. 旋转数组的最小数字（中）"></a>5. 旋转数组的最小数字（中）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">153. Find Minimum in Rotated Sorted Array (Medium)</a></p>
<p><strong>【题目描述】</strong> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p>
<p>请找出其中最小的元素。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>整个数组是分段递增的，且左区间必定大于右区间元素。</p>
<p>因此，</p>
<ul>
<li>当 m 小于右端点时，index必定在左子区间；</li>
<li>当 m 大于右端点时，index必定在右子区间；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= nums[r]) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">34. Find First and Last Position of Element in Sorted Array</a></p>
<p><strong>【题目描述】</strong> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>


<p><strong>【题解1】</strong></p>
<p>二分查找到第一个target，即左端点，然后从左往右遍历，找到右端点。</p>
<p>左端点：第一个大于等于target的下标；</p>
<ul>
<li>若 nums[m] &lt; target，查找区间 $[m+1, r]$ </li>
<li>若 nums[m] &gt;= target，查找区间 $[l, m]$ </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m =  l + (r-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || nums[l] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; nums[r] == target) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;l, r<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【题解2 - 查左右端点】</strong></p>
<p>在排序数组中查找元素的第一个和最后一个位置。</p>
<blockquote>
<p>左端点略，重点是查找右端点的细节，绊了很久…</p>
</blockquote>
<p>右端点 ed：第一个大于target的下标。</p>
<ul>
<li>若 nums[m] &lt;= target，查找区间 $[m+1, r]$ </li>
<li>若 nums[m] &gt; target，查找区间 $[l, m]$ </li>
</ul>
<p>务必注意 n = 0, n = 1, n = 2 时的特例。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l, r, st, ed;</span><br><span class="line">        <span class="comment">// 二分查找左端点</span></span><br><span class="line">        l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m =  l + (r-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st = l;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; st &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 二分查找右端点</span></span><br><span class="line">        l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m =  l + (r-l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ed = nums[r]==target? r: r<span class="number">-1</span>;	<span class="comment">// 当没有比target更大的元素时，将返回n-1</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(st &lt;= ed &amp;&amp; ed &lt; n &amp;&amp; nums[st] == target &amp;&amp; nums[ed] == target)</span><br><span class="line">            <span class="keyword">return</span> &#123;st, ed&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="0x05-分治法"><a href="#0x05-分治法" class="headerlink" title="0x05 分治法"></a>0x05 分治法</h2><p>说是分治，其实完全可以归类为动态规划问题。</p>
<h3 id="1-给表达式加括号（难）"><a href="#1-给表达式加括号（难）" class="headerlink" title="1. 给表达式加括号（难）"></a>1. 给表达式加括号（难）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/description/">241. Different Ways to Add Parentheses (Medium)</a></p>
<p><strong>【题目描述】</strong> 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;2-1-1&quot;</span><br><span class="line">输出: [0, 2]</span><br><span class="line">解释: </span><br><span class="line">((2-1)-1) &#x3D; 0 </span><br><span class="line">(2-(1-1)) &#x3D; 2</span><br></pre></td></tr></table></figure>
<p><strong>【题解 - 带备忘录的自顶向下法】</strong></p>
<ul>
<li>区间选择：使用[left, right)的左闭右开区间。</li>
<li>区间划分：遍历字符串，根据符号来划分左右区间，直至区间内只有一个纯数字（最小子问题）。</li>
<li>区间合并：每个区间都有一个vector<int>存储所有可能的计算结果，将左右两个区间的结果分别进行对应的op操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;  <span class="comment">// 备忘录: [left, right] -&gt; result list</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; op, <span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算形如 x op y 的表达式</span></span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:   <span class="keyword">return</span> x + y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:   <span class="keyword">return</span> x - y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:   <span class="keyword">return</span> x * y;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; input, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo.find(<span class="built_in">make_pair</span>(left, right)) != memo.end()) &#123;</span><br><span class="line">            <span class="comment">// 若当前区间已经计算过，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> memo[<span class="built_in">make_pair</span>(left, right)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> op = input[i];</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span> || op == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lRes = dfs(input, left, i);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rRes = dfs(input, i+<span class="number">1</span>, right);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> x: lRes)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> y: rRes)</span><br><span class="line">                        res.push_back(calc(op, x, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当区间内只有一个数字时，将其加入res中</span></span><br><span class="line">            <span class="keyword">int</span> num = stoi(input.substr(left, right - left));</span><br><span class="line">            res.push_back(num);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[<span class="built_in">make_pair</span>(left, right)] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(input, <span class="number">0</span>, input.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="2-不同的二叉搜索树（难）"><a href="#2-不同的二叉搜索树（难）" class="headerlink" title="2. 不同的二叉搜索树（难）"></a>2. 不同的二叉搜索树（难）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/description/">95. Unique Binary Search Trees II (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释:</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为 n，如果我们枚举根节点的值为 i，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]。</p>
<ul>
<li>区间选择：使用 [st, ed] 的闭区间。</li>
<li>区间划分：从序列 1 ..n 中取出数字 i，作为当前树的树根，根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]。</li>
<li>区间合并：每个根节点都有一个vector&lt;TreeNode*&gt;存储所有可能的子树。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateSubTrees</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st &gt; ed) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = st; i &lt;= ed; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees = generateSubTrees(st, i<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees = generateSubTrees(i+<span class="number">1</span>, ed);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> lTree: leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> rTree: rightTrees) &#123;</span><br><span class="line">                    TreeNode* rootTree = <span class="keyword">new</span> TreeNode(i, lTree, rTree);</span><br><span class="line">                    allTrees.push_back(rootTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> generateSubTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="0x06-搜索"><a href="#0x06-搜索" class="headerlink" title="0x06 搜索"></a>0x06 搜索</h2><h2 id="0x07-动态规划"><a href="#0x07-动态规划" class="headerlink" title="0x07 动态规划"></a>0x07 动态规划</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>数列是一维的，可以定义一个一位数组 dp 记录最优解。进一步地，考虑到 dp[i] 只与 dp[i-1] 和 dp[i-2] 有关，因此可以只用两个变量来存储，使得空间复杂度为 $O(1)$ 。</p>
<h4 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1. 爬楼梯"></a>1. 爬楼梯</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/description/">70. Climbing Stairs (Easy)</a></p>
<p><strong>【题目描述】</strong></p>
<p>有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)  <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cur = pre2 + pre1;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-强盗抢劫"><a href="#2-强盗抢劫" class="headerlink" title="2. 强盗抢劫"></a>2. 强盗抢劫</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/description/">198. House Robber (Easy)</a></p>
<p><strong>【题目描述】</strong></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以 $dp[i] = max{dp[i-2] + nums[i], dp[i-1]}$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            cur = max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="3-强盗在环形街区抢劫"><a href="#3-强盗在环形街区抢劫" class="headerlink" title="3. 强盗在环形街区抢劫"></a>3. 强盗在环形街区抢劫</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/description/">213. House Robber II (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>同上题，这个地方所有的房屋都 <strong>围成一圈</strong> 。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>“围成一圈” 意味着不能同时抢劫第一个房屋和最后一个房屋，因此不妨将原问题拆解为 1<del>n-1 和 2</del>n 两个子问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = st; i &lt;= ed; i++) &#123;</span><br><span class="line">            cur = max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> max(rob(nums, <span class="number">0</span>, n<span class="number">-2</span>), rob(nums, <span class="number">1</span>, n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h3><p>矩阵与斐波那契数列的不同之处在于，可以有多条路径，因此必须开一个二维数组dp来记录最优解。</p>
<h4 id="1-矩阵的最小路径和"><a href="#1-矩阵的最小路径和" class="headerlink" title="1. 矩阵的最小路径和"></a>1. 矩阵的最小路径和</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/description/">64. Minimum Path Sum (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向右和向下移动。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[1,3,1],</span><br><span class="line"> [1,5,1],</span><br><span class="line"> [4,2,1]]</span><br><span class="line">输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>标准的自底向上dp解法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自底向上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-矩阵的总路径数"><a href="#2-矩阵的总路径数" class="headerlink" title="2. 矩阵的总路径数"></a>2. 矩阵的总路径数</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/description/">62. Unique Paths (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>类似斐波那契数列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[m][n];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)  dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)  dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 自底向上计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h3><h4 id="1-数组区间和"><a href="#1-数组区间和" class="headerlink" title="1. 数组区间和"></a>1. 数组区间和</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/">303. Range Sum Query - Immutable (Easy)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点。</p>
<p>实现 NumArray 类：</p>
<ul>
<li>NumArray(int[] nums) 使用数组 nums 初始化对象</li>
<li>int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）</li>
</ul>
<p><strong>【示例】</strong></p>
<p>略</p>
<p><strong>【题解】</strong></p>
<p>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">10007</span>][<span class="number">10007</span>];</span><br><span class="line"></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i][i] = nums[i];         <span class="comment">// 对角线</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            sum[<span class="number">0</span>][j] = sum[<span class="number">0</span>][j<span class="number">-1</span>] + nums[j];   <span class="comment">// 计算第一行 [0, n-1] 的和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自底向上计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                sum[i][j] = sum[i<span class="number">-1</span>][j] - nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<ul>
<li>一种更加精妙的解法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* sum;    <span class="comment">// sum[i]: sum of 0~i</span></span><br><span class="line"></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];   <span class="comment">// 计算sum</span></span><br><span class="line">            sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                sum[i] = sum[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span>? sum[j] : sum[j] - sum[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-数组中等差递增子区间的个数（难）"><a href="#2-数组中等差递增子区间的个数（难）" class="headerlink" title="2. 数组中等差递增子区间的个数（难）"></a>2. 数组中等差递增子区间的个数（难）</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/arithmetic-slices/description/">413. Arithmetic Slices (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [0, 1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">return: 6, for 3 arithmetic slices in A:</span><br><span class="line"></span><br><span class="line">[0, 1, 2],</span><br><span class="line">[1, 2, 3],</span><br><span class="line">[0, 1, 2, 3],</span><br><span class="line">[0, 1, 2, 3, 4],</span><br><span class="line">[ 1, 2, 3, 4],</span><br><span class="line">[2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>用 dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>
<p>当 A[i] - A[i-1] == A[i-1] - A[i-2] 时，</p>
<ol>
<li>在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间，dp[i-1]个；</li>
<li>同时， [A[i-2], A[i-1], A[i]] 也构成一个等差递增子区间，1个。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算以 A[i] 结尾的递增子区间个数</span></span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i<span class="number">-1</span>] == A[i<span class="number">-1</span>] - A[i<span class="number">-2</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计所有个数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h3><h4 id="1-分割整数的最大乘积"><a href="#1-分割整数的最大乘积" class="headerlink" title="1. 分割整数的最大乘积"></a>1. 分割整数的最大乘积</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/description/">343. Integer Break (Medim)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的<strong>乘积最大化</strong>。 返回你可以获得的最大乘积。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<p>由于正整数n可以拆分为n1和n2，显然包含重复子问题，因此考虑用动态规划的方法做。</p>
<p>定义 dp[i] 为整数 i 分割后的最大乘积，对于每个整数 i，可以拆分为 j 和 i - j ，确定一个 j 使得 dp[i] 最大即可。</p>
<ul>
<li>基础解：把 i 拆分为两个整数，即 dp[i] = j * (i - j)</li>
<li>递归解：取 j 的最优解，乘上整数 i - j</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] = max(dp[i], max(j * (i - j), dp[j] * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-按平方数来分割整数"><a href="#2-按平方数来分割整数" class="headerlink" title="2. 按平方数来分割整数"></a>2. 按平方数来分割整数</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/description/">279. Perfect Squares(Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>，你需要让组成和的完全平方数的个数最少。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 &#x3D; 4 + 4 + 4</span><br></pre></td></tr></table></figure>
<p><strong>【题解】</strong></p>
<ul>
<li>递归分析： $dp[i] = min(dp[j] + dp[i-j])$ </li>
<li>时间复杂度：$O(nlogn)$ </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">10007</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果i是完全平方数，则dp[i]=1</span></span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">sqrt</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(temp * temp == i) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，动规解决</span></span><br><span class="line">            dp[i] = MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                dp[i] = min(dp[i], dp[j] + dp[i - j]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【题解 - 2】</strong></p>
<p>第一种解法仍有些无脑，考虑到是按平方数来分割整数，因此在内层循环中 j 不必遍历 1~i-1，只需遍历完全平方数即可。</p>
<p>这样对每个整数 $i$ ，利用 $i - square_j$ 的最优解加上1即可，故由 $dp[i] = min(dp[i - square[j]] + 1)$ 。</p>
<p>由此，问题就只剩下<strong>如何求得所有小于等于n的完全平方数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">10007</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; square = genSquareList(n);</span><br><span class="line">        <span class="keyword">int</span> len = square.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; len &amp;&amp; i == square[k]) &#123;    <span class="comment">// 如果i是完全平方数</span></span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i] = MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(square[j] &gt;= i) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = min(dp[i], dp[i - square[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成所有小于等于n的完全平方数 */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">genSquareList</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> square = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(square &lt;= n) &#123;</span><br><span class="line">            res.push_back(square);</span><br><span class="line">            square += diff;</span><br><span class="line">            diff += <span class="number">2</span>;      <span class="comment">// 完全平方数各项的差为一个等差数列，差为2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="3-分割整数构成字母字符串"><a href="#3-分割整数构成字母字符串" class="headerlink" title="3. 分割整数构成字母字符串"></a>3. 分割整数构成字母字符串</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/description/">91. Decode Ways (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>给你一个只含数字的 非空 字符串 num ，请计算并返回 <strong>解码</strong> 方法的 总数 。</p>
<p><strong>【示例】</strong></p>
<p>例如，”111” 可以将 “1” 中的每个 “1” 映射为 “A” ，从而得到 “AAA” ，或者可以将 “11” 和 “1”（分别为 “K” 和 “A” ）映射为 “KA” 。注意，”06” 不能映射为 “F” ，因为 “6” 和 “06” 不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串开头的 0 无法指向一个有效的字符。 </span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>定义 dp[i] 为前 i 个数字所能映射的方法数，则</p>
<ul>
<li>若 s[i] = 0 ：<ul>
<li>只有当 s[i-1] = 1或2 时，才可以把 s[i-1] 和 s[i] 组合起来，此时有 dp[i] = dp[i-2]</li>
<li>其余情况均为 dp[i] = 0，且之后的都为0</li>
</ul>
</li>
<li>若 s[i] != 0 ：<ul>
<li>当 s[i-1] == 1 或 s[i-1] == 2 &amp;&amp; 1 &lt;= s[i] &lt;= 6 时， 既可以单独映射，也可以组合起来，因此有 dp[i] = dp[i-1] + dp[i-2]；</li>
<li>其余情况只能单独映射，因此 dp[i] = d[i-1]</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">107</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((s[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) || (s[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; <span class="string">&#x27;1&#x27;</span> &lt;= s[<span class="number">1</span>] &amp;&amp; s[<span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自底向上计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i<span class="number">-1</span>] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>((s[i<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) || (s[i<span class="number">-1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; <span class="string">&#x27;1&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>已知一个序列 {S1, S2,…,Sn}，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p>
<p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p>
<h4 id="1-最长递增子序列"><a href="#1-最长递增子序列" class="headerlink" title="1. 最长递增子序列"></a>1. 最长递增子序列</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/description/">300. Longest Increasing Subsequence (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>【题解1】</strong></p>
<p>我们不妨考虑末尾数字，dp[i] 表示以 num[i] 结尾的最长递增子序列的长度，则有 $dp[i] = max_{j &lt; i \ and \  num[j] &lt; num[i]}(dp[j] + 1)$ 。</p>
<p>对于一个长度为 n 的序列，最长递增子序列并不一定会以 num[n] 为结尾，因此 dp[n] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">2507</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算dp数组</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最长递增子序列</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【题解2 - 难想】</strong></p>
<p>以上解法的时间复杂度为 O(N2)，可以使用二分查找将时间复杂度降低为 O(NlogN)。</p>
<p>定义一个 tails 数组，其中 <strong>tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素</strong>。</p>
<p>对于一个元素 x，</p>
<ul>
<li>如果它大于 tails 数组所有的值，那么把它添加到 tails 后面，表示最长递增子序列长度加 1；</li>
<li>如果 tails[i-1] &lt; x &lt;= tails[i]，那么更新 tails[i] = x。</li>
</ul>
<p>例如对于数组 [4,3,6,5]，有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tails      len      num</span><br><span class="line">[]         0        4</span><br><span class="line">[4]        1        3</span><br><span class="line">[3]        1        6</span><br><span class="line">[3,6]      2        5</span><br><span class="line">[3,5]      2        null</span><br></pre></td></tr></table></figure>
<p>可以看出 tails 数组保持有序，因此在查找 Si 位于 tails 数组的位置时就可以使用二分查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tails[<span class="number">2507</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新tails数组</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = bSearch(<span class="number">0</span>, len, nums[i]);</span><br><span class="line">            tails[index] = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(index == len) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 二分查找key在tails数组中的位置 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tails[mid] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tails[mid] &gt; key) &#123;</span><br><span class="line">                h = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h4 id="2-一组整数对能够构成的最长链"><a href="#2-一组整数对能够构成的最长链" class="headerlink" title="2. 一组整数对能够构成的最长链"></a>2. 一组整数对能够构成的最长链</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/description/">646. Maximum Length of Pair Chain (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。给定一个数对集合，找出能够形成的最长数对链的长度。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2], [2,3], [3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：最长的数对链是 [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>因为给定的是集合，所以首先根据数对的第一个数升序排列所有的数对。</p>
<p>定义 $dp[i]$ 存储以 $pairs[i]$ 结尾的最长链的长度。</p>
<p>对于每个 $dp[i]$ ，其长度只与前 $i$ 项有关：</p>
<ul>
<li>当 $j &lt; i$ 且 $pairs[j][1] &lt; pairs[i][0]$ 时，扩展数对链，更新 $dp[i] = max(dp[i], dp[j] + 1)$ 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1007</span>];   <span class="comment">// dp[i]: 以pairs[i]结尾的最长链数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pairs.size();</span><br><span class="line">        sort(pairs.begin(), pairs.end(), compare);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:\t&quot;</span> &lt;&lt; pairs[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pairs[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;      </span><br><span class="line">                <span class="keyword">if</span>(pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照数对的第一个数升序排列</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="3-最长摆动子序列（难）"><a href="#3-最长摆动子序列（难）" class="headerlink" title="3. 最长摆动子序列（难）"></a>3. 最长摆动子序列（难）</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/description/">376. Wiggle Subsequence (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>如果<strong>连续数字之间的差</strong>严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。那么列出状态表达式为：</p>
<ol>
<li><p>$up[i]$ 表示以<strong>前 i 个元素</strong>中的某一个为结尾的最长的「上升摆动序列」的长度。</p>
</li>
<li><p>$down[i]$ 表示以<strong>前 i 个元素</strong>中的某一个为结尾的最长的「下降摆动序列」的长度。</p>
</li>
</ol>
<p>对于 $up[i]$，</p>
<ul>
<li>当 $nums[i] \leq nums[i-1]$ 时，我们无法选出更长的「上升摆动序列」的方案。因为对于任何以 $nums[i]$ 结尾的「上升摆动序列」，我们都可以将 $nums[i]$ 替换为 $nums[i−1]$ ，使其成为以 $nums[i - 1]$ 结尾的「上升摆动序列」。</li>
<li>当 $nums[i] &gt; nums[i-1]$ 时，以 $nums[i]$ 结尾的「上升摆动序列」长度为 $down[i-1]+1$ ，因此 $up[i] = max(up[i-1], down[i-1] + 1)$ 。</li>
</ul>
<p>对于 $down[i]$ 同理。</p>
<p>事实上，我们仅需要前一个状态来进行转移，所以只需要维护两个变量即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>详见 <a href="https://jay1zhang.github.io/2021/01/29/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E3%80%8D%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%88%86%E6%B2%BB-%E5%8A%A8%E8%A7%84-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/">《算法导论》（二）之动规问题</a></p>
<h4 id="1-最长公共子序列"><a href="#1-最长公共子序列" class="headerlink" title="1. 最长公共子序列"></a>1. 最长公共子序列</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = text1.length(), m = text2.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><h4 id="1-划分数组为和相等的两部分（难）"><a href="#1-划分数组为和相等的两部分（难）" class="headerlink" title="1. 划分数组为和相等的两部分（难）"></a>1. 划分数组为和相等的两部分（难）</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/">416. Partition Equal Subset Sum (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>本题与 0-1 背包问题有一个很大的不同，即：</p>
<ul>
<li>0-1 背包问题选取的物品的容积总量 <strong>不能超过</strong> 规定的总量；</li>
<li>本题选取的数字之和需要 <strong>恰好等于</strong> 规定的和的一半。</li>
</ul>
<p>作为「0-1 背包问题」，它的特点是：「每个数只能用一次」。解决的基本思路是：<strong>物品一个一个选，容量也一点一点增加去考虑</strong>，这一点是「动态规划」的思想，特别重要。</p>
<p><strong>状态定义</strong>：$dp[i][j]$ 表示从数组的 $[0, i]$ 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 $j$ 。</p>
<p>在定义状态之后，需要<strong>考虑边界情况</strong>。以下两种情况都属于边界情况。</p>
<ul>
<li><p>如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有 $0 \le i &lt; n$ ，都有 $dp[i][0] = true$ 。</p>
</li>
<li><p>当 $i = 0$ 时，只有一个正整数 $nums[0]$ 可以被选取，因此 $dp[0][nums[0]] = true$ 。</p>
</li>
</ul>
<p>对于一般情况，如何确定 $dp[i][j]$ 呢？</p>
<ul>
<li>如果 $j \ge nums[i]$ ，则对于当前的数字 $nums[i]$ ，既可以选取也可以不选取，两种情况只要有一个为真，则 $dp[i][j] = true$ ；<ul>
<li>如果不选取 $nums[i]$ ，则 $dp[i][j] = dp[i-1][j]$ ； </li>
<li>如果选取 $nums[i]$ ，则 $dp[i][j] = dp[i-1][j-nums[i]]$ 。</li>
</ul>
</li>
<li>如果 $j &lt; nums[i]$ ，则无法选取当前数字 $nums[i]$ ，因此有 $dp[i][j] = dp[i-1][j]$ 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 个数小于2，显然不可能分出两个非空子集</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">            sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 和为奇数，显然不可能成立</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n][target + <span class="number">1</span>];   <span class="comment">// 状态数组，行：物品索引，列：容量</span></span><br><span class="line">        <span class="comment">/* 初始化第一列为true，其余为false */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算第0行，即第1个物品</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 1~n-1 行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; j) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];    <span class="comment">// 不选nums[i]，需看0~i-1能否构成j</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i]];   <span class="comment">// 可选可不选</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>【题解 - 2】</strong></p>
<p>上述代码的空间复杂度是 $O(n×target)$ ，但是可以发现在计算 $dp$ 的过程中，每一行的 $dp$ 值都只与上一行的 $dp$ 值有关，因此只需要一个一维数组即可将空间复杂度降到 $O(target)$ 。</p>
<p>此时的转移方程为： $dp[j]=dp[j] ∣ dp[j−nums[i]]$ .</p>
<p>且需要注意的是第二层的循环我们需要<strong>从大到小计算</strong>，因为如果我们从小到大更新 $dp$ 值，那么在计算 $dp[j]$ 值的时候，**$dp[j−nums[i]]$ 已经是被更新过的状态**，不再是上一行的 $dp$ 值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 个数小于2，显然不可能分出两个非空子集</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">            sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 和为奇数，显然不可能成立</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[target + <span class="number">1</span>];   <span class="comment">// 状态数组，容量</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++)  dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算状态数组dp[]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] |= dp[j - nums[i]];   <span class="comment">// 选nums[i]，或不选</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h4 id="2-改变一组数的正负号使得它们的和为一给定数（难）"><a href="#2-改变一组数的正负号使得它们的和为一给定数（难）" class="headerlink" title="2. 改变一组数的正负号使得它们的和为一给定数（难）"></a>2. 改变一组数的正负号使得它们的和为一给定数（难）</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/description/">494. Target Sum (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p><strong>【示例】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>


<p><strong>【题解】</strong></p>
<p>同上一题，本题选取的数字应恰好为 S。区别在于，S是可以为负数的，且S的范围为 $[-sum, sum]$ 。</p>
<p>因而定义状态数组 $dp[n][2<em>sum + 1]$ ， $dp[i][j+sum]$ 为前 $i$ 个数字，组成和为 $j$ 的方法数（$-sum \le j \le sum$）。即将数组整个向右偏移一个 sum，$[0, 2</em>sum]$ 映射为 $[-sum, sum]$ 。 </p>
<p>在定义状态之后，需要<strong>考虑边界情况</strong>：</p>
<ul>
<li>和为0的情况， $dp[i][sum] = 0$ ；</li>
<li>当 $i = 0$ 时，由单独一个 $nums[0]$ 组成的 $S$ 只有两种情况，$nums[0]$ 或 $-nums[0]$ ，故 $dp[0][sum + nums[0]] = 1$ 且 $dp[0][sum - nums[0]] = 1$ 。</li>
</ul>
<p>对于一般情况，如何确定 $dp[i][j]$ 呢？</p>
<ul>
<li>如果 $nums[i]$ 取正号：<ul>
<li>当 $j-sum \ge nums[i]$ 时，有 $dp[i][j] = dp[i-1][j - sum - nums[i]]$ ；</li>
<li>否则，显然不可能，故为0。</li>
</ul>
</li>
<li>如果 $nums[i]$ 取负号：<ul>
<li>当 $j + nums[i] \le sum$ 时， $dp[i][j] = dp[i-1][j + nums[i]]$ ；</li>
<li>当 $j + nums[i] &gt; S$ 时，显然不可能，故为0</li>
</ul>
</li>
</ul>
<p>所以 $dp[i][j]$ 应取上述两种情况之和。</p>
<h1 id="cnm，我输了，行了吧。"><a href="#cnm，我输了，行了吧。" class="headerlink" title="cnm，我输了，行了吧。"></a>cnm，我输了，行了吧。</h1><h4 id="3-01-字符构成最多的字符串"><a href="#3-01-字符构成最多的字符串" class="headerlink" title="3. 01 字符构成最多的字符串"></a>3. 01 字符构成最多的字符串</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ones-and-zeroes/description/">474. Ones and Zeroes (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p><strong>【示例】</strong></p>
<p><strong>【题解】</strong></p>
<h4 id="4-找零钱的最少硬币数"><a href="#4-找零钱的最少硬币数" class="headerlink" title="4. 找零钱的最少硬币数"></a>4. 找零钱的最少硬币数</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/description/">322. Coin Change (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p><strong>【示例】</strong></p>
<p><strong>【题解】</strong></p>
<h4 id="5-找零钱的硬币数组合"><a href="#5-找零钱的硬币数组合" class="headerlink" title="5. 找零钱的硬币数组合"></a>5. 找零钱的硬币数组合</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/description/">518. Coin Change 2 (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p><strong>【示例】</strong></p>
<p><strong>【题解】</strong></p>
<h4 id="6-字符串按单词列表分割"><a href="#6-字符串按单词列表分割" class="headerlink" title="6. 字符串按单词列表分割"></a>6. 字符串按单词列表分割</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/description/">139. Word Break (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p><strong>【示例】</strong></p>
<p><strong>【题解】</strong></p>
<h4 id="7-组合总和"><a href="#7-组合总和" class="headerlink" title="7. 组合总和"></a>7. 组合总和</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iv/description/">377. Combination Sum IV (Medium)</a></p>
<p><strong>【题目描述】</strong></p>
<p><strong>【示例】</strong></p>
<p><strong>【题解】</strong></p>
<h3 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h3><h3 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h3><h2 id="0x08-数学"><a href="#0x08-数学" class="headerlink" title="0x08 数学"></a>0x08 数学</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jay1zhang.github.io/2021/01/22/Coding/Algorithm/%E3%80%8CLeetCode%E9%A2%98%E8%A7%A3%E3%80%8D%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">http://jay1zhang.github.io/2021/01/22/Coding/Algorithm/%E3%80%8CLeetCode%E9%A2%98%E8%A7%A3%E3%80%8D%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="http://jayyy1.gitee.io/images/pictures/cartoons/033.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/23/Coding/Algorithm/%E3%80%8C%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E3%80%8D%E3%80%8A%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/035.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">「算法思想」《编程珠玑》学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/20/Coding/Linux/%E3%80%8CShell%E3%80%8DLinux%20Commander/"><img class="next-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/023.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">「Shell」Linux Commander</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/12/31/Coding/LeetCode/「算法」03-贪心思想/" title="「算法」03-贪心思想"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/017.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」03-贪心思想</div></div></a></div><div><a href="/2021/01/23/Coding/Algorithm/「LeetCode题解」数据结构相关/" title="「LeetCode题解」数据结构相关"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/036.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">「LeetCode题解」数据结构相关</div></div></a></div><div><a href="/2021/01/29/Coding/Algorithm/「算法思想」《算法导论》（四）之图算法-NP问题/" title="「算法思想」《算法导论》（四）之图算法-NP问题"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/017.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">「算法思想」《算法导论》（四）之图算法-NP问题</div></div></a></div><div><a href="/2021/01/23/Coding/Algorithm/「算法思想」《编程珠玑》学习笔记/" title="「算法思想」《编程珠玑》学习笔记"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/035.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">「算法思想」《编程珠玑》学习笔记</div></div></a></div><div><a href="/2020/12/31/Coding/LeetCode/「算法」01-双指针/" title="「算法」01-双指针"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/035.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」01-双指针</div></div></a></div><div><a href="/2020/12/31/Coding/LeetCode/「算法」02-排序/" title="「算法」02-排序"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「算法」02-排序</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">0x01 双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-Two-Sum"><span class="toc-text">1. 有序数组的 Two Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="toc-text">2. 两数平方和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6"><span class="toc-text">3. 反转字符串中的元音字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4. 回文字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">5. 归并两个有序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF"><span class="toc-text">6. 判断链表是否存在环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">7. 最长子序列（中）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E6%8E%92%E5%BA%8F"><span class="toc-text">0x02 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%AB%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">1. 快排序与堆排序（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">2. 桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E5%A4%9A%E7%9A%84-k-%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">2.1 出现频率最多的 k 个元素（中）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%8C%89%E7%85%A7%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">2.2 按照字符出现次数对字符串排序（中）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E5%BF%AB%E6%8E%92%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">3. 荷兰国旗问题 - 三向切分快排（中）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">0x03 贪心思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E9%85%8D%E9%A5%BC%E5%B9%B2"><span class="toc-text">1. 分配饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%8C%BA%E9%97%B4%E4%B8%AA%E6%95%B0%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">2. 不重叠的区间个数（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8A%95%E9%A3%9E%E9%95%96%E5%88%BA%E7%A0%B4%E6%B0%94%E7%90%83%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">3. 投飞镖刺破气球（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E5%92%8C%E5%BA%8F%E5%8F%B7%E9%87%8D%E7%BB%84%E9%98%9F%E5%88%97%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">4. 根据身高和序号重组队列（难）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A"><span class="toc-text">5. 买卖股票的最大收益</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A-%E2%80%96"><span class="toc-text">6. 买卖股票的最大收益 ‖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%A7%8D%E6%A4%8D%E8%8A%B1%E6%9C%B5"><span class="toc-text">7.  种植花朵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">8. 判断是否为子序列（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E6%88%90%E4%B8%BA%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E7%BB%84"><span class="toc-text">9. 修改一个数成为非递减数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%9A%84%E5%92%8C"><span class="toc-text">10. 子数组最大的和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%88%86%E9%9A%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E5%90%8C%E7%A7%8D%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">11. 分隔字符串使同种字符出现在一起（难）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">0x04 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B1%82%E5%BC%80%E6%96%B9"><span class="toc-text">1. 求开方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-text">2. 大于给定元素的最小元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-Single-Element%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">3. 有序数组的 Single Element（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-text">4. 第一个错误的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">5. 旋转数组的最小数字（中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4"><span class="toc-text">6. 查找区间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-text">0x05 分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8A%A0%E6%8B%AC%E5%8F%B7%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">1. 给表达式加括号（难）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">2. 不同的二叉搜索树（难）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-%E6%90%9C%E7%B4%A2"><span class="toc-text">0x06 搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">0x07 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">1. 爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%BA%E7%9B%97%E6%8A%A2%E5%8A%AB"><span class="toc-text">2. 强盗抢劫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%BA%E7%9B%97%E5%9C%A8%E7%8E%AF%E5%BD%A2%E8%A1%97%E5%8C%BA%E6%8A%A2%E5%8A%AB"><span class="toc-text">3. 强盗在环形街区抢劫</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84"><span class="toc-text">矩阵路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">1. 矩阵的最小路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%80%BB%E8%B7%AF%E5%BE%84%E6%95%B0"><span class="toc-text">2. 矩阵的总路径数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4"><span class="toc-text">数组区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-text">1. 数组区间和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AD%89%E5%B7%AE%E9%80%92%E5%A2%9E%E5%AD%90%E5%8C%BA%E9%97%B4%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">2. 数组中等差递增子区间的个数（难）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0"><span class="toc-text">分割整数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="toc-text">1. 分割整数的最大乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8C%89%E5%B9%B3%E6%96%B9%E6%95%B0%E6%9D%A5%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0"><span class="toc-text">2. 按平方数来分割整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E5%89%B2%E6%95%B4%E6%95%B0%E6%9E%84%E6%88%90%E5%AD%97%E6%AF%8D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3. 分割整数构成字母字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">1. 最长递增子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%80%E7%BB%84%E6%95%B4%E6%95%B0%E5%AF%B9%E8%83%BD%E5%A4%9F%E6%9E%84%E6%88%90%E7%9A%84%E6%9C%80%E9%95%BF%E9%93%BE"><span class="toc-text">2. 一组整数对能够构成的最长链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%80%E9%95%BF%E6%91%86%E5%8A%A8%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">3. 最长摆动子序列（难）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">1. 最长公共子序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85"><span class="toc-text">0-1 背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">1. 划分数组为和相等的两部分（难）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%94%B9%E5%8F%98%E4%B8%80%E7%BB%84%E6%95%B0%E7%9A%84%E6%AD%A3%E8%B4%9F%E5%8F%B7%E4%BD%BF%E5%BE%97%E5%AE%83%E4%BB%AC%E7%9A%84%E5%92%8C%E4%B8%BA%E4%B8%80%E7%BB%99%E5%AE%9A%E6%95%B0%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="toc-text">2. 改变一组数的正负号使得它们的和为一给定数（难）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cnm%EF%BC%8C%E6%88%91%E8%BE%93%E4%BA%86%EF%BC%8C%E8%A1%8C%E4%BA%86%E5%90%A7%E3%80%82"><span class="toc-text">cnm，我输了，行了吧。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-01-%E5%AD%97%E7%AC%A6%E6%9E%84%E6%88%90%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3. 01 字符构成最多的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%89%BE%E9%9B%B6%E9%92%B1%E7%9A%84%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E6%95%B0"><span class="toc-text">4. 找零钱的最少硬币数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%BE%E9%9B%B6%E9%92%B1%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%BB%84%E5%90%88"><span class="toc-text">5. 找零钱的硬币数组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E5%8D%95%E8%AF%8D%E5%88%97%E8%A1%A8%E5%88%86%E5%89%B2"><span class="toc-text">6. 字符串按单词列表分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">7. 组合总和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93"><span class="toc-text">股票交易</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91"><span class="toc-text">字符串编辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-%E6%95%B0%E5%AD%A6"><span class="toc-text">0x08 数学</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/012.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
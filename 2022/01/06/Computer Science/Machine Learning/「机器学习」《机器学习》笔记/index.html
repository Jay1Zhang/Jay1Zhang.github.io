<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「机器学习」《机器学习》笔记 | J1z's Blog</title><meta name="keywords" content="Machine Learning"><meta name="author" content="Jay"><meta name="copyright" content="Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="本系列Blog是基于周志华老师的《机器学习》一书的学习笔记。 第1章 绪论机器学习（Machine Learning）致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，“经验”通常以“数据”形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中学得“模型”（model）的算法，即“学习算法”（learning algorithm）。  一般地，我们用“模型”指">
<meta property="og:type" content="article">
<meta property="og:title" content="「机器学习」《机器学习》笔记">
<meta property="og:url" content="http://jay1zhang.github.io/2022/01/06/Computer%20Science/Machine%20Learning/%E3%80%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8D%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="J1z&#39;s Blog">
<meta property="og:description" content="本系列Blog是基于周志华老师的《机器学习》一书的学习笔记。 第1章 绪论机器学习（Machine Learning）致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，“经验”通常以“数据”形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中学得“模型”（model）的算法，即“学习算法”（learning algorithm）。  一般地，我们用“模型”指">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/039.jpg">
<meta property="article:published_time" content="2022-01-06T05:33:33.000Z">
<meta property="article:modified_time" content="2022-01-06T05:48:57.247Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="Machine Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/039.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jay1zhang.github.io/2022/01/06/Computer%20Science/Machine%20Learning/%E3%80%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8D%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKEK6XV2V5","apiKey":"e093fbb9f29fdf5c7ddd56ec43e9ae05","indexName":"Jay","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-06 13:48:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">57</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/039.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1z's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「机器学习」《机器学习》笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-01-06T05:33:33.000Z" title="Created 2022-01-06 13:33:33">2022-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-01-06T05:48:57.247Z" title="Updated 2022-01-06 13:48:57">2022-01-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Science/">Computer Science</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Science/Machine-Learning/">Machine Learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">33.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>120min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本系列Blog是基于周志华老师的《机器学习》一书的学习笔记。</p>
<h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><p>机器学习（Machine Learning）致力于研究如何通过<strong>计算</strong>的手段，利用<strong>经验</strong>来改善系统自身的性能。在计算机系统中，“经验”通常以“数据”形式存在，因此，机器学习所研究的主要内容，是关于在计算机上<strong>从数据中学得“模型”（model）的算法，即“学习算法”（learning algorithm）</strong>。</p>
<blockquote>
<p>一般地，我们用“模型”指从数据中学得的全局性结果（例如一棵决策树），而用“模式”指局部性结构（例如一条规则）。</p>
</blockquote>
<h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1 基本术语"></a>1.1 基本术语</h3><h4 id="数据样本"><a href="#数据样本" class="headerlink" title="数据样本"></a>数据样本</h4><p>要进行机器学习，先要有数据。</p>
<p>假定我们收集了一批关于西瓜的数据，例如：（色泽=青绿；根蒂=蜷缩；敲声=浊响），（色泽=乌黑；根蒂= 稍蜷；敲声=沉闷），（色泽=浅白；根蒂=硬挺；敲声=清脆），……</p>
<p>每对括号内是一条记录，这组记录的集合称为一个”数据集”（data set），其中：</p>
<ul>
<li><p>每条记录是关于一个事件或对象（这里是一个西瓜）的描述，称为一个**”示例”（instance）或”样本”（sample）**；</p>
</li>
<li><p>反映事件或对象在某方面的表现或性质的事项，例如”色泽””根蒂””敲声”，称为**”属性”（attribute）或”特征”（feature）**;</p>
</li>
<li><p>属性上的取值，例如”青绿””乌黑”，称为**”属性值”（attribute value）**；</p>
</li>
<li><p>属性张成的空间称为”属性空间”（attribute space）、**”样本空间”（sample space）或”输入空间”（input space）**。</p>
<p>例如我们把”色泽””根蒂” “敲声”作为三个坐标轴，则它们张成一个用于描述西瓜的三维空间，每个西瓜都可在这个空间中找到自己的坐标位置。</p>
</li>
<li><p>由于空间中的每个点对应一个坐标向量，因此我们也把一个示例称为一个**”特征向量”feature vector）**。</p>
</li>
</ul>
<p>一般地，令 $D = {x_1, x_2, \dots, x_m}$ 表示包含 $m$ 个样本的数据集，每个样本由 $d$ 个属性描述（例如上面的西瓜数据使用了3个属性），则每个样本 $x_i = (x_{i1}; x_{i2}; \dots; x_{id})$ 是 $d$ 维样本空间 $\chi$ 中的一个向量，其中 $x_{ij}$ 表示 $x_i$ 在第 $j$ 个属性上的取值。</p>
<h4 id="数据标签"><a href="#数据标签" class="headerlink" title="数据标签"></a>数据标签</h4><p>如果希望学得一个能帮助我们判断没剖开的西瓜是不是“好瓜”的模型，我们还需获得训练样本的“结果”信息，例如“（（色泽=青绿；根蒂=蜷缩；敲声=浊响），好瓜）”。</p>
<ul>
<li>这里关于示例结果的信息，例如“好瓜”，称为<strong>“标记”（label）</strong>；</li>
<li>拥有了标记信息的示例，则称为<strong>“样例”（example）</strong>。</li>
</ul>
<p>一般地，用 $(x_i, y_i)$ 表示第 $i$ 个样例，其中 $y_i \in \gamma$ 是示例 $x_i$ 的标记，$\gamma$ 是所有标记的集合，亦称<strong>“标记空间”（label space）或“输出空间”（output space）</strong>。</p>
<h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><p>从数据中学得模型的过程称为”学习”（learning）或**”训练”（training）**，这个过程通过执行某个学习算法来完成。</p>
<ul>
<li>训练过程中使用的数据称为”训练数据”（training data），其中每个样本称为一个”训练样本”（training sample），训练样本组成的集合称为**”训练集”（training set）**。</li>
<li>学得模型对应了关于数据的某种潜在的规律，因此亦称**”假设”（hypothesis）<strong>，这种潜在规律自身，则称为</strong>“真相”（ground-truth）**；</li>
<li>学习过程就是为了找出或逼近ground-truth，学得的模型可以看作学习算法在给定数据和参数空间上的实例化。</li>
</ul>
<h4 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h4><p>学得模型后，使用其进行预测的过程称为<strong>“测试”（testing）</strong>，被预测的样本称为<strong>“测试样本”（testing sample）</strong>。例如在学得 $f$ 后，对测试例 $x$ ，可得到其预测标记 $y = f(x)$ 。</p>
<ul>
<li><p>若我们欲预测的是离散值，例如“好瓜”“坏瓜”，此类学习任务称为 <strong>“分类”（lassification）</strong>；</p>
<p>对只涉及两个类别的“二分类”（binary classification）任务，通常称其中一个类为“正类”（positive class），另一个类为“反类”（negative class）；涉及多个类别时，则称为“多分类”（multi-class classification）任务。</p>
</li>
<li><p>若欲预测的是连续值，例如西瓜成熟度0.95、0.37，此类学习任务称为<strong>“回归”（regression）</strong>。</p>
</li>
</ul>
<p>一般地，预测任务是希望通过对训练集 ${ (x_1, y_1), (x_2, y_2), \dots, (x_m, y_m) }$ 进行学习，建立一个从输入空间 $\chi$ 到输出空间 $\gamma$ 的映射 $f: \chi \rightarrow \gamma $ 。</p>
<ul>
<li>对二分类任务，通常令 $\gamma = {-1, +1}$ 或 ${0, 1}$ ；</li>
<li>对多分类任务，$|\gamma| &gt; 2$ ；</li>
<li>对于回归任务，$\gamma = \mathbb{R}$ 。</li>
</ul>
<p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类：<strong>“监督学习”（supervised learning）</strong>和<strong>“无监督学习”（unsupervised learning）</strong>，分类和回归是前者的代表，而聚类则是后者的代表。</p>
<ul>
<li>比如我们还可以对西瓜做<strong>“聚类”（clustering）</strong>，即将训练集中的西瓜分成若干组，每组称为一个<strong>“簇”（cluster）</strong>；这些自动形成的簇可能对应一些潜在的概念划分，例如“浅色瓜”“深色瓜”，甚至“本地瓜”“外地瓜”。这样的学习过程有助于我们了解数据内在的规律，能为更深入地分析数据建立基础。</li>
</ul>
<h4 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h4><p>需注意的是，机器学习的目标是使学得的模型能很好地适用于“新样本”，而不是仅仅在训练样本上工作得很好，学得模型适用于新样本的能力，称为<strong>“泛化”（generalization）能力</strong>。具有强泛化能力的模型能很好地适用于整个样本空间，于是，<em>尽管训练集通常只是<strong>样本空间的一个很小的采样</strong>，我们仍希望它能很好地<strong>反映出样本空间的特性</strong></em>。</p>
<ul>
<li>通常我们<strong>假设样本空间中全体样本服从一个未知“分布”（distribution）$\mathbb{D}$，我们获得的每个样本都是独立地从这个分布上采样获得的，即“独立同分布”（independent and identicallydistributed，简称i.i.d.）</strong>。</li>
</ul>
<p>一般而言，训练样本越多，我们得到的关于 $\mathbb{D}$ 的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型。</p>
<h3 id="1-2-归纳学习"><a href="#1-2-归纳学习" class="headerlink" title="1.2 归纳学习"></a>1.2 归纳学习</h3><p>归纳（induction）与演绎（deduction）是科学推理的两大基本手段。</p>
<ul>
<li>前者是从特殊倒一般的“泛化”（generalization）过程，即从具体的事实归纳出一般性规律；</li>
<li>后者是从一般到特殊的“特化”（specialization）过程，即从基础原理推演出具体状况。</li>
</ul>
<p>例如，在数学公理系统中，基于一组公理和推理规则推导出与之相洽的定力，这是演绎；而“从样例中学习”显然是一个归纳的过程，因此亦成为“归纳学习”（inductive learning）。</p>
<h4 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h4><p>我们可以<strong>把学习过程看作一个在所有假设（hypothesis）组成的空间中进行搜索的过程</strong>，搜索目标是找到与训练集“匹配”（fit）的假设，即能够将训练集中的瓜进行正确判断的假设。</p>
<p>需注意的是，现实问题中我们常面临很大的假设空间，但<strong>学习过程是基于有限样本训练集进行的</strong>，因此，<em>可能有多个假设与训练集一致</em>，即存在着一个与训练集一致的“假设集合”，我们称之为<strong>“版本空间”（version space）</strong>。</p>
<h4 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h4><p>机器学习算法在学习过程中对某种类型假设的偏好，称为<strong>“归纳偏好”（inductive bias）</strong>。</p>
<blockquote>
<p>任何一个有效的机器学习算法必有其归纳偏好，否则它将被假设空间中看似在训练集上“等效”的假设所迷惑，而无法产生确定的学习结果。</p>
<p>可以想象，如果没有偏好，我们的西瓜学习算法产生的模型每次在进行预测时随机抽选训练集上的等效假设，那么对这个新瓜“（色泽=青绿；根蒂=蜷缩；敲声=沉闷）”，学得模型时而告诉我们它是好的、时而告诉我们它是不好的，这样的学习结果显然没有意义。</p>
</blockquote>
<p>归纳偏好的作用在下面这个回归学习图示中可能更为直观。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211005172824979.png" alt="image-20211005172824979" style="zoom:80%;" />

<p>这里的每个训练样本是图中的一个点 $(x，y)$ ，要学得一个与训练集一致的模型，相当于找到一条穿过所有训练样本点的曲线。显然，<strong>对有限个样本点组成的训练集，存在着很多条曲线与其一致</strong>。</p>
<ul>
<li>我们的学习算法必须有某种偏好，才能产出它认为“正确”的模型。</li>
</ul>
<p>归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行<strong>启发式选择</strong>。那么，有没有一般性的原则来引导算法确立“正确的”偏好呢？<strong>“奥卡姆剃刀”（Occam’s razor）</strong>是一种常用的、自然科学研究中最基本的原则，即<strong>“若有多个假设与观察一致，则选最简单的那个”</strong>。</p>
<ul>
<li>如果采用这个原则，并且假设我们认为“更平滑”意味着“更简单”（例如曲线A更易于描述，其方程式是 $y=-x^2+6x+1$，而曲线B则要复杂得多），则在上图1.3中我们会自然地偏好“平滑”的曲线A。</li>
</ul>
<h4 id="没有免费的午餐"><a href="#没有免费的午餐" class="headerlink" title="没有免费的午餐"></a>没有免费的午餐</h4><p>让我们再回头看看图1.3。假设学习算法 $£_a$ 基于某种归纳偏好产生了对应于曲线A的模型，学习算法 $£_b$ 基于另一种归纳偏好产生了对应于曲线B的模型。</p>
<ul>
<li>基于前面讨论的平滑曲线的某种“描述简单性”，我们满怀信心地期待算法 $£_a$ 比 $£_b$ 更好。确实，图1.4（a）显示出，与B相比，A的泛化能力更强。</li>
<li>但是，且慢！虽然我们希望并相信 $£_a$ 比 $£_b$ 更好，但会不会出现图1.4(b)的情况：与A相比，B与训练集外的样本更一致？</li>
<li>很遗憾，这种情况完全可能出现。换言之，对于一个学习算法 $£_a$，若它在某些问题上比学习算法 $£_b$ 好，则必然存在另一些问题，在那里比 $£_a$ 好。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211230152538777.png" alt="image-20211230152538777" style="zoom:50%;" />



<p>有趣的是，这个结论对任何算法均成立：</p>
<p>$$\sum_f E_{ote}(£_a|X,f) = \sum_f E_{ote}(£_b|X,f)$$</p>
<p>也就是说，无论学习算法 $£_a$ 多聪明、学习算法 $£_b$ 多笨拙，它们的期望性能是相同的！</p>
<ul>
<li>这就是<strong>“没有免费的午餐”定理（NoFree Lunch Theorem，简称NFL定理）</strong>【Wolpert，1996；Wolpert and Macready，1995】</li>
</ul>
<p>但我们需注意到，NFL定理有一个重要前提：所有“问题”出现的机会相同、或所有问题同等重要。但实际情形并不是这样。很多时候，我们只关注自己正在试图解决的问题（例如某个具体应用任务），希望为它找到一个解决方案，至于这个解决方案在别的问题、甚至在相似的问题上是否为好方案，我们并不关心。</p>
<ul>
<li>所以，NFL定理最重要的寓意，是让我们清楚地认识到，脱离具体问题，空泛地谈论“什么学习算法更好”毫无意义，因为<strong>若考虑所有潜在的问题，则所有学习算法都一样好</strong>。</li>
<li>要谈论算法的相对优劣，必须要针对具体的学习问题；在某些问题上表现好的学习算法，在另一些问题上却可能不尽如人意，而学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用。</li>
</ul>
<h3 id="1-3-思考与归纳"><a href="#1-3-思考与归纳" class="headerlink" title="1.3 思考与归纳"></a>1.3 思考与归纳</h3><p>注意下面这句话：</p>
<blockquote>
<p>通常我们<strong>假设样本空间中全体样本服从一个未知“分布”（distribution）$\mathbb{D}$，我们获得的每个样本都是独立地从这个分布上采样获得的，即“独立同分布”（independent and identicallydistributed，简称i.i.d.）</strong>。</p>
</blockquote>
<p>以及，注意对<strong>归纳偏好</strong>的理解。</p>
<p>另外，深刻理解NFL定理的意义。</p>
<h2 id="第2章-模型评估与选择"><a href="#第2章-模型评估与选择" class="headerlink" title="第2章 模型评估与选择"></a>第2章 模型评估与选择</h2><p>暂略</p>
<h2 id="第3章-线性模型"><a href="#第3章-线性模型" class="headerlink" title="第3章 线性模型"></a>第3章 线性模型</h2><h3 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h3><p>给定由 $d$ 个属性描述的示例 $\mathbf{x} = (x_1;x_2;\dots;x_d)$ ，其中 $x_i$ 是 $\mathbf{x}$ 在第 $i$ 个属性上的取值，<strong>线性模型（linear model）</strong>试图学得一个通过属性的线性组合来进行预测的函数，即</p>
<p>$$\begin{align} f(\mathbf{x}) = w_1x_1 + w_2x_2 + \dots + w_dx_d + b \tag{3.1} \end{align}$$</p>
<p>一般向量形式写成</p>
<p>$$\begin{align} f(\mathbf{x}) = \mathbf{w^T} \mathbf{x} + b \tag{3.2} \end{align}$$</p>
<p>其中 $\mathbf{w} = (w_1;w_2;\dots;w_d)$ 。</p>
<p>线性模型形式简单、易于建模，但却蕴涵着机器学习中一些重要的基本思想。</p>
<ul>
<li><p>许多功能更为强大的<strong>非线性模型（nonlinear model）可在线性模型的基础上通过引入层级结构或高维映射而得</strong>。</p>
</li>
<li><p>此外，由于 $\mathbf{w}$ 直观表达了各属性在预测中的重要性，因此线性模型有很好的<strong>可解释性（comprehensibility）</strong>。</p>
<p>例如若在西瓜问题中学得 “$f_{好瓜}(a)=0.2 \cdot 色泽 + 0.5 \cdot 工根蒂 + 0.3 \cdot 敲声 + 1$”，则意味着可通过综合考虑色泽、根蒂和敲声来判断瓜好不好，其中根蒂最要紧，而敲声比色泽更重要。</p>
</li>
</ul>
<p>本章介绍几种经典的线性模型，我们先从回归任务开始，然后讨论二分类和多分类任务。</p>
<h3 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h3><p>给定数据集 $D = {(\mathbf{x_1}, y_1), (\mathbf{x}_2, y_2), \dots, (\mathbf{x_m}, y_m) }$ ，“线性回归”（linear regression）试图学得一个线性模型以尽可能准确地预测实值输出标记。</p>
<p>我们先考虑一种最简单的情形：输入属性的数目只有一个，即 $d=1$ 。</p>
<ul>
<li><p>对离散属性，若属性值间存在“序”（order）关系，可<strong>通过连续化将其转化为连续值</strong>。</p>
<p>例如二值属性“身高”的取值“高”“矮”可转化为{1.0，0.0}，三值属性“高度”的取值“高”“中”“低”可转化为{1.0，0.5，0.0}；</p>
</li>
<li><p>若属性值间不存在序关系，假定有k个属性值，则<strong>通常转化为k维向量</strong>。</p>
<p>例如属性“瓜类”的取值“西瓜”“南瓜”“黄瓜”可转化为（0，0，1），（0，1，0），（1，0，0）。</p>
<blockquote>
<p>若将无序属性连续化，则会不恰当地引入序关系，<strong>对后续处理如距离计算等造成误导</strong>，参见9.3节。</p>
</blockquote>
</li>
</ul>
<p>线性回归试图学得</p>
<p>$$\begin{align} f(x_i) = wx_i + b \mbox{ ，使得 } f(x_i) \cong y_i \tag{3.3} \end{align}$$ </p>
<p>那如何确定 $w$ 和 $b$ 呢？</p>
<ul>
<li>显然，关键在于<strong>如何衡量 $f(x)$ 与 $y$ 之间的差别</strong>。</li>
</ul>
<p>前面介绍过，均方误差是回归任务中最常用的性能度量，因此我们的<strong>目标为最小化均方误差</strong>，即：</p>
<p>$$\begin{align} (w*, b*) &amp;= \underset{(w, b)}{\arg\min} \sum_{i=1}^m (f(x_i) - y_i)^2 \ &amp;= \underset{(w, b)}{\arg\min} \sum_{i=1}^m (y_i - wx_i - b)^2 \tag{3.4} \end{align} $$</p>
<p>基于均方误差最小化来进行模型求解的方法称为<strong>“最小二乘法”（least square method）</strong>。</p>
<h4 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h4><p>在线性回归中，最小二乘法就是**<em>试图找到一条直线，使所有样本到直线上的欧氏距离之和最小**</em>。</p>
<p><img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211017153205028.png" alt="image-20211017153205028"></p>
<center><b>图3.0 </b> 最小二乘法示意图</center>

<p>求解 $w$ 和 $b$ 使 $E_{(w, b)} = \sum_{i=1}^m (y_i - wx_i - b)^2$ 最小化的过程， 称为线性回归模型的最小二乘“参数估计”（parameter estimation）。</p>
<blockquote>
<p>这里 $E_{(w,b)}$ 是关于 $w$ 和 $b$ 的<strong>凸函数</strong>，当它关于 $w$ 和 $b$ 的导数均为零时，得到 $w$ 和 $b$ 的最优解。</p>
</blockquote>
<p>我们可将 $E_{(w, b)} $ 分别对 $w$ 和 $b$ 求导，得到</p>
<p>$$\begin{align} \frac{\partial E_{(w,b)}}{\partial w} &amp;= 2\left(w\sum_{i=1}^mx_i^2 - \sum_{i=1}^m(y_i-b)x_i \right) \tag{3.5} \ \frac{\partial E_{(w,b)}}{\partial b} &amp;= 2\left(mb - \sum_{i=1}^m(y_i - wx_i)\right) \tag{3.6} \end{align} $$</p>
<p>然后令式 $(3.5)$ 和 $(3.6)$ 为零可得到 $w$ 和 $b$ 最优解的闭式（closed-form）解</p>
<p>$$\begin{align} w &amp;= \frac{\sum_{i=1}^m y_i(x_i - \bar{x})}{\sum_{i=1}^m x_i^2 - \frac{1}{m}(\sum_{i=1}^m x_i)^2} \tag{3.7} \ b &amp;= \frac{1}{m} \sum_{i=1}^m (y_i - wx_i) \tag{3.8} \end{align} $$</p>
<p>其中 $\bar{x} = \frac{1}{m} \sum_{i=1}^m x_i$ 为 $x$ 的均值。</p>
<h4 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h4><p>更一般的情形是每个样本由 $d$ 个属性描述，这称为<strong>“多元线性回归”（multivariate linear regression）</strong>或“多变量线性回归”。</p>
<p>类似的，可利用最小二乘法来对 $w$ 和 $b$ 进行估计。</p>
<ul>
<li><p>为便于讨论，我们把 $w$ 和 $b$ 记为向量形式 $\mathbf{\hat{w}} = (\mathbf{w};b)$ </p>
</li>
<li><p>相应的，把数据集 $D$ 表示为一个 $m \times (d + 1)$ 大小的矩阵 $\mathbf{X}$ ，其中每行对应于一个示例，该行前 $d$ 个元素对应于示例的 $d$ 个属性值，最后一个元素恒置为1，即</p>
<p>$$\mathbf{X} = \left( \begin{matrix}<br>x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \<br>x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d} &amp; 1 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md} &amp; 1 \                   </p>
<pre><code>                  \end&#123;matrix&#125; \right) = \left( \begin&#123;matrix&#125; </code></pre>
<p>\mathbf{x_1^T} &amp; 1 \<br>\mathbf{x_2^T} &amp; 1 \<br>\vdots &amp; \vdots\<br>\mathbf{x_m^T} &amp; 1 \                   </p>
<pre><code>                  \end&#123;matrix&#125; \right)$$</code></pre>
</li>
<li><p>再把标记也写成向量形式 $\mathbf{y} = (y_1;y_2;\dots;y_m)$ </p>
</li>
</ul>
<p>则类似于式 $(3.4)$ ，有</p>
<p>$$\begin{align} \mathbf{\hat{w}^*} &amp;= \underset{\hat{w}}{\arg\min} \mathbf{(y - X\hat{w})^T (y - X\hat{w})} \tag{3.9} \end{align}$$</p>
<p>令 $E_{\hat{w}} = \mathbf{(y - X\hat{w})^T (y - X\hat{w})} $ ，对 $\hat{w}$ 求导得到</p>
<p>$$\begin{align} \frac{\partial E_{\hat{w}}}{\partial \hat{w}} &amp;= 2 \ \mathbf{X^T(X\hat{w}-y)} \tag{3.10} \end{align}$$</p>
<p>令上式为零可得 $\hat{w}$ 最优解的闭式解，但由于涉及矩阵逆的计算，比单变量情形要复杂一些，这里我们做一个简单的讨论。</p>
<p>当 $\mathbf{X^T} \mathbf{X}$ 为满秩矩阵（full-rank matrix）或正定矩阵（positive definite ma-trix）时，令式（3.10）为零可得</p>
<p>$$\begin{align} \hat{w}^* &amp;= \mathbf{(X^T X)^{-1} X^T y} \tag{3.11} \end{align}$$</p>
<p>令 $\mathbf{\hat{x}} = (\mathbf{x_i, 1})$ ，则最终学得的多元线性回归模型为</p>
<p>$$\begin{align} f(\mathbf{\hat{x}_i}) &amp;= \mathbf{\hat{x}_i^T (X^T X)^{-1} X^T y} \tag{3.12} \end{align} $$</p>
<blockquote>
<p>注意，对于多元线性回归，我们的优化目标可以看作：</p>
<p>$$\begin{align} f(\mathbf{\hat{x}}) = \mathbf{X} \mathbf{\hat{w}} \mbox{ ，使得 } f(\mathbf{\hat{x}}) \cong \mathbf{y}   \end{align}$$ </p>
<p>那么可直接利用广义逆解得：</p>
<p>$$\mathbf{\hat{w}} = \mathbf{X^{+}} \mathbf{y}$$ </p>
<p>对于广义逆，如果 $\mathbf{X^T} \mathbf{X}$ 为满秩矩阵（full-rank matrix），那么我们就有补充公式（可利用正SVD分解证明）：</p>
<p>$$\mathbf{X^{+}} = \mathbf{(X^{T}X)^{-1}} \mathbf{X^T} $$ </p>
<p>进而有：</p>
<p>$$\mathbf{\hat{w}} = \mathbf{(X^{T}X)^{-1}} \mathbf{X^T} \mathbf{y}$$ </p>
<p>可见，这与利用最小二乘法得到的结论是一致的。（矩阵理论nb！）</p>
</blockquote>
<p>然而，现实任务中 $\mathbf{X^T} \mathbf{X}$ 往往不是满秩矩阵。例如在许多任务中我们会遇到大量的变量，其数目甚至超过样例数，导致 $\mathbf{X}$ 的列数多于行数， $\mathbf{X^T} \mathbf{X}$ 显然不满秩。</p>
<ul>
<li>此时可解出多个 $\hat{w}$ ，它们都能使均方误差最小化。</li>
</ul>
<p>选择哪一个解作为输出，将<strong>由学习算法的归纳偏好决定</strong>，常见的做法是引入<strong>正则化（regularization）项</strong>。</p>
<h4 id="广义线性回归"><a href="#广义线性回归" class="headerlink" title="广义线性回归"></a>广义线性回归</h4><p>线性模型虽简单，却有丰富的变化。</p>
<p>例如对于样例 $(\mathbf{x}, y)$  ，$y \in \mathbb{R}$ ，当我们希望线性模型（3.2）的预测值逼近输出标记（ground-truth）时，就得到了线性回归模型。此时我们可以将线性回归模型简写为</p>
<p>$$\begin{align} y = \mathbf{w^T x} + b \tag{3.13} \end{align}$$</p>
<p>那么可否令模型预测值逼近 $y$ 的衍生物呢？譬如说，假设我们认为示例所对应的输出标记是在指数尺度上变化，那就可<strong>将输出标记的对数作为线性模型逼近的目标</strong>，即</p>
<p>$$\begin{align} \ln y = \mathbf{w^T x} + b \tag{3.14} \end{align}$$</p>
<p>这就是<strong>“对数线性回归”（log-linear regression）</strong>，它实际上是在试图让 $e^{\mathbf{w^T x} + b}$ 逼近 $y$ 。</p>
<ul>
<li>式（3.14）在形式上仍是线性回归，但实质上已是在<strong>求取输入空间到输出空间的非线性函数映射</strong>。</li>
</ul>
<p>如图3.1所示，这里的对数函数起到了将线性回归模型的预测值与真实标记联系起来的作用。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211005222211450.png" alt="image-20211005222211450" style="zoom:80%;" />

<p>更一般地，考虑单调可微函数 $g(\cdot)$ ，令</p>
<p>$$\begin{align} y = g^{-1} (\mathbf{w^T x} + b) \tag{3.15} \end{align}$$</p>
<p>这样得到的模型称为<strong>“广义线性模型”（generalized linear model）</strong>，其中函数 $g(\cdot)$ 称为<strong>“联系函数”（link function）</strong>。显然，对数线性回归是广义线性模型在 $g(\cdot) = ln(\cdot)$ 时的特例。</p>
<h3 id="3-3-逻辑回归"><a href="#3-3-逻辑回归" class="headerlink" title="3.3 逻辑回归"></a>3.3 逻辑回归</h3><p>上一节讨论了如何使用线性模型进行<strong>回归学习</strong>，但若要做的是<strong>分类任务</strong>该怎么办？答案蕴涵在式（3.15）的广义线性模型中：</p>
<ul>
<li>只需找一个单调可微函数将分类任务的真实标记 $y$ 与线性回归模型的预测值联系起来即可。</li>
</ul>
<p>比如我们考虑二分类任务，其输出标记 $y \in {0, 1}$，而线性回归模型产生的预测值 $z = \mathbf{w^T x} + b$ 是实值，于是，我们需将实值 $z$ 转换为 $0/1$ 值。</p>
<p>最理想的是<strong>“单位阶跃函数”（unit-step function）</strong>：</p>
<p>$$\begin{align} y =  \begin{cases} 0, \ \ \ \ \ z &lt; 0; \ 0.5, \ \ z = 0; \ 1, \ \ \ \ \ z &gt; 0;   \end{cases} \tag{3.16} \end{align}$$</p>
<p>即若预测值 $z$ 大于零就判为正例，小于零则判为反例，预测值为临界值零则可任意判别，如图3.2所示：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211006141630880.png" alt="image-20211006141630880" style="zoom:80%;" />

<p>但从图3.2可看出，<strong>单位阶跃函数不连续</strong>，因此不能直接用作式（3.15）中的 $g^{-1}(\cdot)$ 。于是我们希望找到能在一定程度上近似单位阶跃函数的“替代函数”（surrogate function），并希望它单调可微 —— <strong>对数几率函数（logisticfunction）</strong>正是这样一个常用的替代函数：</p>
<p>$$\begin{align} y = \frac{1}{1 + e^{-z}} \tag{3.17} \end{align}$$</p>
<p>从图3.2可看出，对数几率函数是一种<strong>“Sigmoid函数”</strong>，它能够将 $z$ 值转化为一个接近0或1的 $y$ 值，并且其输出值在 $z=0$ 附近变化很陡。</p>
<blockquote>
<p>Sigmoid函数即形似S的函数，对率函数是Sig-moid函数最重要的代表。</p>
</blockquote>
<p>将对数几率函数作为 $g^{-1}(\cdot) $ 代入式（3.15），得到</p>
<p>$$\begin{align} y = \frac{1}{1 + e^{-( \mathbf{w^T x} + b )}} \tag{3.18} \end{align} $$</p>
<p>类似于式（3.14），式（3.18）可变化为</p>
<p>$$\begin{align} \ln \frac{y}{1-y} = \mathbf{w^T x} + b \tag{3.19} \end{align}$$</p>
<p>若将 $y$ 视为样本 $x$ 作为正例的可能性，则 $1-y$ 是其作为反例的可能性，两者的比值即为</p>
<p>$$\begin{align} \frac{y}{1-y} \tag{3.20} \end{align}$$</p>
<p>称为<strong>“几率”（odds）</strong>，反映了 $x$ 作为正例的相对可能性。</p>
<p>对几率取对数则得到<strong>“对数几率”</strong>（log odds，亦称logit）</p>
<p>$$\begin{align} \ln \frac{y}{1-y} \tag{3.21} \end{align}$$</p>
<p>由此可看出，<strong>式（3.18）实际上是在用线性回归模型的预测结果去逼近真实标记的对数几率</strong>，因此，其对应的模型称为<strong>“对数几率回归”</strong>（logistic regression），亦称<strong>逻辑回归（logit regression）</strong>。</p>
<blockquote>
<p>特别需注意到，虽然它的名字是“回归”，但实际却是一种分类学习方法。这种方法有很多优点，例如</p>
<ul>
<li>它是直接对分类可能性进行建模，<strong>无需事先假设数据分布</strong>，这样就避免了假设分布不准确所带来的问题；</li>
<li>它不是仅预测出“类别”，而是可得到<strong>近似概率预测</strong>，这对许多需利用概率辅助决策的任务很有用；</li>
<li>此外，对率函数是<strong>任意阶可导的凸函数</strong>，有很好的数学性质，现有的许多数值优化算法都可直接用于求取最优解。</li>
</ul>
</blockquote>
<h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h4><p>那么如何确定式（3.18）中的 $w$ 和 $b$ 呢？前面提到，$y$ 和 $1-y$ 分别表示 $x$ 作为正例和反例的可能性大小，我们不妨将它们视为<strong>类后验概率估计</strong> $p(y=1|x)$ 和 $p(y=0|x)$ ，显然有</p>
<p>$$\begin{align} p(y=1|x) = \frac{e^{\mathbf{w^T x} + b}}{1 + e^{\mathbf{w^T x} + b}} \tag{3.23} \end{align} $$</p>
<p>$$\begin{align} p(y=0|x) = \frac{1}{1 + e^{\mathbf{w^T x} + b}} \tag{3.24} \end{align} $$</p>
<p>于是，我们可通过<strong>“极大似然法”（maximum likelihood method）</strong>来估计，若给定数据集 $D = {(\mathbf{x_i}, y_i)}_{i=1}^m$ ，则</p>
<ul>
<li><p>对率回归模型（逻辑回归模型）就是<strong>最大化“对数似然”（log-likelihood）函数</strong></p>
<p>$$\begin{align} L(\mathbf{w}, b) = \sum_{i=1}^m \ln p(y_i | \mathbf{x_i}; \mathbf{w}, b) \tag{3.25} \end{align}$$</p>
<p>即<strong>令每个样本属于其真实标记的概率越大越好</strong>。</p>
</li>
</ul>
<p>为便于讨论，我们</p>
<ul>
<li>令 $\mathbf{\hat{w}} = (\mathbf{w}; b)$ ，$\mathbf{\hat{x}} =  (\mathbf{x};1)$ ，则 $\mathbf{w^T x} + b$ 可以简写为 $\mathbf{\hat{w}^T \hat{x}}$ ；</li>
<li>再令 $p_1(\mathbf{\hat{x}; \hat{w}}) = p(y = 1 | \mathbf{\hat{x}; \hat{w}})$ ，$p_0(\mathbf{\hat{x}; \hat{w}}) = p(y = 0 | \mathbf{\hat{x}; \hat{w}}) = 1 - p_1(\mathbf{\hat{x}; \hat{w}}) $ 。</li>
</ul>
<p>则式（3.25）中的似然项可重写为</p>
<p>$$\begin{align} p(y_i | \mathbf{x_i}; \mathbf{w}, b) = y_i p_1(\mathbf{\hat{x_i}; \hat{w}}) + (1 - y_i) p_0(\mathbf{\hat{x_i}; \hat{w}}) \tag{3.26} \end{align}$$</p>
<blockquote>
<p>#? question</p>
<p>这里似然项的展开，并没有完全理解，这是信息熵演变而来的吗？</p>
<p>#! answer</p>
<p>不是，注意这里 $y_i$ 为0或1，因此上（3.26）实际只会有一项。</p>
</blockquote>
<p>将式（3.26）代入（3.25），并根据式（3.23）和（3.24）可知，最大化式（3.25）等价于最小化</p>
<p>$$\begin{align} L(\mathbf{\hat{w}}) = \sum_{i=1}^m \left( -y_i \mathbf{\hat{w}^T \hat{x}} + \ln (1 + e^{\mathbf{\hat{w}^T \hat{x}}}) \right) \tag{3.27} \end{align}$$</p>
<blockquote>
<p>注意到 $y_i$ 为0或1，因此可分别将两种情况代入并综合即可得到上式，具体证明见【南瓜书-P10】。</p>
</blockquote>
<p>式（3.27）是关于 $\mathbf{\hat{w}}$ 的高阶可导连续凸函数，根据<strong>凸优化理论</strong>【Boyd and Vandenberghe，2004】，或经典的数值优化算法如<strong>梯度下降法</strong>（gradient descent method）、<strong>牛顿法</strong>（Newton method）等都可求得其最优解。</p>
<p>于是就得到</p>
<p>$$\begin{align} \mathbf{\hat{w}}^* = \underset{\mathbf{\hat{w}}}{\arg\min} \ L(\mathbf{\hat{w}}) \tag{3.28} \end{align}$$</p>
<h3 id="3-4-线性判别分析"><a href="#3-4-线性判别分析" class="headerlink" title="3.4 线性判别分析"></a>3.4 线性判别分析</h3><p><strong>线性判别分析（Linear Discriminant Analysis，简称LDA）</strong>是一种经典的线性学习方法，在二分类问题上因为最早由【Fisher，1936】提出，亦称“<strong>Fisher判别分析</strong>”。</p>
<p>LDA的思想非常朴素：</p>
<ul>
<li>给定训练样例集，设法将样例投影到一条直线上，<strong>使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离</strong>；</li>
<li>在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别</li>
</ul>
<p>图3.3给出了一个二维示意图：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211006161749232.png" alt="image-20211006161749232" style="zoom:80%;" />

<p>令 $X_i、\mu_i、\Sigma_i$ 分别表示第 $i \in {0, 1}$ 类示例的<strong>集合、均值向量、协方差矩阵</strong>。</p>
<ul>
<li>若将数据投影到直线 $y = w^Tx$ 上，则两类样本的中心在直线上的投影分别为 $w^T \mu_0$ 和 $w^T \mu_1$ ；</li>
<li>若将所有样本点都投影到直线上，则两类样本的协方差分别为 $w^T \Sigma_0 w$  和 $w^T \Sigma_1 w$ 。</li>
</ul>
<p>由于直线是一维空间，因此  $w^T \mu_0$ 、 $w^T \mu_1$ 、 $w^T \Sigma_0 w$  和 $w^T \Sigma_1 w$ 均为实数。</p>
<ul>
<li>欲使同类样例的投影点尽可能接近，可以<strong>让同类样例投影点的协方差尽可能小</strong>，即 $w^T \Sigma_0 w + w^T \Sigma_1 w$  尽可能小；</li>
<li>而欲使异类样例的投影点尽可能远离，可以<strong>让类中心之间的距离尽可能大</strong>，即 $ ||w^T \mu_0 - w^T \mu_1||^2$ 尽可能大。</li>
</ul>
<p>同时考虑二者，则可得到欲最大化的目标</p>
<p>$$\begin{align} J &amp;= \frac{||w^T \mu_0 - w^T \mu_1||^2}{w^T \Sigma_0 w + w^T \Sigma_1 w} \ &amp;= \frac{w^T  (\mu_0 - \mu_1)(\mu_0 - \mu_1)^T w}{w^T  (\Sigma_0 + \Sigma_1) w} \tag{3.32} \end{align}$$</p>
<ul>
<li><p>定义<strong>“类内散度矩阵”</strong>（<strong>w</strong>ithin-class scatter matrix）</p>
<p>$$\begin{align} S_w &amp;= \Sigma_0 + \Sigma_1 \ &amp;= \sum_{x \in X_0} (x - \mu_0)(x - \mu_0)^T + \sum_{x \in X_1} (x - \mu_1)(x - \mu_1)^T \tag{3.33} \end{align}$$</p>
</li>
<li><p>以及<strong>“类间散度矩阵”</strong>（<strong>b</strong>etween-class scatter matrix）</p>
<p>$$\begin{align} S_b = (\mu_0 - \mu_1)(\mu_0 - \mu_1)^T \tag{3.34} \end{align}$$</p>
</li>
</ul>
<p>则式（3.32）可重写为</p>
<p>$$\begin{align} J = \frac{w^T S_b w}{w^T S_w w} \tag{3.35} \end{align}$$</p>
<p>这就是LDA欲最大化的目标，即 $S_b$ 与 $S_w$ 的“广义瑞利商”（generalized Rayleigh quotient)。</p>
<h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><p>如何确定 $w$ 呢？注意到式（3.35）的分子和分母都是关于 $w$ 的二次项，因此式（3.35）的解与 $w$ 的长度无关，只与其方向有关。</p>
<p>因此令 $w^T S_w w= 1 $ 不失一般性 ，则式（3.35）等价于</p>
<p>$$\begin{align} \min_{w} \ \ -w^TS_bw \ s.t. \ \ w^TS_ww = 1 \tag{3.36} \end{align}$$</p>
<p>由拉格朗日乘子法，能够求得</p>
<p>$$\begin{align} w = S_w^{-1}(\mu_0 - \mu_1) \tag{3.39} \end{align}$$</p>
<blockquote>
<p>详见【南瓜书- P11】</p>
<p>此外，书中还提到了“考虑到数值解的稳定性，在实践中通常是对S进行奇异值分解…”</p>
</blockquote>
<h4 id="LDA多分类任务"><a href="#LDA多分类任务" class="headerlink" title="LDA多分类任务"></a>LDA多分类任务</h4><p>loading…</p>
<ul>
<li><h3 id="3-5-多分类学习"><a href="#3-5-多分类学习" class="headerlink" title="3.5 多分类学习"></a>3.5 多分类学习</h3></li>
<li><h3 id="3-6-类别不平衡问题"><a href="#3-6-类别不平衡问题" class="headerlink" title="3.6 类别不平衡问题"></a>3.6 类别不平衡问题</h3></li>
</ul>
<h3 id="3-7-思考与归纳"><a href="#3-7-思考与归纳" class="headerlink" title="3.7 思考与归纳"></a>3.7 思考与归纳</h3><p>在前面介绍的线性模型中，实际上目标均为使 $\mathbf{w^T x} + b$ 尽可能地拟合 $y$ ，不同之处仅在于优化算法，或者说使用的准则函数不同，如：</p>
<ul>
<li>最常见的最小二乘法，即<strong>最小平方误差准则</strong>（MSE），优化目标为<strong>最小化样本点到直线的距离</strong>。</li>
<li>LDA法，或称<strong>Fisher准则</strong>，优化目标为使<strong>类内距离尽可能小，类间距离尽可能大</strong>，其考虑的是样本在直线上的<strong>投影点之间的距离</strong>。</li>
<li>还有一种<strong>感知机准则</strong>，亦即神经网络采用的优化函数，常使用<strong>梯度下降法</strong>进行优化。</li>
</ul>
<h2 id="第4章-决策树"><a href="#第4章-决策树" class="headerlink" title="第4章 决策树"></a>第4章 决策树</h2><h3 id="4-1-基本流程"><a href="#4-1-基本流程" class="headerlink" title="4.1 基本流程"></a>4.1 基本流程</h3><p>决策树（decision tree）是一类常见的机器学习方法。顾名思义，决策树是基于树结构来进行决策的，这恰是人类在面临决策问题时一种很自然的处理机制。</p>
<p>例如，我们要对“这是好瓜吗？”这样的问题进行决策时，通常会进行一系列的判断或“子决策”，如图4.1所示：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211106111502639.png" alt="image-20211106111502639" style="zoom:67%;" />



<p>一般的，一棵决策树包含一个根结点、若干个内部结点和若干个叶结点：</p>
<ul>
<li>叶结点对应于<strong>决策结果</strong>；</li>
<li>其他每个结点则对应于一个<strong>属性测试</strong>，每个结点包含的样本集合根据属性测试的结果被划分到子结点中；</li>
<li>根结点包含<strong>样本全集</strong>，从根结点到每个叶结点的路径对应了一个<strong>判定测试序列</strong>。</li>
</ul>
<p>决策树学习的目的是为了产生一棵泛化能力强，即处理未见示例能力强的决策树，其基本流程遵循简单且直观的<strong>“分而治之”（divide-and-conquer）</strong>策略，如图4.2所示。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211106112208816.png" alt="image-20211106112208816" style="zoom:80%;" />



<p>显然，决策树的生成是一个递归过程。</p>
<p>在决策树基本算法中，有三种情形会导致递归返回：</p>
<ol>
<li>当前结点包含的<strong>样本全属于同一类别</strong>，无需划分；</li>
<li>当前<strong>属性集为空</strong>，或是所有样本在所有属性上取值相同，无法划分；</li>
<li>当前结点包含的<strong>样本集合为空</strong>，不能划分.</li>
</ol>
<blockquote>
<ul>
<li><p>在第（2）种情形下，我们把当前结点标记为叶结点，并将其类别设定为<strong>该结点所含样本最多的类别</strong>；</p>
</li>
<li><p>在第（3）种情形下，同样把当前结点标记为叶结点，但将其类别设定为其<strong>父结点所含样本最多的类别</strong>。</p>
</li>
</ul>
<p>注意这两种情形的处理实质不同：</p>
<p>情形（2）是在利用当前结点的<strong>后验分布</strong>，而情形（3）则是把父结点的样本分布作为当前结点的<strong>先验分布</strong>。</p>
</blockquote>
<h3 id="4-2-划分选择"><a href="#4-2-划分选择" class="headerlink" title="4.2 划分选择"></a>4.2 划分选择</h3><p>由算法4.2可看出，决策树学习的关键是第8行，即<strong>如何选择最优划分属性</strong>。</p>
<ul>
<li>一般而言，随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即<strong>结点的“纯度”（purity）越来越高</strong>。</li>
</ul>
<h4 id="4-2-1-信息增益"><a href="#4-2-1-信息增益" class="headerlink" title="4.2.1 信息增益"></a>4.2.1 信息增益</h4><p><strong>“信息熵”（information entropy）</strong>是度量样本集合纯度最常用的一种指标。</p>
<p>假定当前样本集合 $D$ 中第 $k$ 类样本所占的比例为 $p_k(k=1,2,\dots,|\gamma|)$ ，则样本集 $D$ 的信息熵定义为 </p>
<p>$$\begin{align} \text{Ent}(D) = - \sum_{k=1}^{|\gamma|} p_k \log_2 p_k \tag{4.1} \end{align} $$</p>
<blockquote>
<p>计算信息熵时约定：若 $p = 0$ ，则 $p \log_2 p = 0.$</p>
</blockquote>
<p>$Ent(D)$ 的值越小，则 $D$ 的纯度越高。$Ent(D)$ 的最小值为0，最大值为 $\log_2 |\gamma|$ 。</p>
<p>假定离散属性 $a$ 有 $V$ 个可能的取值 ${ a^1, a^2, \dots, a^V }$ ，若使用 $a$ 来对样本集 $D$ 进行划分，则会产生 $V$ 个分支结点，其中第 $v$ 个分支结点包含了 $D$ 中所有在属性 $a$ 上取值为 $a^v$ 的样本，记为 $D^v$ 。那么我们便可根据式（4.1）计算出 $D^v$ 的信息熵。</p>
<p>考虑到不同的分支结点所包含的样本数不同，给分支结点赋予权重 $|D^v|/|D|$ ，即样本数越多的分支结点的影响越大。</p>
<p>于是可计算出属性 $a$ 对样本集 $D$ 进行划分所获得的<strong>“信息增益”（information gain）</strong>：</p>
<p>$$\begin{align}  \text{Gain}(D, a) = \text{Ent}(D) - \sum_{v=1}^V \frac{|D^v|}{|D|} \text{Ent}(D^v) \tag{4.2} \end{align} $$</p>
<ul>
<li>一般而言，<strong>信息增益越大，则意味着使用属性 $a$ 来进行划分所获得的“纯度提升”越大</strong>。</li>
</ul>
<p>因此，我们可用信息增益来进行决策树的划分属性选择，即在图4.2算法第8行选择属性：</p>
<p>$$\begin{align} a_* = \arg\max_{a \in A} Gain(D, a). \end{align}$$</p>
<ul>
<li>著名的<strong>ID3决策树学习算法</strong>【Quinlan，1986】就是以<strong>信息增益</strong>为准则来选择划分属性。</li>
</ul>
<blockquote>
<p>ID3 名字中的 ID 是 Iterative Dichotomiser （迭代二分器）的简称.</p>
</blockquote>
<h4 id="4-2-2-增益率"><a href="#4-2-2-增益率" class="headerlink" title="4.2.2 增益率"></a>4.2.2 增益率</h4><p>实际上，信息增益准则对可取值数目较多的属性有所偏好。</p>
<blockquote>
<p>比如若样本集 $D$ 大小为 17，如果把“编号”也作为一个候选划分属性，则根据式（4.2）可计算出它的信息增益为 0.998。</p>
<p>这很容易理解，因为“编号”将产生17个分支，且<strong>每个分支仅包含一个样本，这些分支样本的纯度已达最大</strong>。</p>
<p>然而，这样的决策树显然不具有泛化能力，无法对新样本进行有效预测。</p>
</blockquote>
<p>为减少这种偏好可能带来的不利影响，著名的<strong>C4.5决策树算法</strong>【Quinlan，1993】不直接使用信息增益，而是使用<strong>“增益率”（gain ratio）</strong>来选择最优划分属性：</p>
<p>$$\begin{align}  \text{Gain_ratio} \ (D, a) = \frac{\text{Gain}(D, a)}{\text{IV}(a)} \tag{4.3} \end{align} $$</p>
<p>其中</p>
<p>$$\begin{align}  \text{IV}(a) = - \sum_{v=1}^V \frac{|D^v|}{|D|} \  \log_2 \frac{|D^v|}{|D|} \tag{4.4} \end{align} $$</p>
<p>称为属性 $a$ 的<strong>“固有值”（intrinsic value）</strong>。</p>
<ul>
<li>属性 $a$ 的可能取值数目越多（即 $V$ 越大），则 $\text{IV}(a)$ 的值通常会越大。</li>
</ul>
<p>需注意的是，增益率准则对可取值数目较少的属性有所偏好，因此，C4.5算法并不是直接选择增益率最大的候选划分属性，而是使用了一个<strong>启发式</strong>：</p>
<ul>
<li>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。</li>
</ul>
<h4 id="4-2-3-基尼指数"><a href="#4-2-3-基尼指数" class="headerlink" title="4.2.3 基尼指数"></a>4.2.3 基尼指数</h4><p>CART决策树【Breiman et al.，1984】使用<strong>“基尼指数”（Gini index）</strong>来选择划分属性，样本集 $D$ 的纯度可用<strong>基尼值</strong>来度量：</p>
<p>$$\begin{align} \text{Gini}(D) &amp;= \sum_{k=1}^{|\gamma|} \sum_{k’ \neq k} p_k p_{k’} \ &amp;= 1 -  \sum_{k=1}^{|\gamma|}p_k^2  \tag{4.5} \end{align}$$</p>
<blockquote>
<p>CART是Classificationand Regression Tree的简称，这是一种著名的决策树学习算法，分类和回归任务都可用.</p>
</blockquote>
<p>直观来说，$\text{Gini}(D)$  反映了从数据集 $D$ 中随机抽取两个样本，其类别标记不一致的概率。因此，$\text{Gini}(D)$  越小，则数据集D的纯度越高。</p>
<p>那么，属性 $a$ 的基尼指数定义为</p>
<p>$$\begin{align}  \text{Gini_index}(D, a) = \sum_{v=1}^V \frac{|D^v|}{|D|} \text{Gini}(D^v) \tag{4.6} \end{align} $$</p>
<h3 id="4-3-剪枝处理"><a href="#4-3-剪枝处理" class="headerlink" title="4.3 剪枝处理"></a>4.3 剪枝处理</h3><p><strong>剪枝（pruning）</strong>是决策树学习算法对付<strong>“过拟合”</strong>的主要手段。</p>
<p>在决策树学习中，为了尽可能正确分类训练样本，结点划分过程将不断重复，有时会造成决策树分支过多，这时就可能因训练样本学得“太好”了，</p>
<ul>
<li>以致于<strong>把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合</strong>。</li>
</ul>
<p>因此，可通过主动去掉一些分支来降低过拟合的风险。</p>
<p>决策树剪枝的基本策略有<strong>“预剪枝”（prepruning）</strong>和 <strong>“后剪枝”（post-pruning）</strong>。</p>
<h4 id="4-3-1-预剪枝"><a href="#4-3-1-预剪枝" class="headerlink" title="4.3.1 预剪枝"></a>4.3.1 预剪枝</h4><p>预剪枝是指在决策树生成过程中，对每个结点在划分前先进行估计，<strong>若当前结点的划分不能带来决策树泛化性能提升</strong>，则停止划分并将当前结点标记为叶结点。</p>
<blockquote>
<p>泛化性能可以在验证集上进行评估。</p>
</blockquote>
<p>预剪枝策略特点：</p>
<ul>
<li><strong>优势</strong>：“剪掉”很多没必要展开的分支，<strong>降低了过拟合风险</strong>，并且<strong>显著减少了决策树的训练时间开销</strong>和测试时间开销.</li>
<li><strong>劣势</strong>：有些分支的当前划分有可能不能提高甚至降低泛化性能，但后续划分有可能提高泛化性能，预剪枝禁止这些后续分支的展开，可能会<strong>导致欠拟合</strong>.</li>
</ul>
<h4 id="4-3-2-后剪枝"><a href="#4-3-2-后剪枝" class="headerlink" title="4.3.2 后剪枝"></a>4.3.2 后剪枝</h4><p>后剪枝则是先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，<strong>若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升</strong>，则将该子树替换为叶结点。</p>
<p>后剪枝策略特点：</p>
<ul>
<li>优势：测试了所有分支，比预剪枝决策树保留了更多分支，降低了欠拟合的风险，<strong>泛化性能一般优于预剪枝</strong>决策树.</li>
<li>劣势：后剪枝过程在生成完全决策树后再进行，且要自底向上对所有非叶节点逐一评估，因此，决策树的训练<strong>时间开销要高</strong>于未剪枝决策树和预剪枝决策树.</li>
</ul>
<h3 id="4-4-连续与缺失值"><a href="#4-4-连续与缺失值" class="headerlink" title="4.4 连续与缺失值"></a>4.4 连续与缺失值</h3><h4 id="4-4-1-连续值处理"><a href="#4-4-1-连续值处理" class="headerlink" title="4.4.1 连续值处理"></a>4.4.1 连续值处理</h4><p>现实任务中常会遇到连续属性，此时可将连续属性进行离散化，最简单的策略是采用<strong>二分法（bi-partition）</strong>，这也正是C4.5决策树算法中采用的机制。</p>
<p>给定样本集 $D$ 和连续属性 $a$ ， 假定 $a$ 在 $D$ 上出现了 $n$ 个不同的取值，将这些值从小到大进行排序，记为 ${ a^1, a^2, \dots, a^n }$ . </p>
<ul>
<li><strong>基于某个划分点 $t$ 可将 $D$ 分为子集 $D_t^-$ 和 $D_t^+$</strong> ，其中 $D_t^-$ 包含那些在属性 $a$ 上取值不大于 $t$ 的样本，而 $D_t^+$ 则包含那些在属性 $a$ 上取值大于 $t$ 的样本。</li>
</ul>
<p>显然，对相邻的属性取值 $a^i$ 与 $a^{i+1}$ 来说，$t$ 在区间 $[a^i, a^{i+1})$ 中取任意值所产生的划分结果相同。</p>
<p>因此，对连续属性 $a$ ，我们可考察包含 $n-1$ 个元素的候选划分点集合</p>
<p>$$\begin{align} T_a = { \frac{a^i + a^{i+1}}{2} \ \ | \ \ 1 \leq i \leq n-1 } \tag{4.7} \end{align}$$</p>
<p>即把区间 $[a^i, a^{i+1})$ 的中位点 $\frac{a^i + a^{i+1}}{2}$ 作为候选划分点 $t_i$ ，这样便能得到 $n-1$ 对划分。</p>
<ul>
<li>然后，我们就可像离散属性值一样来考察这些划分，并选取最优的划分点进行样本集合的划分。</li>
</ul>
<p>例如，可对式（4.2）稍加改造：</p>
<p>$$\begin{align}  \text{Gain}(D, a) &amp;= \max_{t \in T_a} \text{Gain}(D, a, t) \ &amp;= \max_{t \in T_a} \  ( \text{Ent}(D) - \sum_{\lambda \in {-, +}} \frac{|D^{\lambda}_t|}{|D|} \text{Ent}(D^{\lambda}_t)) \tag{4.8} \end{align} $$</p>
<p>其中 $\text{Gain} (D, a, t)$ 是样本集 $D$ 基于划分点 $t$ 二分后的信息增益。</p>
<p>于是，我们就可<strong>选择使 $\text{Gain} (D, a, t)$ 最大化的划分点来作为连续属性 $a$ 的信息增益</strong>。</p>
<h4 id="4-4-2-缺失值处理"><a href="#4-4-2-缺失值处理" class="headerlink" title="4.4.2 缺失值处理"></a>4.4.2 缺失值处理</h4><p>现实任务中常会遇到不完整样本，即<strong>样本的某些属性值缺失</strong>。尤其是在属性数目较多的情况下，往往会有大量样本出现缺失值。</p>
<blockquote>
<p>例如由于诊测成本、隐私保护等因素，患者的医疗数据在某些属性上的取值（如HIV测试结果）未知.</p>
</blockquote>
<p>如果简单地放弃不完整样本，仅使用无缺失值的样本来进行学习，显然是对数据信息的极大浪费。因此，有必要考虑利用有缺失属性值的训练样例来进行学习。</p>
<p>那么我们便需要解决两个问题：</p>
<ol>
<li>如何在属性值缺失的情况下进行<strong>划分属性选择</strong>？</li>
<li>给定划分属性，若样本在该<strong>属性上的值缺失</strong>，如何对样本进行<strong>划分</strong>？</li>
</ol>
<p>给定训练集 $D$ 和属性 $a$ ，令 $\tilde{D}$ 表示 $D$ 中在属性 $a$ 上没有缺失值的样本子集。</p>
<h5 id="对问题（1）"><a href="#对问题（1）" class="headerlink" title="对问题（1）"></a>对问题（1）</h5><p>显然我们可根据 $\tilde{D}$ 来判断属性 $a$ 的优劣，假定属性 $a$ 有 $V$ 个可取值 ${ a^1, a^2, \dots, a^V }$ ，</p>
<ul>
<li>令 $\tilde{D}^v$ 表示 $\tilde{D}$ 中在属性 $a$ 上取值为 $a^v$ 的样本子集，</li>
<li>$\tilde{D_k}$ 表示 $\tilde{D}$ 中属于第 $k$ 类（$k = 1, 2, \dots, |\gamma|$）的样本子集，</li>
</ul>
<p>则显然有 $\tilde{D} = \cup_{k=1}^{|\gamma|} \tilde{D}<em>k$ ， $\tilde{D} = \cup</em>{v=1}^{V} \tilde{D}^v$ .</p>
<blockquote>
<p>一个是按类别划分，一个是按属性取值划分.</p>
</blockquote>
<p>假定我们为每个样本 $x$ 赋予一个权重 $w_x$ ，并定义</p>
<p>$$\begin{align} \rho = \frac{\sum_{x \in \tilde{D}} w_x}{\sum_{x \in D} w_x} \tag{4.9} \end{align}$$</p>
<p>$$\begin{align} \tilde{p}<em>k = \frac{\sum</em>{x \in \tilde{D}_k} w_x}{\sum_{x \in \tilde{D}} w_x} \ , \ (1 \leq k \leq |\gamma|) \tag{4.10} \end{align}$$</p>
<p>$$\begin{align} \tilde{r}<em>v = \frac{\sum</em>{x \in \tilde{D}^v} w_x}{\sum_{x \in \tilde{D}} w_x} \ , \ (1 \leq v \leq V) \tag{4.11} \end{align}$$</p>
<p>直观地看，对于属性 $a$ ，</p>
<ul>
<li>$\rho$ 表示无缺失值样本所占的比例</li>
<li>$\tilde{p}_k$ 表示无缺失值样本中第 $k$ 类所占的比例</li>
<li>$\tilde{r}_v$ 则表示无缺失值样本中在属性 $a$ 上取值 $a^v$ 的样本所占的比例</li>
</ul>
<p>显然，$\sum_{k=1}^{|\gamma|} \tilde{p}<em>k = 1$ ，$\sum</em>{v=1}^V \tilde{r}^v = 1$  .</p>
<p>基于上述定义，我们可将信息增益的计算式（4.2）推广为</p>
<p>$$\begin{align}  \text{Gain}(D, a) &amp;= \rho \times \text{Gain}(\tilde{D}, a) \ &amp;= \rho \times ( \text{Ent}(\tilde{D}) - \sum_{v=1}^V \tilde{r}_v \text{ Ent}(\tilde{D}^v)  ) \tag{4.12} \end{align} $$</p>
<h5 id="对问题（2）"><a href="#对问题（2）" class="headerlink" title="对问题（2）"></a>对问题（2）</h5><ul>
<li>若样本 $x$ 在划分属性 $a$ 上的取值已知，则将 $x$ 划入与其取值对应的子结点，且样本权值在子结点中保持为 $w_x$  </li>
<li>若样本 $x$ 在划分属性 $a$ 上的取值未知，则将 $x$ <strong>同时划入所有子结点</strong>，且样本权值在与属性值 $a^v$ 对应的子结点中<strong>调整为 $\tilde{r}_v · w_x $</strong> .</li>
</ul>
<p>直观地看，这就是<strong>让同一个样本以不同的概率划入到不同的子结点中去</strong>。</p>
<p>C4.5算法便使用了上述解决方案。</p>
<h3 id="4-5-多变量决策树"><a href="#4-5-多变量决策树" class="headerlink" title="4.5 多变量决策树"></a>4.5 多变量决策树</h3><p>若我们把每个属性视为坐标空间中的一个坐标轴，则由 $d$ 个属性描述的样本就对应 $d$ 维空间中的一个数据点。</p>
<ul>
<li>对样本分类则意味着在这个坐标空间中<strong>寻找不同类样本之间的分类边界</strong>。</li>
</ul>
<p>决策树所形成的分类边界有一个明显的特点：<strong>轴平行（axis-parallel）</strong>，即它的分类边界由若干个与坐标轴平行的分段组成。</p>
<p>这样的分类边界使得学习结果有较好的可解释性，因为每一段划分都直接对应了某个属性取值。</p>
<p>但在学习任务的真实分类边界比较复杂时，必须使用很多段划分才能获得较好的近似，此时的决策树会相当复杂，由于要进行大量的属性测试，预测时间开销会很大。</p>
<p>如图4.12所示，若能使用斜的划分边界，则决策树模型将大为简化。</p>
<p><img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211106165554214.png" alt="image-20211106165554214"></p>
<p><strong>“多变量决策树”（multivariate decision tree）</strong>就是能实现这样的“斜划分”甚至更复杂划分的决策树，亦称“斜决策树”（oblique decision tree)。</p>
<ul>
<li><p>在此类决策树中，非叶结点不再是仅对某个属性，而是<strong>对属性的线性组合进行测试</strong>；</p>
</li>
<li><p>换言之，每个非叶结点是一个形如 $\sum_{i=1}^d w_i a_i = t $ 的线性分类器.</p>
<p>其中 $w_i$ 是属性 $a_i$ 的权重。</p>
</li>
</ul>
<p>于是，与传统的“单变量决策树”（univariate decision tree）不同，在多变量决策树的学习过程中，<strong>不是为每个非叶结点寻找一个最优划分属性，而是试图建立一个合适的线性分类器</strong>。</p>
<h3 id="4-6-思考与归纳"><a href="#4-6-思考与归纳" class="headerlink" title="4.6 思考与归纳"></a>4.6 思考与归纳</h3><p>决策树的思想较为简单，理解算法4.2即可。</p>
<h2 id="第5章-神经网络"><a href="#第5章-神经网络" class="headerlink" title="第5章 神经网络"></a>第5章 神经网络</h2><h3 id="5-1-神经元模型"><a href="#5-1-神经元模型" class="headerlink" title="5.1 神经元模型"></a>5.1 神经元模型</h3><p>神经网络中最基本的成分是神经元（neuron）模型。</p>
<ul>
<li>在生物神经网络中，每个神经元与其他神经元相连，当它“兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的电位；</li>
<li>如果某神经元的电位超过了一个“阈值”（threshold），那么它就会被激活，即“兴奋”起来，继续向其他神经元发送化学物质。</li>
</ul>
<p>1943年，【McCulloch and Pitts，1943】将上述情形抽象为图5.1所示的简单模型，这就是一直沿用至今的<strong>“M-P神经元模型”</strong>。</p>
<ul>
<li>在该模型中，神经元接收到来自n个其他神经元传递过来的输入信号，这些输入信号通过<strong>带权重的连接（connection）</strong>进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过<strong>“激活函数”（activation function）</strong>处理以产生神经元的输出。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211107175817425.png" alt="image-20211107175817425" style="zoom:80%;" />

<p>理想中的激活函数是图5.2（a）所示的阶跃函数，它将输入值映射为输出值“0”或“1”。</p>
<p>然而，阶跃函数具有<strong>不连续、不光滑</strong>等不太好的性质，因此实际常用Sigmoid函数作为激活函数，如图5.2（b）所示。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211107175953726.png" alt="image-20211107175953726" style="zoom:80%;" />

<p>把许多个这样的神经元按一定的层次结构连接起来，就得到了神经网络。</p>
<h3 id="5-2-感知机与多层网络"><a href="#5-2-感知机与多层网络" class="headerlink" title="5.2 感知机与多层网络"></a>5.2 感知机与多层网络</h3><p><strong>感知机（Perceptron）</strong>由两层神经元组成，如图5.3所示，输入层接收外界输入信号后传递给输出层，输出层是M-P神经元，亦称“阈值逻辑单元”（threshold logic unit），其数学形式为 $y = f(\sum_i w_i x_i - b)$。</p>
<p>给定训练数据集，权重 $w_i (i = 1, 2, \dots, n)$ 以及偏置 $b$ 可通过学习得到。</p>
<ul>
<li>偏置 $b$ 可看作一个固定输入为 $-1.0$ 的<strong>“哑结点”（dummy node）</strong>，其对应的权重为 $w_{n+1}$ ，这样权重和偏置的学习就可统一为权重的学习。</li>
</ul>
<p>感知机学习规则非常简单，对训练样例 $(\vec{x}, y)$ ，若当前感知机的输出为 $\hat{y}$ ，则感知机权重将这样调整：</p>
<p>$$\begin{align} w_i \larr w_i + \Delta w_i \tag{5.1} \end{align}$$</p>
<p>$$\begin{align} \Delta w_i \larr \eta (y - \hat{y})x_i  \tag{5.2} \end{align}$$</p>
<p>其中，$\eta \in (0, 1)$ 称为<strong>学习率（learning rate）</strong>，$x_i$ 是 $\vec{x}$ 对英语第 $i$ 个输入神经元的分量。</p>
<p>从式（5.1）可看出，</p>
<ul>
<li>若感知机对训练样例 $(\vec{x}, y)$ 预测正确，即 $y - \hat{y}$，则感知机不发生变化</li>
<li>否则将根据错误的程度进行权重调整.</li>
</ul>
<p>需注意的是，<strong>感知机只有输出层神经元进行激活函数处理</strong>，即只拥有一层<strong>功能神经元（functional neuron）</strong>，其学习能力非常有限，例如感知机甚至不能解决异或这样简单的非线性可分问题。</p>
<ul>
<li>要解决非线性可分问题，需考虑使用<strong>多层功能神经元</strong>。</li>
</ul>
<p>例如图5.5中这个简单的两层感知机就能解决异或问题。</p>
<ul>
<li>在图5.5（a）中，输出层与输入层之间的一层神经元，被称为隐层或<strong>隐藏层（hidden layer）</strong>，<strong>隐藏层和输出层神经元都是拥有激活函数的功能神经元</strong>。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211107184107535.png" alt="image-20211107184107535" style="zoom:80%;" />

<p>更一般的，常见的神经网络是形如图5.6所示的层级结构，每层神经元与下一层神经元全互连，神经元之间<strong>不存在同层连接，也不存在跨层连接</strong>，这样的神经网络结构通常称为<strong>“多层前馈神经网络”（multi-layer feedforward neural networks）</strong>。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211107184544499.png" alt="image-20211107184544499" style="zoom:80%;" />

<blockquote>
<p>注意：</p>
<p>输入层神经元仅是接受输入，不进行函数处理，隐层与输出层则包含功能神经元。</p>
</blockquote>
<h3 id="5-3-误差反向传播算法"><a href="#5-3-误差反向传播算法" class="headerlink" title="5.3 误差反向传播算法"></a>5.3 误差反向传播算法</h3><p>欲训练多层网络，式（5.1）的简单感知机学习规则显然不够了，需要更强大的学习算法——<strong>误差逆传播（errorBackPropagation，简称BP）算法</strong>。</p>
<h4 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h4><p>给定训练集 $D = { (x_1, y_1), (x_2, y_2), \dots, (x_m, y_m) } , x_i \in \mathbb{R}^d, y_i \in \mathbb{R}^l$ ，即输入样例由 $d$ 个属性描述，输出 $l$ 维向量。</p>
<p>图5.7给出了一个拥有 $d$ 个输入神经元、$l$ 个输出神经元，以及 $q$ 个隐层神经元的多层前馈网络结构。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211107202430863.png" alt="image-20211107202430863" style="zoom:80%;" />

<p>其中，</p>
<ul>
<li>输入层第 $i$ 个神经元与隐藏层第 $h$ 个神经元之间的连接权重为 $w^{(1)}_{ih}$ ；</li>
<li>隐藏层第 $h$ 个神经元的偏置用 $b^{(1)}<em>h$ 表示，隐藏层第 $h$ 个神经元与输出层第 $j$ 个神经元的连接权重为 $w^{(2)}</em>{hj}$ ；</li>
<li>输出层第 $j$ 个神经元的偏置用 $b^{(2)}_j$ 表示；</li>
</ul>
<blockquote>
<p>注意，这里的变量是按照自己的理解写的，与图5.7并不一一对应。</p>
<p>本节实际推导过程中的变量定义是按下表来的：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入层 i</th>
<th align="center">隐藏层 h</th>
<th align="center">输出层 j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">$a^{(0)}_i = x_i $</td>
<td align="center">$a^{(1)}<em>h = \sum</em>{i=1}^d w^{(1)}_{ih} x_i + b^{(1)}_h$</td>
<td align="center">$a^{(2)}<em>j = \sum</em>{h=1}^q w^{(2)}_{hj} z_h + b^{(2)}_j$</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">$x_i $</td>
<td align="center">$z_h = f(a^{(1)}_h)$</td>
<td align="center">$y_j = f(a^{(2)}_j)$</td>
</tr>
<tr>
<td align="center">weight</td>
<td align="center">-</td>
<td align="center">$w^{(1)}_{ih} $</td>
<td align="center">$w^{(2)}_{hj}$</td>
</tr>
<tr>
<td align="center">bias</td>
<td align="center">-</td>
<td align="center">$b^{(1)}_h$</td>
<td align="center">$b^{(2)}_j$</td>
</tr>
</tbody></table>
<p>但实际上，一般来说 $a$ 常作为激活值，$z$ 一般作为输入值，因此一个更容易扩写且让本强迫症比较满意的变量定义如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入层 i</th>
<th align="center">隐藏层 h</th>
<th align="center">输出层 j</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">$z^{(0)}_i = x_i$</td>
<td align="center">$z^{(1)}<em>h = \sum</em>{i=1}^d w^{(1)}_{ih} a^{(0)}_i + b^{(1)}_h$</td>
<td align="center">$z^{(2)}<em>j = \sum</em>{h=1}^q w^{(2)}_{hj} a^{(1)}_h + b^{(2)}_j$</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">$a^{(0)}_i = x_i$</td>
<td align="center">$a^{(1)}_h = f(z^{(1)}_h)$</td>
<td align="center">$a^{(2)}_j = f(z^{(2)}_j)$ ，即 $y_j$</td>
</tr>
</tbody></table>
</blockquote>
<p>假设隐藏层和输出层神经元均使用图5.2（b）中的Sigmoid 函数（对率几率函数）作为激活函数，则记</p>
<ul>
<li>输入层不进行任务处理，因此第 $i$ 个神经元的输入与输出均为 $x_i$ ；</li>
<li>隐藏层第 $h$ 个神经元接收到的输入为 $a^{(1)}<em>{h} = \sum</em>{i=1}^d w^{(1)}_{ih} x_i$ ，输出为 $z^{(1)}_h = f(a^{(1)}_h)$ ；</li>
<li>输出层第 $j$ 个神经元接收到的输入为 $a^{(2)}<em>{j} = \sum</em>{h=1}^q w^{(2)}_{hj} z^{(1)}_h$ ，输出为 $z^{(2)}_j = f(a^{(2)}_j) =  \hat{y}_j$；</li>
</ul>
<p>那么网络在样例 $(x_k, y_k)$ 上的均方误差即为</p>
<p>$$\begin{align} E_k = \frac{1}{2} \sum_{j=1}^l (\hat{y}^k_j - y^k_j)^2 \tag{5.4} \end{align} $$</p>
<p>BP算法采用式（5.1）来更新参数，并基于<strong>梯度下降（gradient descent）</strong>策略，以目标的负梯度方向对参数进行调整。</p>
<h5 id="1）计算-Delta-w-2-hj"><a href="#1）计算-Delta-w-2-hj" class="headerlink" title="1）计算 $\Delta w^{(2)}_{hj}$"></a>1）计算 $\Delta w^{(2)}_{hj}$</h5><p>对式（5.4）的误差 $E_k$ ，给定学习率 $\eta$ ，有</p>
<p>$$\begin{align} \Delta w^{(2)}_{hj} = - \eta \frac{\part E_k}{\part w^{(2)}_{hj}} \tag{5.6} \end{align} $$</p>
<p>注意到 $w^{(2)}_{hj}$ 先影响到第 $j$ 个输出层神经元的输入值 $a^{(2)}_j$ ，再影响到其输出值 $\hat{y}^k_j$ ，然后才影响到 $E_k$ ，故又</p>
<p>$$\begin{align} \frac{\part E_k}{\part w^{(2)}_{hj}} = \frac{\part E_k}{\part \hat{y}^k_j} · \frac{\part \hat{y}^k_j}{\part a^{(2)}_j} · \frac{\part a^{(2)}<em>j}{\part w^{(2)}</em>{hj}} \tag{5.7} \end{align} $$</p>
<p>现在问题是化简式（5.7）。</p>
<p>我们知道Sigmoid函数有一个很好的性质：</p>
<p>$\begin{align} f’(x) = f(x)(1 - f(x)) \tag{5.8} \end{align}$</p>
<p>于是有根据式（5.4）有：</p>
<p>$$\begin{align} g^{(2)}_j &amp;= \frac{\part E_k}{\part \hat{y}^k_j} · \frac{\part \hat{y}^k_j}{\part a^{(2)}_j} \ &amp;= (\hat{y}^k_j - y^k_j) \hat{y}^k_j (1 - \hat{y}^k_j) \tag{5.9} \end{align}$$</p>
<p>又由前述 $a^{(2)}_j$ 的定义可知：</p>
<p> $\begin{align} \frac{\part a^{(2)}<em>j}{\part w^{(2)}</em>{hj}} = z^{(1)}_h \tag{5.10} \end{align} $  </p>
<p>把式（5.9）和式（5.10）带入式（5.7）中，再代入式（5.6）中，可得第二层神经元 $w^{(2)}_{hj}$ 的更新公式</p>
<p>$$\begin{align} \Delta w_{hj} = - \eta g^{(2)}_j z^{(1)}_h \tag{5.11} \end{align} $$</p>
<h5 id="2）计算-Delta-w-1-ih"><a href="#2）计算-Delta-w-1-ih" class="headerlink" title="2）计算  $\Delta w^{(1)}_{ih}$"></a>2）计算  $\Delta w^{(1)}_{ih}$</h5><p>由于隐藏层的第 $h$ 个神经元与输出层的 $l$ 个神经元均有连接，因此在反向传播时需要考虑所有的 $\sum_{j=1}^l w^{(2)}_{hj} z^{(1)}_h $ .</p>
<p>因此有</p>
<p>$$\begin{align} \frac{\part E_k}{\part w^{(1)}<em>{ih}} &amp;= \sum</em>{j=1}^l \frac{\part E_k}{\part \hat{y}^k_j} · \frac{\part \hat{y}^k_j}{\part a^{(2)}<em>j} · \frac{\part a^{(2)}<em>j}{\part z^{(1)}</em>{h}} · \frac{\part z^{(1)}<em>h}{\part a^{(1)}</em>{h}}  · \frac{\part a^{(1)}<em>h}{\part w</em>{ih}} \ &amp;= \sum</em>{j=1}^l g^{(2)}<em>j \cdot w</em>{hj} \ \cdot z^{(1)}_h (1 - z^{(1)}_h) \ \cdot x_i  \tag{5.12} \end{align} $$</p>
<p>令 $g^{(1)}<em>h = z^{(1)}_h (1 - z^{(1)}_h) \ \cdot \sum</em>{j=1}^l w_{hj} \cdot  g^{(2)}_j$</p>
<p>则有</p>
<p>$$\begin{align} \Delta w^{(2)}_{hj} &amp;= - \eta \frac{\part E_k}{\part w^{(2)}_{hj}} \ &amp;= - \eta g^{(1)}_h x_i \tag{5.13} \end{align} $$</p>
<h5 id="3）计算偏置-Delta-b-1-h-与-Delta-b-2-j"><a href="#3）计算偏置-Delta-b-1-h-与-Delta-b-2-j" class="headerlink" title="3）计算偏置  $\Delta b^{(1)}_h$ 与 $\Delta b^{(2)}_j$"></a>3）计算偏置  $\Delta b^{(1)}_h$ 与 $\Delta b^{(2)}_j$</h5><p>正如5.2节提到的，「偏置 $b$ 可看作一个固定输入为 $-1.0$ 的哑结点」，因此可直接将 $-1.0$ 带入式（5.11）与式（5.12）即得</p>
<p>$$\begin{align} \Delta b^{(2)}_j = \eta g^{(2)}_j \tag{5.13} \end{align} $$</p>
<p>$$\begin{align} \Delta b^{(1)}_h = \eta g^{(1)}_h \tag{5.14} \end{align} $$</p>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>BP算法的工作流程如下：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211107215245848.png" alt="image-20211107215245848" style="zoom:95%;" />

<p>需注意的是，BP算法的目标是要最小化训练集 $D$ 上的累积误差：</p>
<p>$$\begin{align} E = \frac{1}{m} \sum_{k=1}^m E_k \tag{5.16} \end{align}$$</p>
<p>但我们上面介绍的“标准BP算法”每次仅针对一个训练样例更新连接权和偏置，参数更新得非常频繁，而且对不同样例进行更新的效果可能出现“抵消”现象。</p>
<p>因此，在实际训练中，我们常采用<strong>随机梯度下降</strong>的方法进行参数更新，详见<a href="https://jay1zhang.github.io/2021/04/22/Computer%20Science/Deep%20Learning/%E3%80%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8D%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/">「深度学习」神经网络中的优化算法</a>。</p>
<h4 id="残差网络中的BP"><a href="#残差网络中的BP" class="headerlink" title="残差网络中的BP"></a>残差网络中的BP</h4><p>详见 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/80226180">残差网络解决了什么，为什么有效？</a> .</p>
<h3 id="5-4-全局最小与局部极小"><a href="#5-4-全局最小与局部极小" class="headerlink" title="5.4 全局最小与局部极小"></a>5.4 全局最小与局部极小</h3><p>若用 $E$ 表示神经网络在训练集上的误差，则它显然是关于连接权 $w$ 和偏置 $b$ 的函数。</p>
<p>此时，神经网络的训练过程可看作一个参数寻优过程，</p>
<ul>
<li>即<strong>在参数空间中，寻找一组最优参数使得E最小</strong>。</li>
</ul>
<p>我们常会谈到两种“最优”：“<strong>局部极小</strong>”（local minimum）和“<strong>全局最小</strong>”（global minimum）。</p>
<p>显然，</p>
<ul>
<li>参数空间内<strong>梯度为零</strong>的点，只要其误差函数值小于邻点的误差函数值，就是局部极小点；</li>
<li>可能存在多个局部极小值，但却只会有一个全局最小值；</li>
</ul>
<p>如图5.10中有两个局部极小，但只有其中之一是全局最小，显然，我们在参数寻优过程中是希望找到全局最小。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211107223127581.png" alt="image-20211107223127581" style="zoom:80%;" />

<p>基于梯度的搜索是使用最为广泛的参数寻优方法。</p>
<ul>
<li><p>在此类方法中，我们从某些初始解出发，迭代寻找最优参数值；</p>
</li>
<li><p>每次迭代中，我们先计算误差函数在当前点的梯度，然后根据梯度确定搜索方向。</p>
</li>
</ul>
<p>例如，由于负梯度方向是函数值下降最快的方向，因此梯度下降法就是<strong>沿着负梯度方向搜索最优解</strong>。</p>
<ul>
<li>若误差函数在当前点的梯度为零，则已达到局部极小，更新量将为零，这意味着<strong>参数的迭代更新将在此停止</strong>。</li>
</ul>
<p>显然，如果误差函数具有多个局部极小，则不能保证找到的解是全局最小。</p>
<p>在现实任务中，人们常采用以下策略来试图“跳出”局部极小，从而进一步接近全局最小：</p>
<ul>
<li><p><strong>以多组不同参数值初始化多个神经网络</strong>，按标准方法训练后，取其中误差最小的解作为最终参数。这相当于从多个不同的初始点开始搜索，这样就可能陷入不同的局部极小，从中进行选择有可能获得更接近全局最小的结果；</p>
</li>
<li><p>使用<strong>“模拟退火”（simulated annealing）</strong>技术。模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率要随着时间的推移而逐渐降低，从而保证算法稳定；</p>
</li>
<li><p>使用<strong>随机梯度下降</strong>，与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入了随机因素。于是，即便陷入局部极小点，它计算出的梯度仍可能不为零，这样就有机会跳出局部极小继续搜索；</p>
</li>
<li><p>此外，<strong>遗传算法（genetic algorithms）</strong> 也常用来训练神经网络以更好地逼近全局最小。</p>
</li>
</ul>
<p>需注意的是，上述用于跳出局部极小的技术大多是启发式，<strong>理论上尚缺乏保障</strong>。</p>
<h3 id="5-5-深度学习"><a href="#5-5-深度学习" class="headerlink" title="5.5 深度学习"></a>5.5 深度学习</h3><p>理论上来说，参数越多的模型复杂度越高、“容量”（capacity）越大，这意味着它能完成更复杂的学习任务。典型的深度学习模型就是很深层的神经网络，然而，深度神经网络难以直接用经典算法（例如标准BP算法）进行训练，因为误差在多隐层内逆传播时，往往会“发散”（diverge）而不能收敛到稳定状态。</p>
<h4 id="1）“预训练-微调”"><a href="#1）“预训练-微调”" class="headerlink" title="1）“预训练+微调”"></a>1）“预训练+微调”</h4><p>无监督逐层训练（unsupervised layer-wise training）是多隐层网络训练的有效手段，其基本思想是</p>
<ul>
<li>每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，而本层隐结点的输出作为下一层隐结点的输入，这称为“预训练”（pre-training）；</li>
<li>在预训练全部完成后，再对整个网络进行“微调”（fine-tuning）训练。</li>
</ul>
<p>事实上，“预训练+微调”的做法可视为将大量参数分组，对每组先找到局部看来比较好的设置，然后再基于这些局部较优的结果联合起来进行全局寻优。这样就在利用了模型大量参数所提供的自由度的同时，有效地节省了训练开销。</p>
<h4 id="2）“权共享”"><a href="#2）“权共享”" class="headerlink" title="2）“权共享”"></a>2）“权共享”</h4><p>另一种节省训练开销的策略是<strong>“权共享”（weight sharing）</strong>，即让一组神经元使用相同的连接权，这个策略在卷积神经网络（Convolutional NeuralNetwork，简称CNN）【LeCun and Bengio，1995；LeCun et al.，1998】中发挥了重要作用。</p>
<p>关于CNN的详细内容可参考<a href="https://jay1zhang.github.io/2021/04/29/Computer%20Science/Deep%20Learning/%E3%80%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8D%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E%20LeNet5%20%E5%88%B0%20DenseNet%20/">「深度学习」卷积网络架构的演进：从 LeNet5 到 DenseNet</a>。</p>
<h3 id="5-6-思考与归纳"><a href="#5-6-思考与归纳" class="headerlink" title="5.6 思考与归纳"></a>5.6 思考与归纳</h3><p>务必注意并掌握反向传播算法的推导过程。</p>
<h2 id="第6章-支持向量机"><a href="#第6章-支持向量机" class="headerlink" title="第6章 支持向量机"></a>第6章 支持向量机</h2><p>支持向量机（Support Vertor Machines，SVM）是一种常用的二分类模型，其基本思想是构建特征空间上类间间隔最大的超平面，并以此进行分类。</p>
<ul>
<li>本章首先介绍SVM的分类间隔定义，并给出基础SVM的目标函数，以及其对应的凸二次规划问题。</li>
<li>通过使用拉格朗日乘子法，可导出其对偶问题，并给出SVM目标函数的求解方法。</li>
<li>其次，针对基础SVM只能处理线性可分数据的情况，引入软间隔（softmargin）及核方法（kernel method）的概念。<ul>
<li>对于近似线性可分数据，通过引入软间隔来允许SVM在少数样本下不满足约束条件，达到分类的目的。</li>
<li>对于线性不可分数据，可使用核方法，将原始数据空间映射到高维特征空间中，并在高维特征空间下构造最优超平面，实现数据的分类。</li>
</ul>
</li>
<li>最后，将介绍一种快速的启发式学习方法一序列最小优化算法（SMO），该方法是目前较为常用的SVM训练算法。</li>
</ul>
<h3 id="6-1-支持向量机的基本型"><a href="#6-1-支持向量机的基本型" class="headerlink" title="6.1 支持向量机的基本型"></a>6.1 支持向量机的基本型</h3><h4 id="基本分类问题"><a href="#基本分类问题" class="headerlink" title="基本分类问题"></a>基本分类问题</h4><p>给定训练样本集 $D = {(\mathbf{x_1}, y_1), (\mathbf{x_2}, y_2), \dots, (\mathbf{x_m}, y_m)}, \ y_i \in {-1, +1}$ ，分类学习最基本的想法就是：</p>
<ul>
<li>基于训练集 $D$ 在样本空间中找到一个<strong>划分超平面</strong>，将不同类别的样本分开。</li>
</ul>
<p>但正如图6.1所示，能将训练样本分开的划分超平面可能有很多，我们该如何确定<strong>最优分类面</strong>呢？</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211017161917999.png" alt="image-20211017161917999" style="zoom:80%;" />

<p>直观上看，应该去找位于两类样本“正中间”的划分超平面，即图6.1中加粗部分，因为该平面对样本局部扰动的“容忍性”最好。</p>
<ul>
<li>换句话说，我们希望最优分类面不但能将两类样本正确分开，且能够<strong>使分类间隔最大</strong>。</li>
</ul>
<h4 id="间隔与支持向量"><a href="#间隔与支持向量" class="headerlink" title="间隔与支持向量"></a>间隔与支持向量</h4><p>在样本空间中，划分超平面可通过如下线性方程来描述：</p>
<p>$$\begin{align} \mathbf{w^T x} + b = 0 \tag{6.1} \end{align}$$ </p>
<p>其中， $\mathbf{w} = (w_1;w_2;\dots;w_d)$ 为法向量，决定了超平面的方向；$b$ 为位移项，决定了超平面与原点之间的距离。</p>
<p>显然，划分超平面可由法向量 $\mathbf{w}$ 和位移 $b$ 共同确定，我们不妨记为 $(\mathbf{w}, b)$ 。</p>
<p><strong>假设超平面 $(\mathbf{w}, b)$ 能将训练样本正确分类</strong>，即对于某个样本点  $(\mathbf{x}_i, y_i) \in D$ ：</p>
<ul>
<li>若 $y_i = +1$ ，则有  $\mathbf{w^T x}_i + b &gt; 0$ ，即正类样本必在超平面上方；</li>
<li>若 $y_i = -1$ ，则有  $\mathbf{w^T x}_i + b &lt; 0$ ，即负类样本必在超平面下方。</li>
</ul>
<p>不妨令</p>
<p>$$\begin{align} \begin{cases} \mathbf{w^T x_i} + b \geq +1, \ \ y_i = +1; \ \mathbf{w^T x_i} + b \leq -1, \ \ y_i = -1.  \end{cases} \tag{6.2} \end{align}$$</p>
<p>即若超平面 $(\mathbf{w}, b)$ 能将训练样本正确分类，需满足条件 $y_i (\mathbf{w^T x_i} + b) \geq 1$ 。</p>
<blockquote>
<p>易知，若超平面 $(\mathbf{w’}, b’)$ 能将训练样本正确分类 ，则<strong>必定存在线性变换 $\tau \mathbf{w} \rightarrow \mathbf{w’}$ 和 $\tau b \rightarrow b’$ 使得（6.2）式成立</strong>。</p>
<p>这是因为对于任意超平面 $(\mathbf{w’}, b’)$ ，有</p>
<p>$$\begin{align} \begin{cases} \mathbf{w^T x_i} + b \geq +\tau, \ \ y_i = +1; \ \mathbf{w^T x_i} + b \leq -\tau, \ \ y_i = -1.  \end{cases} \end{align}$$</p>
<p>其中 $\tau &gt; 0$ ，进而有</p>
<p>$$\begin{align} \begin{cases} \frac{1}{\tau} \mathbf{w^T x_i} + \frac{1}{\tau} b \geq +1, \ \ y_i = +1; \ \frac{1}{\tau} \mathbf{w^T x_i} + \frac{1}{\tau} b \leq -1, \ \ y_i = -1.  \end{cases} \end{align}$$</p>
<p>因此，不等号后面取1只是为了简化计算。</p>
</blockquote>
<p>那么<strong>如何保证分类间隔最大呢</strong>？我们知道，样本空间中的任意点 $\mathbf{x}$ 到超平面 $(\mathbf{w}, b)$ 的距离可写为</p>
<p>$$\begin{align} r = \frac{|\mathbf{w^T x} + b|}{||\mathbf{w}||} \geq \frac{1}{||\mathbf{w}||} \tag{6.3} \end{align}$$</p>
<p>如图6.2所示，距离超平面最近（被圆圈起来）的这几个样本点使式（6.3）的等号成立，它们被称为<strong>“支持向量”（support vector）</strong>。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211017171440965.png" alt="image-20211017171440965" style="zoom:80%;" />

<p>那么两个异类支持向量到超平面的距离之和为</p>
<p>$$\begin{align} \gamma = \frac{2}{||\mathbf{w}||} \tag{6.4} \end{align} $$</p>
<p>它被称为<strong>“间隔”（margin）</strong>。</p>
<p>欲找到具有<strong>“最大间隔”（maximum margin）</strong>的划分超平面，也就是要找到能满足式（6.2）中约束的参数 $\mathbf{w}$ 和 $b$ ，使得 $\gamma$ 最大，即</p>
<p>$$\begin{align} \max_{w,b} \ \ \frac{2}{||\mathbf{w}||} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s.t. \ \ \ \ y_i(\mathbf{w^T x_i} + b) \geq 1, \ \  i=1,2,\dots,m \ . \tag{6.5} \end{align}$$</p>
<p>显然，为了最大化间隔，仅需最大化 $||\mathbf{w}||^{-1}$ ，这等价于最小化 $||\mathbf{w}||^2$ 。于是，式（6.5）可重写为：</p>
<p>$$\begin{align} \min_{w,b} \ \ \frac{1}{2} ||\mathbf{w}||^2 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s.t. \ \ \ \ y_i(\mathbf{w^T x_i} + b) \geq 1, \ \ i=1,2,\dots,m \ . \tag{6.6} \end{align}$$</p>
<p>这就是<strong>支持向量机（Support Vector Machine，SVM）</strong>的基本型。</p>
<h3 id="6-2-对偶问题"><a href="#6-2-对偶问题" class="headerlink" title="6.2 对偶问题"></a>6.2 对偶问题</h3><h4 id="使用拉格朗日乘子法求对偶问题"><a href="#使用拉格朗日乘子法求对偶问题" class="headerlink" title="使用拉格朗日乘子法求对偶问题"></a>使用拉格朗日乘子法求对偶问题</h4><p>我们希望求解式（6.6）来确定模型参数 $\mathbf{w}$ 和 $b$ ，以得到最优划分超平面：</p>
<p>$$\begin{align} f(\mathbf{x}) = \mathbf{w^T x} + b \tag{6.7} \end{align}$$</p>
<p>注意到式（6.6）本身是一个<strong>凸二次规划（convex quadratic programming）问题</strong>，我们可以使用<strong>拉格朗日乘子法</strong>得到其<strong>“对偶问题”（dual problem）</strong>。</p>
<p>具体来说，对式（6.6）的每条约束添加拉格朗日乘子 $\alpha_i \geq 0$ ，则该问题的拉格朗日函数可写为</p>
<p>$$\begin{align} L(\mathbf{w}, b, \mathbf{\alpha}) = \frac{1}{2}||\mathbf{w}||^2 + \sum_{i=1}^m \alpha_i (1 - y_i(\mathbf{w^T x} + b)) \tag{6.8} \end{align}$$</p>
<p>其中，$\mathbf{\alpha} = (\alpha_1; \alpha_2; \dots; \alpha_m).$ </p>
<p>令 $L(\mathbf{w}, b, \mathbf{\alpha})$ 对 $\mathbf{w}$ 和 $b$ 的偏导数为零可得</p>
<p>$$\begin{align} \mathbf{w} = \sum_{i=1}^m \alpha_i y_i \mathbf{x_i} + b \tag{6.9} \end{align}$$</p>
<p>$$\begin{align} 0 = \sum_{i=1}^m \alpha_i y_i \tag{6.10} \end{align}$$</p>
<p>将式（6.9）代入（6.8），即可将 $L(\mathbf{w}, b, \mathbf{\alpha})$ 中的 $\mathbf{w}$ 和 $b$ 消去，再考虑式（6.10）的约束，就得到式（6.6）的<strong>对偶问题</strong>：</p>
<p>$$\begin{align} \max_{\alpha} \ \ \sum_{i=1}^m \alpha_i - \frac{1}{2} \sum_{i=1}^m\sum_{j=1}^m \alpha_i \alpha_j y_i y_j \mathbf{x^T_i} \mathbf{x_j} \ s.t. \ \ \sum_{i=1}^m \alpha_i y_i = 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \alpha_i \geq 0, \ \ i = 1,2,\dots,m \ . \ \ \ \ \ \ \ \ \ \ \ \ \ \tag{6.11} \end{align}$$</p>
<p>因此，只需求解出 $\alpha$ ，进而可以得到模型</p>
<p>$$\begin{align} f(\mathbf{x}) &amp;= \mathbf{w^T x} + b \ &amp;= \sum_{i=1}^m \alpha_i y_i \mathbf{x_i^T} \ \mathbf{x} + b \tag{6.12} \end{align}$$</p>
<h4 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h4><p>从对偶问题（6.11）解出的 $\alpha_i$ 是式（6.8）中的拉格朗日乘子，它恰对应着训练样本 $(\mathbf{x_i}, y_i)$ 。</p>
<p>注意到式（6.6）中有不等式约束，因此上述过程需满足<strong>KKT（Karush-Kuhn-Tucker）条件</strong>，即要求</p>
<p>$$\begin{align} \begin{cases} \alpha_i \geq 0 \ ; \ y_if(\mathbf{x_i}) - 1 \geq 0 \ ; \ \alpha_i(y_if(\mathbf{x_i}) - 1) = 0 \ . \end{cases} \tag{6.13} \end{align}$$</p>
<blockquote>
<p>式（6.13）中前两项均为拉格朗日乘子约束，第三项为松弛变量约束，只是松弛变量可以通过推导消掉而已。</p>
<p>关于KKT条件的详细推导，见<a href="">「机器学习」拉格朗日乘子法</a>。</p>
</blockquote>
<p>因此，对任一样本点 $(\mathbf{x_i}, y_i)$ ，总有 $\alpha_i = 0$ 或 $y_if(\mathbf{x_i}) = 1$ ：</p>
<ul>
<li>若 $\alpha_i = 0$ ，则该样本不会在式（6.12）中出现，也就<strong>不会对最终的模型 $f(\mathbf{x})$ 有任何影响</strong>；</li>
<li>若 $\alpha_i &gt; 0$ ，则必有 $y_if(\mathbf{x_i}) = 1$ ，即<strong>所对应的样本点位于最大间隔边界上，是一个支持向量</strong>。</li>
</ul>
<p>这显示出支持向量机的一个重要性质：</p>
<ul>
<li>训练完成后，<strong>最终模型仅与支持向量有关</strong>，因而大部分的训练样本都无需保留。</li>
</ul>
<h3 id="6-3-核函数"><a href="#6-3-核函数" class="headerlink" title="6.3 核函数"></a>6.3 核函数</h3><h4 id="核技巧：将低维数据映射到高维空间"><a href="#核技巧：将低维数据映射到高维空间" class="headerlink" title="核技巧：将低维数据映射到高维空间"></a>核技巧：将低维数据映射到高维空间</h4><p>在本章前面的讨论中，我们<strong>假设训练样本是线性可分的</strong>，然而在现实任务中，原始样本空间内可能并不存在一个能正确划分两类样本的超平面。</p>
<p>对这样的问题，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分，如图6.3所示。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211023185042472.png" alt="image-20211023185042472" style="zoom:90%;" />

<p>幸运的是，如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分。</p>
<p>令 $\phi(\mathbf{x})$ 表示将 $\mathbf{x}$ 映射后的特征向量，于是，在特征空间中划分超平面所对应的模型可表示为</p>
<p>$$\begin{align} f(\mathbf{x}) = \mathbf{w^T \phi(x)} + b \tag{6.19} \end{align}$$</p>
<p>那么类似SVM的基本型（6.6），有</p>
<p>$$\begin{align} \min_{w,b} \ \ \frac{1}{2} ||\mathbf{w}||^2 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s.t. \ \ \ \ y_i(\mathbf{w^T \phi(x_i)} + b) \geq 1, \ \ i=1,2,\dots,m \ . \tag{6.20} \end{align}$$</p>
<p>其对偶问题是</p>
<p>$$\begin{align} \max_{\alpha} \ \ \sum_{i=1}^m \alpha_i - \frac{1}{2} \sum_{i=1}^m\sum_{j=1}^m \alpha_i \alpha_j y_i y_j \mathbf{\phi(x_i)^T} \mathbf{\phi(x_j)} \ s.t. \ \ \sum_{i=1}^m \alpha_i y_i = 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \alpha_i \geq 0, \ \ i = 1,2,\dots,m \ . \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \tag{6.21} \end{align}$$</p>
<p>求解式（6.21）涉及到计算 $\mathbf{\phi(x_i)^T} \mathbf{\phi(x_j)}$ ，这是样本 $\mathbf{x_i}$ 与 $\mathbf{x_j}$ 映射到高维特征空间之后的内积。</p>
<ul>
<li>由于特征空间维数可能很高，甚至可能是无穷维，因此直接计算 $\mathbf{\phi(x_i)^T} \mathbf{\phi(x_j)}$ 通常是困难的。</li>
</ul>
<p>为了避开这个障碍，可以设想这样一个函数：</p>
<p>$$\begin{align} \kappa(\mathbf{x_i}, \mathbf{x_j}) = \ &lt; \mathbf{\phi(x_i)^T}, \mathbf{\phi(x_j)} &gt; \  \approx \  \mathbf{\phi(x_i)^T} \mathbf{\phi(x_j)}  \tag{6.22} \end{align}$$</p>
<p>即 $\mathbf{x_i}$ 与 $\mathbf {x_j}$ 在特征空间的内积等于它们在原始样本空间中通过函数 $\kappa(·, ·)$ 计算的结果。</p>
<ul>
<li>这称为<strong>“核技巧”（kernel trick）</strong>，有了这样的函数，我们就不必直接去计算高维甚至无穷维特征空间中的内积。</li>
</ul>
<p>于是式（6.21）可重写为</p>
<p>$$\begin{align} \max_{\alpha} \ \ \sum_{i=1}^m \alpha_i - \frac{1}{2} \sum_{i=1}^m\sum_{j=1}^m \alpha_i \alpha_j y_i y_j \kappa(\mathbf{x^T_i}, \mathbf{x_j}) \ s.t. \ \ \sum_{i=1}^m \alpha_i y_i = 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \alpha_i \geq 0, \ \ i = 1,2,\dots,m \ . \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \tag{6.23} \end{align}$$</p>
<p>求解后即得到</p>
<p>$$\begin{align} f(\mathbf{x}) &amp;= \mathbf{w^T \phi(x)} + b \ &amp;= \sum_{i=1}^m \alpha_i y_i \mathbf{\phi(x_i)^T} \ \mathbf{\phi(x)} + b \ &amp;= \sum_{i=1}^m \alpha_i y_i \kappa(\mathbf{x^T_i}, \mathbf{x_j}) + b \tag{6.24} \end{align}$$</p>
<h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211023192003228.png" alt="image-20211023192003228" style="zoom:80%;" />

<blockquote>
<p>定理6.1表明，只要一个对称函数所对应的核矩阵半正定，它就能作为核函数使用。</p>
<p>事实上，对于一个半正定核矩阵，总能找到一个与之对应的映射。换言之，<strong>任何一个核函数都隐式地定义了一个称为<em>“再生核希尔伯特空间”（Reproducing Kernel Hilbert Space，简称RKHS）</em>的特征空间</strong>。</p>
</blockquote>
<p>通过前面的讨论可知，我们希望样本在特征空间内线性可分，因此<strong>核函数的好坏对支持向量机的性能至关重要</strong>。</p>
<p>表6.1列出了几种常用的核函数：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211023191252962.png" alt="image-20211023191252962" style="zoom:90%;" />

<p>此外，还可通过函数组合得到，例如：</p>
<ul>
<li>若 $\kappa_1$ 和 $\kappa_2$ 为核函数，则对于任意正数 $\gamma_1$ 、$\gamma_2$ ，其线性组合 $\gamma_1 \kappa_1 + \gamma_2 \kappa_2$ 也是核函数；</li>
<li>若 $\kappa_1$ 和 $\kappa_2$ 为核函数，则核函数的直积 $\kappa_1 \otimes \kappa_2 (x,z) = \kappa_1(x, z) \kappa_2(x, z)$ 也是核函数；</li>
<li>若 $\kappa_1$ 为核函数，则对于任意函数 $g(\mathbf{x})$ ，$\kappa(x,z) = g(x) \kappa_1(x,z) g(z)$ 也是核函数.</li>
</ul>
<h3 id="6-4-软间隔"><a href="#6-4-软间隔" class="headerlink" title="6.4 软间隔"></a>6.4 软间隔</h3><h4 id="软间隔支持向量机"><a href="#软间隔支持向量机" class="headerlink" title="软间隔支持向量机"></a>软间隔支持向量机</h4><p>在现实任务中往往很难找到一个超平面将不同类的样本完全划分开，退一步说，即便恰好找到了，也很难断定这不是由于过拟合所造成的。</p>
<p>因此，为了缓解该问题，我们要引入<strong>软间隔</strong>的概念，即<strong>允许支持向量机在一些样本上出错</strong>，如图6.4所示。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211023165802550.png" alt="image-20211023165802550" style="zoom:90%;" />



<p>具体来说，</p>
<ul>
<li><strong>“硬间隔”（hard margin）</strong>要求所有样本均满足约束 $y_i(\mathbf{w^T x_i} + b) \geq 1$ ，即所有样本都必须划分正确；</li>
<li><strong>“软间隔”（soft margin）</strong>则允许某些样本不满足约束  $y_i(\mathbf{w^T x_i} + b) \geq 1$ ，当然不满足约束的样本应尽可能地少。</li>
</ul>
<p>于是，优化目标可改写为</p>
<p>$$\begin{align} \min_{\mathbf{w}, b} \ \ \frac{1}{2} ||\mathbf{w}||^2 \ + \ C \sum_{i=1}^{m} l_{0/1}(y_i(\mathbf{w^T x_i} + b) - 1)  \tag{6.29} \end{align}$$</p>
<p>其中，$C &gt; 0$ 是一个常数，$l_{0/1}$ 是<strong>“0/1损失函数”</strong> </p>
<p>$$\begin{align}  l_{0/1}(z) = \begin{cases} 1, \text{   if   } z &lt; 0; \ 0, \text{   otherwise.}   \end{cases} \tag{6.30} \end{align}$$</p>
<p>显然，</p>
<ul>
<li><p>当 $C$ 无穷大时，式（6.29）就迫使 $l_{0/1}$ 损失函数的值为0，即<strong>每个样本点 $x_i$ 均需满足约束</strong> $y_i(\mathbf{w^T x_i} + b) - 1 \geq 0$ ；</p>
</li>
<li><p>当 $C$ 取有限值时，式（6.29）允许一些样本不满足约束.</p>
</li>
</ul>
<p>然而，$l_{0/1}$ 非凸、非连续，数学性质不太好，使得式（6.29）不易直接求解。</p>
<p>于是，人们通常用其他一些具有较好数学性质的函数来作为<strong>“替代损失”（surrogate loss）</strong>，图6.5给出了三种常用的替代损失函数：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211023175445138.png" alt="image-20211023175445138" style="zoom:90%;" />

<p>它们的数学表达形式如下：</p>
<p>$$\begin{align} \text{hinge 损失：  } l_{hinge}(z) = \max(0, 1 - z)  \tag{6.31} \end{align}$$</p>
<p>$$\begin{align} \text{指数损失（exponential loss）：  } l_{exp}(z) = \exp(- z)  \tag{6.32} \end{align}$$</p>
<p>$$\begin{align} \text{对率损失（logistic loss）：  } l_{log}(z) = \log(1 + \exp(-z))  \tag{6.33} \end{align}$$</p>
<p>若采用 hinge 损失，则式（6.29）的优化目标就变成</p>
<p>$$\begin{align} \min_{\mathbf{w}, b} \ \ \frac{1}{2} ||\mathbf{w}||^2 \ + \ C \sum_{i=1}^{m} \max \  (0,\   1 - y_i(\mathbf{w^T x_i} + b))  \tag{6.34} \end{align}$$</p>
<p>如果我们引入<strong>“松弛变量”（slack variables）</strong> $\xi_i \geq 0$ ，可将式（6.34）重写为</p>
<p>$$\begin{align} \min_{\mathbf{w}, b} \ \ \frac{1}{2} ||\mathbf{w}||^2 \ + \ C \sum_{i=1}^{m} \xi_i \ \ \ \ \ \ \ \  \ s.t. \ \ y_i(\mathbf{w^T x_i} + b) \geq 1 - \xi_i \ \ \  \ \xi_i \geq 0, \ \ i = 1,2,\dots,m \ . \tag{6.35} \end{align}$$</p>
<p>显然，式（6.35）中每个样本都有一个对应的松弛变量，用以表征该样本不满足约束的程度，这就是常用的<strong>“软间隔支持向量机”</strong>。。</p>
<h4 id="软间隔支持向量机的对偶问题"><a href="#软间隔支持向量机的对偶问题" class="headerlink" title="软间隔支持向量机的对偶问题"></a>软间隔支持向量机的对偶问题</h4><p>式（6.35）仍是一个二次规划问题。于是，类似式（6.8），通过拉格朗日乘子法可得到式（6.35）的拉格朗日函数</p>
<p>$$\begin{align} L(\mathbf{w}, b, \mathbf{\alpha}, \mathbf{\xi}, \mathbf{\mu}) &amp;= \ \ \frac{1}{2} ||\mathbf{w}||^2 \ + \ C \sum_{i=1}^{m} \xi_i \ &amp;+ \sum_{i=1}^m \alpha_i (1 - \xi_i - y_i(\mathbf{w^T x_i} + b)) - \sum_{i=1}^m  \mu_i \xi_i \tag{6.36} \end{align}$$</p>
<p>其中，$\alpha_i \geq 0$ ，$\mu_i \geq 0$ 是拉格朗日乘子。</p>
<p>我们令 $L(\mathbf{w}, b, \mathbf{\alpha}, \mathbf{\xi}, \mathbf{\mu})$ 对 $\mathbf{w}, b, \xi_i$ 的偏导数为零可得</p>
<p>$$\begin{align} \mathbf{w} = \sum_{i=1}^m \alpha_i y_i \mathbf{x_i}  \tag{6.37} \end{align}$$</p>
<p>$$\begin{align} 0 = \sum_{i=1}^m \alpha_i y_i \tag{6.38} \end{align}$$</p>
<p>$$\begin{align} C = \alpha_i + \mu_i  \tag{6.39} \end{align}$$</p>
<p>将式（6.37）-（6.39）代入式（6.36）即可得到式（6.35）的对偶问题</p>
<p>$$\begin{align} \max_{\alpha} \ \ \sum_{i=1}^m \alpha_i - \frac{1}{2} \sum_{i=1}^m\sum_{j=1}^m \alpha_i \alpha_j y_i y_j \mathbf{x^T_i} \mathbf{x_j} \ s.t. \ \ \sum_{i=1}^m \alpha_i y_i = 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0 \leq \alpha_i \leq C, \ \ i = 1,2,\dots,m \ . \ \ \ \ \ \tag{6.40} \end{align}$$</p>
<p>将软间隔下的对偶问题（6.40）与硬间隔下的对偶问题（6.11）对比可看出，</p>
<ul>
<li><strong>两者唯一的差别就在于对偶变量的约束不</strong>同：前者是 $0 \leq \alpha_i \leq C$，后者是 $0 \leq \alpha_i$ </li>
</ul>
<p>于是，同样可采用SMO算法求解式（6.40）。</p>
<p>类似式（6.13），对软间隔支持向量机，KKT条件要求</p>
<p>$$\begin{align} \begin{cases} \alpha_i \geq 0 \ , \mu_i \geq 0 \ ; \ y_if(\mathbf{x_i}) - 1 + \xi_i \geq 0 \ ; \ \alpha_i(y_if(\mathbf{x_i}) - 1 + \xi_i) = 0 \ ; \ \xi_i \geq 0, \ \mu_i \xi_i = 0 \ . \end{cases} \tag{6.41} \end{align}$$</p>
<p>因此，对任一样本点 $(\mathbf{x_i}, y_i)$ ，总有 $\alpha_i = 0$ 或 $y_if(\mathbf{x_i}) = 1 - \xi_i$ ：</p>
<ul>
<li>若 $\alpha_i = 0$ ，则该样本<strong>不会对最终的模型 $f(\mathbf{x})$ 有任何影响</strong>；</li>
<li>若 $\alpha_i &gt; 0$ ，则必有 $y_if(\mathbf{x_i}) = 1 -\xi_i$ ，即<strong>该样本是一个支持向量</strong>，此时由式（6.39） $C = \alpha_i + \mu_i$ 可知：<ul>
<li>若 $\alpha_i &lt; C$ ，则 $\mu_i &gt; 0$ ，进而有 $\xi_i = 0$ ，即该样本恰在最大间隔边界上；</li>
<li>若 $\alpha_i = C$ ，则 $\mu_i = 0$ ，此时若 $\xi_i \leq 1$ 则该样本落在最大间隔内部，若 $\xi_i &gt; 1$ 则该样本被错误分类。</li>
</ul>
</li>
</ul>
<p>由此可看出，<strong>软间隔支持向量机的最终模型仍仅与支持向量有关</strong>，即通过采用hinge损失函数仍保持了<strong>稀疏性</strong>。</p>
<h3 id="6-5-序列最小优化算法"><a href="#6-5-序列最小优化算法" class="headerlink" title="6.5 序列最小优化算法"></a>6.5 序列最小优化算法</h3><p>如前文所述，支持向量机的训练过程可表示为求解具有最优解的<strong>凸二次规划问题</strong>，许多通用算法均可求解此类问题。</p>
<p>然而，<strong>该问题的规模正比于训练样本数</strong>，当训练数据集样本量较大时会带来很大的开销，导致效率较低，甚至无法使用。</p>
<p>为了缓解这个问题，人们提出了很多高效算法，<strong>序列最小化优化方法（Sequential Minimal Optimization, SMO）</strong>是其中一个著名的代表。</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>SMO算法是一种启发式学习算法，其主要思想是</p>
<ul>
<li>将一个复杂的二次规划问题分解为多个只有两个变量的二次规划子问题，并通过求解子问题来解决原始问题。</li>
</ul>
<p>算法将检查当前是否仍存在未满足KKT条件的变量，若有，则选取两个变量（至少有一个不满足KKT条件）作为当前问题的待优化目标，固定其他变量，在此基础上求得优化目标的解析解。当所有变量的KKT条件均得到满足，原问题的就得到了。</p>
<p>这样，在参数初始化后，SMO不断执行如下两个步骤直至收敛：</p>
<ol>
<li>使用启发式方法选取一对需要更新的变量 $\alpha_i$ 和 $\alpha_j$ ；</li>
<li>固定 $\alpha_i$ 和 $\alpha_j$ 以外的参数，求解两个变量 $\alpha_i$ 和 $\alpha_j$ 二次规划的解析方法。</li>
</ol>
<h4 id="使用启发式方法选取待优化变量-alpha-i-和-alpha-j"><a href="#使用启发式方法选取待优化变量-alpha-i-和-alpha-j" class="headerlink" title="使用启发式方法选取待优化变量 $\alpha_i$ 和 $\alpha_j$"></a>使用启发式方法选取待优化变量 $\alpha_i$ 和 $\alpha_j$</h4><p>注意到只需选取的 $\alpha_i$ 和 $\alpha_j$ 中有一个不满足KKT条件（6.13），目标函数就会在迭代后减小【Osuna et al，1997】。直观来看，KKT条件违背的程度越大，则变量更新后可能导致的<strong>目标函数值减幅越大</strong>。于是，</p>
<ul>
<li>SMO先选取一个违背KKT条件程度最大的变量作为 $\alpha_i$ ；</li>
</ul>
<p>第二个变量应选择一个<strong>使目标函数值减小最快</strong>的变量，但由于比较各变量所对应的目标函数值减幅的复杂度过高，因此SMO采用了一个<strong>启发式方法</strong>：</p>
<ul>
<li>使选取的两个变量所对应样本之间的间隔最大，从而确定 $\alpha_j$ .</li>
</ul>
<blockquote>
<p>一种直观的解释是，这样的两个变量有很大的差别，与对两个相似的变量进行更新相比，对它们进行更新会带给目标函数值更大的变化。</p>
</blockquote>
<h4 id="使用解析法计算-alpha-i-和-alpha-j-的最优解并确定偏移项-b"><a href="#使用解析法计算-alpha-i-和-alpha-j-的最优解并确定偏移项-b" class="headerlink" title="使用解析法计算 $\alpha_i$ 和 $\alpha_j$ 的最优解并确定偏移项 $b$"></a>使用解析法计算 $\alpha_i$ 和 $\alpha_j$ 的最优解并确定偏移项 $b$</h4><p>当我们仅考虑 $\alpha_i$ 和 $\alpha_j$ 时，SVM的对偶问题（6.11）中的约束可重写为</p>
<p>$$\begin{align} \alpha_iy_i + \alpha_jy_j = c, \ \ \alpha_i \geq 0, \ \ \alpha_j \geq 0  \tag{6.42} \end{align}$$</p>
<p>其中，$c = - \sum_{k \ne i,j} \alpha_ky_k$ 是使得约束 $\sum_{i=1}^m \alpha_i y_i = 0$ 成立的常数。</p>
<p>我们可以用式（6.42）消去式（6.11）中的变量 $\alpha_j$，则得到一个<strong>关于 $\alpha_i$ 的单变量二次规划问题</strong>，仅有的约束是 $\alpha_i \geq 0$ .</p>
<p>不难发现，这样的二次规划问题具有闭式解，于是不必调用数值优化算法即可高效地计算出更新后的 $\alpha_i$ 和 $\alpha_j$ .</p>
<p>那么如何确定偏移项 $b$ 呢？注意到对任意支持向量 $(\mathbf{x_s}, y_s)$ 都有 $y_s f(\mathbf{x_s}) = 1$，即</p>
<p>$$\begin{align} y_s (\sum_{i \in S} \alpha_i y_i \mathbf{x_i^T x_s} + b) = 1 \tag{6.43} \end{align}$$</p>
<p>其中 $S$ 为所有支持向量的下标集。</p>
<p>理论上，可选取任意支持向量并通过求解式（6.43）获得 $b$ ，但现实任务中常采用一种更鲁棒的做法：</p>
<ul>
<li>使用所有支持向量求解的平均值</li>
</ul>
<p>$$\begin{align} b =  \frac{1}{|S|} \sum_{s \in S} ( y_s - \sum_{i \in S} \alpha_i y_i \mathbf{x_i^T x_s}) \tag{6.44} \end{align}$$</p>
<blockquote>
<p>关于SMO算法更加具体的证明与实现，可参考《数据挖掘导论》的课件《SVM-utf8》.</p>
</blockquote>
<ul>
<li><h3 id="6-6-支持向量回归（SVR）"><a href="#6-6-支持向量回归（SVR）" class="headerlink" title="6.6 支持向量回归（SVR）"></a>6.6 支持向量回归（SVR）</h3></li>
<li><h3 id="6-7-核方法"><a href="#6-7-核方法" class="headerlink" title="6.7 核方法"></a>6.7 核方法</h3></li>
</ul>
<h3 id="6-8-思考与归纳"><a href="#6-8-思考与归纳" class="headerlink" title="6.8 思考与归纳"></a>6.8 思考与归纳</h3><ul>
<li>SVM考虑寻找一个满足分类要求的超平面，并且使训练集中的点距离分类面尽可能的远，也就是寻找一个分类面使它两侧的空白区域（Margin）最大。</li>
<li>核函数解决的是在原始空间线性不可分的情况，将数据映射到高维特征空间。</li>
<li>软间隔SVM是一种正则化操作。</li>
</ul>
<h2 id="第7章-贝叶斯分类器"><a href="#第7章-贝叶斯分类器" class="headerlink" title="第7章 贝叶斯分类器"></a>第7章 贝叶斯分类器</h2><h3 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a>7.1 贝叶斯决策论</h3><p>贝叶斯决策论（Bayesian decision theory）是概率框架下实施决策的基本方法。</p>
<p>对分类任务来说，<strong>在所有相关概率都已知的理想情形下</strong>，贝叶斯决策论考虑<strong>如何基于这些概率和误判损失来选择最优的类别标记</strong>。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>下面我们以多分类任务为例来解释其基本原理。</p>
<ul>
<li><p>假设输入空间 $\chi \subseteq R^n$ 为 $n$ 维向量的集合，输出空间 $\gamma = {c_1，c_2, \dots, c_N }$ 有 $N$ 种可能的类别标记；</p>
</li>
<li><p>$X$ 和 $Y$ 分别是定义在输入空间 $\chi$ 和输出空间 $\gamma$ 上的随机变量； </p>
</li>
<li><p>$\lambda_{ij}$ 是将一个真实类别为 $c_j$ 的样本误分类为 $c_i$ 所产生的损失；</p>
</li>
<li><p><strong>后验概率 $P(Y = c_i | X = x )$</strong> 表示样本 $\mathbf{x} = (x_1, \dots, x_n)$ 为 $c_i$ 的概率，即观察到 $X$ 的各项属性值为 $(X_1 = x_1, \dots, X_n = x_n)$ 时，随机变量 $Y = c_i$ 的概率。</p>
<blockquote>
<p>注：为方便书写公式，后面将省略随机变量。</p>
</blockquote>
</li>
</ul>
<p>那么我们基于<strong>后验概率 $P(c_i | x )$</strong> 便可获得将样本 $x$ 分类为 $c_i$ 所产生的<strong>期望损失（expected loss）</strong>，亦即在样本上的<strong>“条件风险”（conditional risk）</strong></p>
<p>$$\begin{align} R(c_i | x) = \sum_{j=1}^N \lambda_{ij} P(c_j | x) \tag{7.1} \end{align} $$</p>
<blockquote>
<p>上述公式表明了，$x$ 的类别为 $c_j$ 的概率，以及当 $x$ 为 $c_j$ 时，将其错判为 $c_i$ 时的损失，然后对所有可能结果求和。</p>
<p>注：决策论中将“期望损失”称为“风险”(risk).</p>
</blockquote>
<p>我们的任务是<strong>寻找一个判定准则 $h : \chi \rarr \gamma$ 以最小化总体风险</strong></p>
<p>$$\begin{align} R(h) = \mathbb{E}_x [R(h(x)|x)] \tag{7.2} \end{align} $$</p>
<p>显然，对每个样本 $x$ ，若 $h$ 能最小化条件风险  $R(h(x) | x)$ ，则总体风险 $R(h)$ 也将被最小化。</p>
<p>这就产生了<strong>贝叶斯判定准则（Bayes decision rule）</strong>：</p>
<ul>
<li>为最小化总体风险，只需在每个样本上选择那个能使条件风险 $R(c|x)$ 最小的类别标记，即</li>
</ul>
<p>$$\begin{align} h^*(x) = \arg \min_{c \in \gamma} R(c | x) \tag{7.3} \end{align} $$</p>
<p>此时，$h^*$ 称为<strong>贝叶斯最优分类器（Bayes optimal classifier）</strong>，与之对应的总体风险 $R(h^*)$ 称为<strong>贝叶斯风险（Bayes risk）</strong>， $1 - R(h^*)$ 反映了分类器所能达到的<strong>最好性能</strong>，即通过机器学习所能产生的模型精度的理论上限。</p>
<p>具体来说，若目标是<strong>最小化分类错误率</strong>，则误判损失 $\lambda_{ij}$ 可写为</p>
<p>$$\begin{align} \lambda_{ij} = \begin{cases} 0, \text{  if $i = j$;} \ 1, \text{ otherwise} \end{cases} \tag{7.4} \end{align} $$</p>
<p>此时代入式（7.1）得到条件风险为</p>
<p>$$\begin{align} R(c | x) = 1 - P(c | x) \tag{7.5} \end{align} $$</p>
<blockquote>
<p>即把样本 $x$ 分类为 $c$ 的期望损失，可由对应的后验概率描述。</p>
</blockquote>
<p>于是，最小化分类错误率的贝叶斯最优分类器为</p>
<p>$$\begin{align} h^*(x) = \arg \max_{c \in \gamma} P(c | x) \tag{7.6} \end{align} $$</p>
<p>即<strong>对每个样本 $x$ ，选择能使后验概率 $P(c|x)$ 最大的类别标记</strong>。</p>
<h4 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h4><p>不难看出，欲使用贝叶斯判定准则来最小化决策风险，首先要获得后验概率 $P(c | x)$ 。</p>
<p>大体来说，主要有两种策略：</p>
<ol>
<li>给定 $\mathbf{x}$，通过直接建模 $P(c | \mathbf{x})$ 来预测类别 $c$，这样得到的是“<strong>判别式模型”（discriminative models）</strong>，如决策树、BP神经网络、支持向量机等；</li>
<li>也可先对联合概率分布 $P(\mathbf{x},c)$ 建模，然后再由此获得 $P(c | \mathbf{x})$ ，这样得到的是<strong>“生成式模型”（generative models）</strong>.</li>
</ol>
<p>对于生成式模型来说，基于贝叶斯定理，有</p>
<p>$$\begin{align} P(c|\mathbf{x}) = \frac{P(\mathbf{x},c)}{P(\mathbf{x})} = \frac{P(c)P(\mathbf{x}|c)}{P(\mathbf{x})} = \frac{P(c)P(\mathbf{x}|c)}{\sum_{c \in \gamma} P(c)P(\mathbf{x}|c)} \tag{7.8} \end{align}$$</p>
<p>其中，</p>
<ul>
<li>$P(c)$ 是类“先验”（prior）概率；</li>
<li>$P(\mathbf{x} | c)$  是样本 $x$ 相对于类标记 $c$ 的<strong>类条件概率</strong>（class-conditional probability），或<strong>似然（likelihood）</strong>；</li>
<li>$P(\mathbf{x})$ 是用于<strong>归一化</strong>的“证据”（evidence）因子，可使用全概率公式求得。</li>
</ul>
<p>因此估计后验概率 $P(c | x)$ 的问题就转化为<strong>如何基于训练数据 $D$ 来估计先验 $P(c)$ 和类条件概率 $P(\mathbf{x} | c)$</strong> 。</p>
<blockquote>
<ul>
<li><p>这里可能不太好理解，我们举个例子来说明：</p>
<p>假设某人感染了新冠病毒，那么其核酸检测呈阳性的概率为 95%；如果未感染病毒，则阳性的概率为 1%（这也称为类条件概率）。</p>
<p>此外如果我们有先验知识，整个人群中感染此病毒的人数为10%左右，即 $P(感染) = 0.1$ 。</p>
<p>现在有一个人结果为阳性，问这个人感染病毒了吗？</p>
</li>
</ul>
<ul>
<li><p>在这个问题中，「核酸检测是否为阳性」是样本 $x$ 的属性，而「是否感染病毒」则是我们要预测的类别 $c$ 。</p>
<p>那么按照贝叶斯决策理论，有：</p>
<p>$$\begin{align} \displaystyle P(感染|核酸检测阳性) &amp;= \frac{P(核酸检测为阳性且感染了新冠病毒)}{P(核酸检测阳性)} \ &amp;= \frac{P(感染) P(阳性|感染)}{P(感染) P(阳性|感染) + P(未感染) P(阳性|未感染)} \ &amp;= \frac{0.1 \times 0.95}{0.1 \times 0.95 + 0.9 \times 0.01} = 0.51 \end{align}$$ </p>
</li>
</ul>
</blockquote>
<ul>
<li>类先验概率 $P(c)$ 表达了样本空间中各类样本所占的比例，根据大数定律，当训练集包含充足的<strong>独立同分布</strong>样本时，$P(c)$ 可通过各类样本出现的频率来进行估计。</li>
<li>对类条件概率 $P(\mathbf{x} | c)$ 来说，由于它涉及关于 $\mathbf{x}$ 所有属性的联合概率，直接根据样本出现的频率来估计将会遇到严重的困难，下面介绍一种估计策略。</li>
</ul>
<h3 id="7-2-极大似然估计"><a href="#7-2-极大似然估计" class="headerlink" title="7.2 极大似然估计"></a>7.2 极大似然估计</h3><p>估计类条件概率的一种常用策略是<strong>先假定其具有某种确定的概率分布形式</strong>，再<strong>基于训练样本对概率分布的参数进行估计</strong>。</p>
<p>具体地，假设类别 $c$ 的类条件概率 $P(\mathbf{x} | c)$ 具有确定的形式并且被参数向量 $\theta_c$ 唯一确定，则我们的任务就是利用训练集 $D$ 估计参数 $\theta_c$ 。</p>
<blockquote>
<p>为明确起见，我们将 $P(\mathbf{x} | c)$ 记为 $P(\mathbf{x} | \theta_c)$ .</p>
</blockquote>
<p>事实上，概率模型的训练过程就是<strong>参数估计（parameter estimation）</strong>过程。</p>
<p>对于参数估计，统计学界的两个学派分别提供了不同的解决方案：</p>
<ul>
<li><strong>频率主义学派</strong>（Frequentist）认为参数虽然未知，但却是<strong>客观存在的固定值</strong>，因此，可通过优化似然函数等准则来确定参数值；</li>
<li><strong>贝叶斯学派</strong>（Bayesian）则认为参数是未观察到的随机变量，其<strong>本身也可有分布</strong>，因此，可假定参数服从一个先验分布，然后基于观测到的数据来计算参数的后验分布。</li>
</ul>
<p>本节源自频率主义学派的<strong>极大似然估计</strong>（Maximum Likelihood Estimation，简称MLE），这是<strong>根据数据采样来估计概率分布参数</strong>的经典方法。</p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>令 $D_c$ 表示训练集 $D$ 中第 $c$ 类样本组成的集合，假设这些样本是<strong>独立同分布</strong>的，则参数 $\theta_c$ 对于数据集 $D_c$ 的似然是</p>
<p>$$\begin{align} P(D_c | \theta_c) = \prod_{x \in D_c} P(x | \theta_c) \tag{7.9} \end{align}$$</p>
<p>对 $\theta_c$ 进行极大似然估计，就是去<strong>寻找能最大化似然 $P(D_c | \theta_c)$ 的参数值</strong>。</p>
<ul>
<li>直观上看，极大似然估计是试图在 $\theta_c$ 所有可能的取值中，<strong>找到一组能使数据出现的“可能性”最大的参数值</strong>。</li>
</ul>
<p>又因为式（7.9）中的连乘操作易造成下溢，通常使用<strong>对数似然（log-likelihood）</strong></p>
<p>$$\begin{align} LL(\theta_c) &amp;= \log P(D_c | \theta_c) \ &amp;= \sum_{x \in D_c} \log P(x | \theta_c)  \tag{7.10} \end{align}$$</p>
<p>此时，参数 $\theta_c$ 的极大似然估计 $\hat{\theta}_c$ 为</p>
<p>$$\begin{align} \hat{\theta}<em>c = \arg \max</em>{\theta_c} LL(\theta_c) \tag{7.11} \end{align}$$</p>
<p>例如，在<strong>连续属性</strong>情形下，假设概率密度函数服从正态分布 $p(\mathbf{x} | c) \ ～ \ N(\mathbf{\mu}_c, \mathbf{\sigma}_c^2)$ ，则参数 $\mu_c$ 和 $\sigma_c^2$ 的极大似然估计为</p>
<p>$$\begin{align} \mu_c = \frac{1}{|D_c|} \sum_{x \in D_c} \mathbf{x} \tag{7.12} \end{align}$$</p>
<p>$$\begin{align} \sigma_c^2 = \frac{1}{|D_c|} \sum_{x \in D_c} (\mathbf{x} - \hat{\mu}_c )(\mathbf{x} - \hat{\mu}_c)^T \tag{7.13} \end{align}$$</p>
<p>也就是说，通过极大似然法得到的正态分布均值就是样本均值，方差就是 $(\mathbf{x} - \hat{\mu}_c )(\mathbf{x} - \hat{\mu}_c)^T$ 的均值，这显然是一个符合直觉的结果。</p>
<p>在<strong>离散属性</strong>情形下，也可通过类似的方式估计类条件概率。</p>
<blockquote>
<ul>
<li><p>在上面的例子中，如果按照极大似然估计进行决策，则有：</p>
<p>既然感染了病毒出现阳性的概率为95%（P(x|c)），没感染出现阳性的概率只有1%，本着谁大像谁的原则，那我们认为这个人已经感染了病毒。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>需注意的是，这种参数化的方法虽能使类条件概率估计变得相对简单，但估计结果的准确性<strong>严重依赖于所假设的概率分布形式是否符合潜在的真实数据分布</strong>。</p>
<p>在现实应用中，欲做出能较好地接近潜在真实分布的假设，往往需在一定程度上利用关于应用任务本身的经验知识，否则若仅凭“猜测”来假设概率分布形式，很可能产生误导性的结果。</p>
</blockquote>
<h3 id="7-3-朴素贝叶斯分类器"><a href="#7-3-朴素贝叶斯分类器" class="headerlink" title="7.3 朴素贝叶斯分类器"></a>7.3 朴素贝叶斯分类器</h3><h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>不难发现，基于贝叶斯公式（7.8）来估计后验概率 $P(c|x)$ 的主要困难在于：</p>
<ul>
<li>类条件概率 $P(x|c)$ 是<strong>所有属性上的联合概率</strong>，难以从有限的训练样本直接估计而得。</li>
</ul>
<blockquote>
<p>基于有限训练样本直接估计联合概率，在计算上将会遭遇组合爆炸问题，在数据上将会遭遇样本稀疏问题，属性数越多，问题越严重。</p>
</blockquote>
<p>为避开这个障碍，<strong>朴素贝叶斯分类器（naive Bayes classifier）</strong>采用了<strong>“属性条件独立性假设”</strong>（attribute conditional independence assumption）：</p>
<ul>
<li>对已知类别，假设所有属性相互独立，换言之，假设每个属性独立地对分类结果发生影响。</li>
</ul>
<p>基于属性条件独立性假设，式（7.8）可重写为</p>
<p>$$\begin{align} P(c|x) = \frac{P(c)P(x|c)}{P(x)} = \frac{P(c)}{Px} \prod_{i=1}^n P(x_i | c) \tag{7.14} \end{align}$$</p>
<p>其中，$n$ 为属性数目，$x_i$ 为样本 $\mathbf{x}$ 在第 $i$ 个属性上的取值。</p>
<p>由于对所有类别来说 $P(x)$ 相同，因此基于式（7.6）的贝叶斯判定准则有</p>
<p>$$\begin{align} h_{nb}(x) = \arg \max_{c \in \gamma} \ P(c) \prod_{i=1}^n P(x_i | c) \tag{7.15} \end{align} $$</p>
<p>这就是<strong>朴素贝叶斯分类器的表达式</strong>。</p>
<h4 id="估计先验概率与类条件概率"><a href="#估计先验概率与类条件概率" class="headerlink" title="估计先验概率与类条件概率"></a>估计先验概率与类条件概率</h4><p>令 $D_c$ 表示训练集 $D$ 中第 $c$ 类样本组成的集合，若有充足的独立同分布样本，则可容易地估计出类先验概率</p>
<p>$$\begin{align} P(c) = \frac{|D_c|}{| D |} \tag{7.16} \end{align} $$</p>
<p>对类条件概率而言，</p>
<ul>
<li>对离散属性，令 $D_{c, x_i}$ 表示 $D_c$ 中在第 $i$ 个属性上取值为 $x_i$ 的样本组成的集合，则条件概率 $P(x_i | c)$ 可估计为</li>
</ul>
<p>​    $$\begin{align} P(x_i | c) = \frac{|D_{c, x_i}|}{| D_c|} \tag{7.17} \end{align} $$</p>
<ul>
<li><p>对连续属性则可考虑概率密度函数，假定 $p(x_i | c) \ ～ \ N(\mu_{c,i}, \sigma^2_{c, i})$ ，其中参数 $\mu_{c, i}$ 和 $\sigma_{c, i}^2$ 分别是第 $c$ 类样本在第 $i$ 个属性上取值的均值和方差，则有</p>
<p>$$\begin{align} p(x_i|c) = \frac{1}{\sqrt{2 \pi} \sigma_{c,i}} \exp (- \frac{(x_i - \mu_{c,i})^2}{2 \sigma^2_{c,i}}) \tag{7.18} \end{align} $$</p>
</li>
</ul>
<p>需注意，若某个属性值在训练集中没有与某个类同时出现过，则直接基于式（7.17）进行概率估计，再根据式（7.15）进行判别将出现问题：</p>
<ul>
<li>由于式（7.15）的连乘式计算出的概率值为零，因此，无论该样本的其他属性是什么，哪怕在其他属性上明显像好瓜，分类的结果都将是“好瓜=否”，这显然不太合理。</li>
</ul>
<p>为了避免其他属性携带的信息被训练集中未出现的属性值“抹去”，在估计概率值时通常要进行<strong>“平滑”（smoothing）</strong>，常用<strong>“拉普拉斯修正”</strong>（Laplacian correction）。</p>
<p>具体来说，令 $N$ 表示训练集 $D$ 中可能的类别数，$N_i$ 表示第 $i$ 个属性可能的取值数，则式（7.16）和（7.17）分别修正为</p>
<p>$$\begin{align} \hat{P}(c) = \frac{|D_c| + 1}{| D | + N} \tag{7.19} \end{align} $$</p>
<p>$$\begin{align} \hat{P}(x_i | c) = \frac{|D_{c, x_i}| + 1}{| D_c|+N_i} \tag{7.20} \end{align} $$</p>
<h4 id="半朴素贝叶斯分类器"><a href="#半朴素贝叶斯分类器" class="headerlink" title="半朴素贝叶斯分类器"></a>半朴素贝叶斯分类器</h4><p>为了降低贝叶斯公式（7.8）中估计后验概率 $P(c|x)$ 的困难，朴素贝叶斯分类器采用了<strong>属性条件独立性假设</strong>，但在现实任务中这个假设往往很难成立，于是，人们尝试<strong>对属性条件独立性假设进行一定程度的放松</strong>，由此产生了一类称为<strong>“半朴素贝叶斯分类器”</strong>（semi-naive Bayes classifiers）的学习方法。</p>
<p>具体不再详细介绍.</p>
<h3 id="7-5-贝叶斯网"><a href="#7-5-贝叶斯网" class="headerlink" title="7.5 贝叶斯网"></a>7.5 贝叶斯网</h3><p><strong>贝叶斯网</strong>（Bayesian network）亦称“信念网”（belief network），它借助<strong>有向无环图</strong>（Directed Acyclic Graph，简称DAG）来刻画属性之间的依赖关系，并使用<strong>条件概率表</strong>（Conditional Probability Table，简称CPT）来描述属性的<strong>联合概率分布</strong>。</p>
<blockquote>
<p>为了简化讨论，本节假定所有属性均为离散型；对于连续属性，条件概率表可推广为条件概率密度函数。</p>
</blockquote>
<p>具体来说，一个贝叶斯网 $B$ 由结构 $G$ 和参数 $\Theta$ 两部分构成，即 $B = (G, \Theta)$ . </p>
<ul>
<li>网络结构 $G$ 是一个有向无环图，其每个结点对应于一个属性，若两个属性有直接依赖关系，则它们由一条边连接起来；</li>
<li>参数 $\Theta$​ 定量描述这种依赖关系，假设属性 $x_i$ 在 $G$ 中的<strong>父结点集为 $\pi_i$</strong> ，则 $\Theta$ 包含了每个属性的条件概率表 $\theta_{x_i|\pi_i} = P_B(x_i|\pi_i)$.</li>
</ul>
<p>举例来说，图7.2给出了西瓜问题的一种贝叶斯网结构和属性“根蒂”的条件概率表.</p>
<p>从图中网络结构可看出：</p>
<ul>
<li>“色泽”直接依赖于“好瓜”和“甜度”；</li>
<li>而“根蒂”则直接依赖于“甜度”；</li>
<li>进一步从条件概率表能得到“根蒂”对“甜度”量化依赖关系，如 $P(根蒂=硬挺|甜度=高)=0.1$ 等。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20220101021100456.png" alt="image-20220101021100456" style="zoom:80%;" />



<h4 id="7-5-1-结构（重点掌握）"><a href="#7-5-1-结构（重点掌握）" class="headerlink" title="7.5.1 结构（重点掌握）"></a>7.5.1 结构（重点掌握）</h4><blockquote>
<p>重点掌握：</p>
<ol>
<li>贝叶斯网中的三种依赖关系</li>
<li>如何从道德图中找到所有条件独立关系</li>
</ol>
</blockquote>
<p>从上图可以看出，<strong>贝叶斯网结构有效地表达了属性间的条件独立性</strong>。</p>
<p>给定父结点集，贝叶斯网<strong>假设每个属性与它的非后裔属性独立</strong>，于是 $B = (G, \Theta)$ 将属性 $x_1, x_2, \dots, x_d$ 的联合概率分布定义为</p>
<p>$$\begin{align} P_B(x_1, x_2, \dots, x_d) = \prod_{i=1}^d P_B(x_i|\pi_i) = \prod_{i=1}^d \theta_{x_i|\pi_i}  \tag{7.26} \end{align}$$</p>
<p>以图7.2为例，其联合概率分布为</p>
<p>$$\begin{align} P(x_1, x_2, x_3, x_4, x_5) = P(x_1) P(x_2) P(x_3|x_1) P(x_4|x_1,x_2) P(x_5|x_2) \end{align} $$ </p>
<p>显然，$x_3$ 和 $x_4$ 在给定 $x_1$ 的取值时是独立的，而 $x_4$ 和 $x_5$ 在给定 $x_2$ 的取值时独立，我们分别简记为 $x_3 \perp x_4 \ |\  x_1$ 和 $x_4 \perp x_5 \ | \ x_2 $ 。</p>
<p>这称为同父结构，除此之外，贝叶斯网中三个变量之间的典型依赖关系还有V型结构和顺序结构，如图7.3，其中前两种在式（7.26）中已有所体现。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20220101144458598.png" alt="image-20220101144458598" style="zoom:80%;" />

<ul>
<li><p><strong>“同父”</strong>（common parent）结构：给定父结点 $x_1$ 的取值，则 $x_3$ 与 $x_4$ 条件独立；</p>
</li>
<li><p><strong>“顺序”</strong>结构：给定 $x$ 的值，则 $y$ 与 $z$ 条件独立；</p>
</li>
<li><p><strong>“V型”</strong>结构（V-structure）亦称“冲撞”结构：</p>
<ul>
<li><p>给定子结点 $x_4$ 的取值，则 $x_1$ 与 $x_2$ 必不独立；</p>
</li>
<li><p>奇妙的是，若 $x_4$ 的取值<strong>完全未知</strong>，则V型结构下 $x_1$ 与 $x_2$ 却是<strong>相互独立</strong>的，我们做一个简单的验证：</p>
<p>$$\begin{align} P(x_1, x_2) &amp;= \sum_{x_4} P(x_1, x_2, x_4) \ &amp;= \sum_{x_4} P(x_4|x_1,x_2) P(x_1) P(x_2) \ &amp;= P(x_1) P(x_2)  \tag{7.27} \end{align}$$</p>
<p>这样的独立性称为<strong>“边际独立性”</strong>（marginal independence），可以记为 $x_1 \perp x_2$ .</p>
</li>
</ul>
</li>
</ul>
<p>事实上，一个变量取值的确定与否，能对另两个变量间的独立性发生影响，这个现象并非V型结构所特有，例如：</p>
<ul>
<li>在同父结构中，条件独立性 $x_3 \perp x_4 \ |\  x_1$ 成立，但若 $x_1$ 的取值未知，则 $x_3$ 和 $x_4$ 就不独立，即 $x_3 \perp x_4$ 不成立；</li>
<li>在顺序结构中，$y \perp z \ | \ x $ ，但 $y \perp z$ 并不成立。</li>
</ul>
<p>为了分析有向图中所有变量间的条件独立性，可使用<strong>“有向分离”</strong>（D-separation）。</p>
<p>我们先把有向图转变为一个无向图：</p>
<ol>
<li>找出有向图中的所有V型结构，在V型结构的<strong>两个父结点之间加上一条无向边</strong>；</li>
<li>将所有有向边改为无向边</li>
</ol>
<p>由此产生的无向图称为<strong>“道德图”</strong>（moral graph），令父结点相连的过程称为“道德化”（moralization）.</p>
<blockquote>
<p>“道德化”的蕴义：孩子的父母应建立牢靠的关系，否则是不道德的。</p>
</blockquote>
<p>基于道德图能直观、迅速地找到变量间的条件独立性。</p>
<ul>
<li><p>假定道德图中有变量 $x, y$ 和变量集合 $\mathbf{z} = {z_i}$ ，若变量 $x$ 和 $y$ 能在图上被 $\mathbf{z}$ 分开，即从道德图中将变量集合 $\mathbf{z}$ 去除后，$x$ 和 $y$ 分属两个连通分支，则称变量 $x$ 和 $y$ 被 $\mathbf{z}$ 有向分离，$x \perp y \ | \ \mathbf{z} $ 成立.</p>
</li>
<li><p>例如，图7.2所对应的道德图如图7.4所示，从图中能容易地找出所有的条件独立关系：$x_3 \perp x_4 \ | \ x_1$ ，$x_4 \perp x_5 \ | \ x_2$ ，$x_3 \perp x_2 \ | \ x_1$ ，$x_3 \perp x_4 \ | \ x_1$ ，$x_3 \perp x_5 \ | \ x_1$ ，$x_3 \perp x_5 \ | \ x_2$ 等。</p>
</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20220101151438174.png" alt="image-20220101151438174" style="zoom:80%;" />



<h4 id="7-5-2-学习"><a href="#7-5-2-学习" class="headerlink" title="7.5.2 学习"></a>7.5.2 学习</h4><p>若网络结构已知，即属性间的依赖关系已知，则贝叶斯网的学习过程相对简单，只需通过对训练样本“计数”，估计出每个结点的条件概率表即可。</p>
<p>但在现实应用中我们往往并不知晓网络结构，于是，贝叶斯网学习的首要任务就是根据训练数据集来找出结构最“恰当”的贝叶斯网。</p>
<p><strong>“评分搜索”</strong>是求解这一问题的常用办法，具体来说：</p>
<ol>
<li>我们先定义一个评分函数（score function），以此来评估贝叶斯网与训练数据的契合程度</li>
<li>然后基于这个评分函数来寻找结构最优的贝叶斯网</li>
</ol>
<p>显然，评分函数引入了关于我们希望获得什么样的贝叶斯网的归纳偏好。</p>
<h4 id="7-5-3-推断"><a href="#7-5-3-推断" class="headerlink" title="7.5.3 推断"></a>7.5.3 推断</h4><p>贝叶斯网训练好之后就能用来回答<strong>“查询”（query）</strong>，即<strong>通过一些属性变量的观测值来推测其他属性变量的取值</strong>。</p>
<p>例如在西瓜问题中，若我们观测到西瓜色泽青绿、敲声浊响、根蒂蜷缩，想知道它是否成熟、甜度如何。这样通过已知变量观测值来推测待查询变量的过程称为<strong>“推断”（inference）</strong>，已知变量观测值称为<strong>“证据”（evidence）</strong>。</p>
<ul>
<li><strong>最理想的是直接根据贝叶斯网定义的联合概率分布来精确计算后验概率</strong>，不幸的是，这样的“精确推断”已被证明是NP难的。</li>
</ul>
<p>换言之，当网络结点较多、连接稠密时，难以进行精确推断，此时需借助“<strong>近似推断</strong>”，即通过降低精度要求，在有限时间内求得近似解。</p>
<p>在现实应用中，贝叶斯网的近似推断常使用<strong>吉布斯采样（Gibbs sampling）</strong>来完成，这是一种随机采样方法，具体如何工作可参考西瓜书7.5章。</p>
<h3 id="7-6-EM算法"><a href="#7-6-EM算法" class="headerlink" title="7.6 EM算法"></a>7.6 EM算法</h3><h4 id="7-6-1-动机：隐变量"><a href="#7-6-1-动机：隐变量" class="headerlink" title="7.6.1 动机：隐变量"></a>7.6.1 动机：隐变量</h4><p>在前面的讨论中，我们一直假设训练样本所有属性变量的值都已被观测到即训练样本是“完整”的。但在现实应用中往往会遇到“不完整”的训练样本，例如由于西瓜的根蒂已脱落，无法看出是“蜷缩”还是“硬挺”，则训练样本的“根蒂”属性变量值未知。</p>
<p>在这种存在“未观测”变量的情形下，是否仍能对模型参数进行估计呢？</p>
<p>未观测变量的学名是<strong>“隐变量”</strong>（ latent variable）：</p>
<ul>
<li>令 $\mathbf{X}$ 表示已观测变量集， $\mathbf{Z}$ 表示隐变量集， $\mathbf{\Theta}$ 表示模型参数</li>
</ul>
<p>若欲对 $\mathbf{\Theta}$ 做极大似然估计，则应最大化对数似然</p>
<p>$$\begin{align} LL(\mathbf{\Theta} \ | \ \mathbf{X}, \mathbf{Z}) = \ln P(\mathbf{X}, \mathbf{Z} \ | \ \mathbf{\Theta}) \tag{7.34} \end{align}$$</p>
<p>然而，由于 $\mathbf{Z}$ 是隐变量，上式无法直接求解。</p>
<p>此时我们可通过对 $\mathbf{Z}$ 计算期望，来最大化已观测数据的对数“边际似然”（ marginal likelihood）</p>
<p>$$\begin{align} LL(\mathbf{\Theta} \ | \ \mathbf{X}) = \ln P(\mathbf{X} \ | \ \mathbf{\Theta}) = \ln \sum_{\mathbf{Z}}  P(\mathbf{X}, \mathbf{Z} \ | \ \mathbf{\Theta}) \tag{7.35} \end{align}$$</p>
<h4 id="7-6-1-EM算法"><a href="#7-6-1-EM算法" class="headerlink" title="7.6.1 EM算法"></a>7.6.1 EM算法</h4><p><strong>EM（ Expectation- Maximization）算法</strong>，直译为<strong>“期望最大化算法”</strong>，是常用的估计参数隐变量的利器。</p>
<p>EM算法是一种迭代式的方法，其基本想法是：</p>
<ul>
<li>若参数 $\mathbf{\Theta}$ 已知，可根据训练数据推断出最优隐变量 $\mathbf{Z}$ 的值（E步）；</li>
<li>反之，若 $\mathbf{Z}$ 的值已知，则可方便地对参数 $\mathbf{\Theta}$ 做极大似然估计（M步）.</li>
</ul>
<p>于是，以初始值 $\mathbf{\Theta}^0$ 为起点，对式（7.35），可迭代执行以下步骤直至收敛：</p>
<ul>
<li>基于 $\mathbf{\Theta}^t$ 推断隐变量 $\mathbf{Z}$ 的期望，记为 $\mathbf{Z}^t$  ；</li>
<li>基于已观测变量 $\mathbf{X}$ 和 $\mathbf{Z}^t$ 对参数 $\mathbf{\Theta}$ 做极大似然估计，记为 $\mathbf{\Theta}^{t+1}$ .</li>
</ul>
<p>这就是EM算法的原型。</p>
<blockquote>
<p>事实上，隐变量估计问题也可通过梯度下降等优化算法求解，但由于求和的项数将随着隐变量的数目以指数级上升，会给梯度计算带来麻烦；</p>
<p>而EM算法则可看作一种非梯度优化方法，可看作用坐标下降（ coordinate descent）法来最大化对数似然下界的过程。</p>
</blockquote>
<h3 id="7-7-思考与归纳"><a href="#7-7-思考与归纳" class="headerlink" title="7.7 思考与归纳"></a>7.7 思考与归纳</h3><ul>
<li><p>贝叶斯决策可以描述为最小化期望损失，进而能表示为最大化后验概率。</p>
</li>
<li><p><strong>最小错误率贝叶斯决策就是在0-1损失函数条件下的最小风险贝叶斯决策</strong>。</p>
</li>
<li><p>朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类法。</p>
<ul>
<li>对于给定的训练数据集，首先基于特征条件独立假设学习输入输出的联合概率分布；</li>
<li>然后给予此模型，对给定的输入 $x$ ，利用贝叶斯定理求出后验概率最大的输出 $y$ 。</li>
</ul>
</li>
<li><p>贝叶斯网是经典的<strong>概率图模型</strong>，详细参见第14章。</p>
</li>
<li><p>EM算法是最常见的<strong>隐变量估计方法</strong>，在机器学习中有极为广泛的用途，例如常被用来学习高斯混合模型（GMM）的参数，9.4节将介绍的 $k$ 均值聚类算法就是一个典型的EM算法。</p>
</li>
<li><p>简要来说，EM算法使用两个步骤交替计算：</p>
<ul>
<li><p>第一步是期望（E）步，利用当前估计的参数值来计算对数似然的期望值；</p>
</li>
<li><p>第二步是最大化（M）步，寻找能使E步产生的似然期望最大化的参数值；</p>
<p>然后，新得到的参数值重新被用于E步，直至收敛到局部最优解…</p>
</li>
</ul>
</li>
</ul>
<h2 id="第8章-集成学习"><a href="#第8章-集成学习" class="headerlink" title="第8章 集成学习"></a>第8章 集成学习</h2><h3 id="8-1-个体与集成"><a href="#8-1-个体与集成" class="headerlink" title="8.1 个体与集成"></a>8.1 个体与集成</h3><p><strong>集成学习（ensemble learning）</strong>通过构建并结合多个学习器来完成学习任务，有时也被称为多分类器系统（multi-classifier system）、基于委员会的学习（committee-based learning）等。</p>
<p>图8.1显示出集成学习的一般结构：</p>
<ul>
<li>先产生一组“个体学习器”（individual learner），再用某种策略将它们结合起来。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119143929232.png" alt="image-20211119143929232" style="zoom:80%;" />

<p>其中个体学习器通常由一个现有的学习算法从训练数据产生，例如C4.5决策树算法、BP神经网络算法等。</p>
<ul>
<li><p>如果集成中只包含同种类型的个体学习器（例如“决策树集成”中全是决策树，“神经网络集成”中全是神经网络），这样的集成是“同质”的（homogeneous）。</p>
<p>同质集成中的个体学习器亦称<strong>“基学习器”（base learner）</strong>，相应的学习算法称为<strong>“基学习算法”（base learning algorithm）</strong>。</p>
</li>
<li><p>如果集成包含不同类型的个体学习器，例如同时包含决策树和神经网络，这样的集成是“异质”的（heterogenous）。</p>
<p>异质集成中的个体学习器由不同的学习算法生成，这时就<strong>不再有基学习算法</strong>；相应的，个体学习器一般不称为基学习器，常称为“组件学习器”（component learner）或直接称为个体学习器.</p>
</li>
</ul>
<p>集成学习通过将多个学习器进行结合，常可获得比单一学习器显著优越的泛化性能，这对<strong>“弱学习器”（weak learner）</strong>尤为明显。</p>
<blockquote>
<p> 弱学习器常指<strong>泛化性能略优于随机猜测的学习器</strong>，例如在二分类问题上精度略高于50%的分类器。</p>
</blockquote>
<p>根据个体学习器的生成方式，目前的集成学习方法大致可分为两大类，即</p>
<ol>
<li>个体学习器间存在<strong>强依赖关系</strong>、必须串行生成的序列化方法，代表是<strong>Boosting</strong>；</li>
<li>个体学习器间<strong>不存在强依赖关系</strong>、可同时生成的并行化方法，代表是<strong>Bagging</strong>和<strong>“随机森林”（Random Forest）</strong>。</li>
</ol>
<h3 id="8-2-Boosting"><a href="#8-2-Boosting" class="headerlink" title="8.2 Boosting"></a>8.2 Boosting</h3><p>Boosting是一族可将弱学习器提升为强学习器的算法，这族算法的工作机制类似：</p>
<ol>
<li>先从初始训练集训练出一个基学习器；</li>
<li>再根据基学习器的表现<strong>对训练样本分布进行调整</strong>，使得<strong>先前基学习器做错的训练样本在后续受到更多关注</strong>；</li>
<li>然后基于调整后的样本分布来训练下一个基学习器；</li>
<li>如此重复进行，直至基学习器数目达到事先指定的值 $T$ ，最终将这 $T$ 个基学习器进行加权结合。</li>
</ol>
<p>Boosting族算法最著名的代表是<strong>AdaBoost</strong> 【Freund and Schapire，1997】，其描述如图8.3所示：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119145318866.png" alt="image-20211119145318866" style="zoom:80%;" />



<p>其中 $y_i \in {-1, +1} $ ，$f$ 是真实函数。</p>
<p>AdaBoost算法有多种推导方式，比较容易理解的是基于“加性模型”（additive model），即基学习器的线性组合</p>
<p>$$\begin{align} H(x) = \sum_{t=1}^T \alpha_t h_t (x)  \tag{8.4} \end{align}$$</p>
<p>来<strong>最小化指数损失函数（exponential loss function）</strong> 【Friedman et al，2000】</p>
<p>$$loss_{exp}(H | D) = E_{x \in D}[e^{-f(x)H(x)}] $$</p>
<h3 id="8-3-Bagging与随机森林"><a href="#8-3-Bagging与随机森林" class="headerlink" title="8.3 Bagging与随机森林"></a>8.3 Bagging与随机森林</h3><p>由8.1节可知，欲得到泛化性能强的集成，集成中的个体学习器应尽可能具有较大的差异。</p>
<p>一种可能的做法是对训练样本进行采样，产生出若干个不同的子集，再从每个数据子集中训练出一个基学习器。</p>
<h4 id="8-3-1-Bagging"><a href="#8-3-1-Bagging" class="headerlink" title="8.3.1 Bagging"></a>8.3.1 Bagging</h4><p>Bagging 【Breiman，1996a】是并行式集成学习方法最著名的代表，从名字即可看出，它直接基于我们在2.2.3节介绍过的自助采样法（bootstrap sampling）</p>
<ul>
<li><p>从给定数据集中随机采样出 $T$ 个含 $m$ 个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合。</p>
</li>
<li><p>在对预测输出进行结合时，Bagging通常对<strong>分类任务使用简单投票法</strong>，对<strong>回归任务使用简单平均法</strong>。</p>
</li>
</ul>
<p>这就是Bagging的基本流程，其算法描述如图8.5所示.</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119152344403.png" alt="image-20211119152344403" style="zoom:80%;" />



<p>值得一提的是，自助采样过程还给Bagging带来了另一个优点：</p>
<ul>
<li>由于训练只使用了初始训练集中的部分样本，剩下的样本可用作验证集来对泛化性能进行<strong>“包外估计”（out-of-bag estimate）</strong>。 </li>
</ul>
<p>事实上，包外样本还有许多其他用途：</p>
<ul>
<li>例如当基学习器是决策树时，可使用包外样本来辅助剪枝，或用于估计决策树中各结点的后验概率以辅助对零训练样本结点的处理；</li>
<li>当基学习器是神经网络时，可使用包外样本来辅助早期停止以减小过拟合风险。</li>
</ul>
<h4 id="8-3-2-随机森林"><a href="#8-3-2-随机森林" class="headerlink" title="8.3.2 随机森林"></a>8.3.2 随机森林</h4><p>随机森林（Random Forest，简称RF）【Breiman，2001a】是Bagging的一个扩展变体。</p>
<p>RF在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了<strong>随机属性选择</strong>。</p>
<p>具体来说，</p>
<ul>
<li><p>传统决策树在选择划分属性时是在当前结点的属性集合（假定有d个属性）中选择一个最优属性；</p>
</li>
<li><p>而在RF中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 $k$ 个属性的子集，然后再从这个子集中选择一个最优属性用于划分。</p>
<blockquote>
<p>这里的参数 $k$ 控制了随机性的引入程度：</p>
<p>若令 $k=d$ ，则基决策树的构建与传统决策树相同；</p>
<p>若令 $k=1$ ，则是随机选择一个属性用于划分；</p>
<p>一般情况下，推荐值 $k = \log_2 d$ .</p>
</blockquote>
</li>
</ul>
<p>随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能，被誉为“代表集成学习技术水平的方法”。</p>
<p>可以看出，随机森林对Bagging只做了小改动，随机森林中基学习器的多样性不仅来自样本扰动（通过对初始训练集采样），还来自属性扰动，这就使得最终集成的泛化性能可通过个体学习器之间差异度的增加而进一步提升。</p>
<h4 id="8-3-3-性能分析"><a href="#8-3-3-性能分析" class="headerlink" title="8.3.3 性能分析"></a>8.3.3 性能分析</h4><p>随机森林的收敛性与Bagging相似，如图8.7所示：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119154344066.png" alt="image-20211119154344066" style="zoom:80%;" />

<ul>
<li>随机森林的起始性能往往相对较差，特别是在集成中只包含一个基学习器时。这很容易理解，因为通过引入属性扰动，随机森林中<strong>个体学习器的性能往往有所降低</strong>。</li>
<li>然而，随着个体学习器数目的增加，随机森林通常会<strong>收敛到更低的泛化误差</strong>。</li>
</ul>
<p>值得一提的是，随机森林的训练效率常优于Bagging，因为在个体决策树的构建过程中，Bagging使用的是<strong>“确定型”决策树</strong>，在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的<strong>“随机型”决策树</strong>则只需考察一个属性子集。</p>
<h3 id="8-4-结合策略"><a href="#8-4-结合策略" class="headerlink" title="8.4 结合策略"></a>8.4 结合策略</h3><p>学习器结合可能会从三个方面带来好处：</p>
<ol>
<li>首先，从统计的方面来看，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能因误选而导致<strong>泛化性能不佳</strong>，结合多个学习器则会减小这一风险；</li>
<li>第二，从计算的方面来看，学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能很糟糕，而通过多次运行之后进行结合，可<strong>降低陷入糟糕局部极小点的风险</strong>；</li>
<li>第三，从表示的方面来看，某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中，此时若使用单学习器则肯定无效，而通过结合多个学习器，由于相应的<strong>假设空间有所扩大</strong>，有可能学得更好的近似。</li>
</ol>
<p>图8.8给出了一个直观示意图：</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119154900610.png" alt="image-20211119154900610" style="zoom:80%;" />

<p>假定集成包含 $T$ 个基学习器 ${h_1, h_2, \dots, h_r}$ ，其中 $h_i$ 在示例 $x$ 上的输出为 $h_i(x)$ ，下面介绍几种对 $h_i$ 进行结合的常见策略：</p>
<ol>
<li><strong>平均法</strong>：简单平均法和加权平均法；</li>
<li><strong>投票法</strong>：绝对多数投票法与相对多数投票法；</li>
<li><strong>学习法</strong>：代表是Stacking算法，先从初始数据集训练出初级学习器，然后“生成”一个新数据集用于训练次级学习器，在这个新数据集中，初级学习器的输出被当作样例输入特征，而初始样本的标记仍被当作样例标记。</li>
</ol>
<h2 id="第9章-聚类"><a href="#第9章-聚类" class="headerlink" title="第9章 聚类"></a>第9章 聚类</h2><h3 id="9-1-聚类任务"><a href="#9-1-聚类任务" class="headerlink" title="9.1 聚类任务"></a>9.1 聚类任务</h3><p>在“无监督学习”（unsupervised learning）中，训练样本的标记信息是未知的，目标是通过对无标记训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础。此类学习任务中研究最多、应用最广的是<strong>“聚类”（clustering）</strong>。</p>
<ul>
<li>聚类试图将数据集中的样本划分为若千个通常是<strong>不相交的子集</strong>，每个子集称为一个<strong>“簇”（cluster）</strong>。</li>
</ul>
<p>通过这样的划分，每个簇可能对应于一些潜在的概念（类别），如“浅色瓜”“深色瓜”，“有籽瓜”“无籽瓜”，甚至“本地瓜”“外地瓜”等。</p>
<blockquote>
<p>需说明的是，这些概念对聚类算法而言<strong>事先是未知的</strong>，聚类过程仅能自动形成簇结构，簇所对应的概念语义需由使用者来把握和命名。</p>
</blockquote>
<p>形式化地说，</p>
<ul>
<li>假定样本集 $D = { x_1, x_2, \dots, x_m }$ 包含 $m$ 个无标记样本，每个样本 $x_i = (x_{i1}; x_{i2}; \dots; x_{in})$ 是一个 $n$ 维特征向量；</li>
<li>聚类算法将样本集 $D$ 划分为 $k$ 个不相交的簇 ${ C_l | l = 1, 2, \dots, k }$ ，其中 $\displaystyle C_{l1} \cap_{l1 \neq l2} C_{l2} =  \emptyset$ ；</li>
<li>相应地，我们用 $\lambda_j \in { 1, 2, \dots, k }$ 表示样本 $x_j$ 的<strong>“簇标记”（cluster label）</strong>，即 $x_j \in C_{\lambda_j}$ ；</li>
<li>于是，聚类的结果可用包含 $m$ 个元素的簇标记向量 $\mathbf{\lambda} = (\lambda_1; \lambda_2; \dots; \lambda_m)$ 表示.</li>
</ul>
<p>聚类既能作为一个单独过程，用于找寻数据内在的分布结构，也可作为分类等其他学习任务的前驱过程。</p>
<blockquote>
<p>例如，在一些商业应用中需对新用户的类型进行判别，但定义“用户类型”对商家来说却可能不太容易，此时往往可先对用户数据进行聚类，根据聚类结果将每个簇定义为一个类，然后再基于这些类训练分类模型，用于判别新用户的类型，</p>
</blockquote>
<p>基于不同的学习策略，人们设计出多种类型的聚类算法，本章后半部分将对不同类型的代表性算法进行介绍，<del>但在此之前，我们先讨论聚类算法涉及的两个基本问题一性能度量和距离计算</del>。</p>
<ul>
<li><h3 id="9-2-性能度量"><a href="#9-2-性能度量" class="headerlink" title="9.2 性能度量"></a>9.2 性能度量</h3></li>
<li><h3 id="9-3-距离计算"><a href="#9-3-距离计算" class="headerlink" title="9.3 距离计算"></a>9.3 距离计算</h3></li>
</ul>
<h3 id="9-4-原型聚类"><a href="#9-4-原型聚类" class="headerlink" title="9.4 原型聚类"></a>9.4 原型聚类</h3><p>原型聚类亦称“基于原型的聚类”（prototype-based clustering），此类算法<strong>假设聚类结构能通过一组原型刻画</strong>，在现实聚类任务中极为常用。</p>
<blockquote>
<p>“原型”是<strong>指样本空间中具有代表性的点.</strong></p>
</blockquote>
<p>通常情形下，算法先对原型进行<strong>初始化</strong>，然后对原型进行<strong>迭代更新</strong>求解。</p>
<p>采用不同的原型表示、不同的求解方式，将产生不同的算法，下面介绍几种著名的原型聚类算法。</p>
<h4 id="9-4-1-k-均值算法"><a href="#9-4-1-k-均值算法" class="headerlink" title="9.4.1 $k$ 均值算法"></a>9.4.1 $k$ 均值算法</h4><h5 id="基本原理-3"><a href="#基本原理-3" class="headerlink" title="基本原理"></a>基本原理</h5><p>给定样本集样本集 $D = { x_1, x_2, \dots, x_m }$ ，<strong>“k均值”（k-means）算法</strong>针对聚类所得簇划分 $C={C_1, C_2, \dots , C_k}$ 最小化平方误差：</p>
<p>$$\begin{align} E = \sum_{i=1}^k \sum_{x \in C_i} |x - \mu_i|^2 \tag{9.24} \end{align}$$</p>
<p>其中 $\mu_i = \frac{1}{C_i} \sum_{x \in C_i} x $ 是<strong>簇 $C_i$ 的均值向量</strong>。</p>
<blockquote>
<p>可知，$k$ 均值算法认为簇的原型就是均值向量。</p>
</blockquote>
<p>直观来看，式（9.24）在一定程度上刻画了簇内样本围绕簇均值向量的紧密程度，**$E$ 值越小表示簇内样本相似度越高**。</p>
<h5 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h5><p>最小化式（9.24）并不容易，找到它的最优解需考察样本集 $D$ 所有可能的簇划分，这是一个NP难问题【Aloise et al，2009】。</p>
<p>因此，$k$ 均值算法采用了<strong>贪心策略</strong>，通过迭代优化来近似求解式（9.24），算法流程如图9.2所示，其中：</p>
<ul>
<li>第1行对均值向量进行初始化；</li>
<li>在第4-8行与第9-16行依次对当前<strong>簇划分</strong>及<strong>均值向量</strong>迭代更新；</li>
<li>若迭代更新后聚类结果保持不变，则在第18行将当前簇划分结果返回。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119183001533.png" alt="image-20211119183001533" style="zoom:80%;" />



<h4 id="9-4-2-学习向量量化"><a href="#9-4-2-学习向量量化" class="headerlink" title="9.4.2 学习向量量化"></a>9.4.2 学习向量量化</h4><h5 id="基本原理-4"><a href="#基本原理-4" class="headerlink" title="基本原理"></a>基本原理</h5><p>与 $k$ 均值算法类似，<strong>“学习向量量化”（Learning Vector Quantization，简称LVQ）</strong>也是试图找到一组原型向量来刻画聚类结构，但与一般聚类算法不同的是：</p>
<ul>
<li>LVQ假设数据样本带有类别标记，学习过程<strong>利用样本的这些监督信息来辅助聚类</strong>。</li>
</ul>
<p>给定样本集 $D = { (x_1, y_1), (x_2, y_2), \dots, (x_m, y_m) }$ ，每个样本 $x_j$ 是由 $n$ 个属性描述的特征向量 $(x_{j1}; x_{j2}; \dots; x_{jn})$ ，$y_j \in \gamma$ 是样本 $x_j$ 的类别标记。</p>
<p>LVQ的目标是：</p>
<ul>
<li>学得一组 $n$ 维原型向量 ${ p_1, p_2, \dots, p_q }$ ，每个原型向量代表一个聚类簇，其簇标记为 $t_i \in \gamma $ ，共 $q$ 个簇。</li>
</ul>
<h5 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h5><p>LVQ算法描述如图9.4所示，其中：</p>
<ul>
<li><p>第1行先对原型向量进行初始化。</p>
<p>例如对第 $q$ 个簇可从类别标记为 $t_q$ 的样本中随机选取一个作为原型向量；</p>
</li>
<li><p>第2~12行对原型向量进行迭代优化。</p>
<p>在每一轮迭代中，算法<strong>随机选取一个有标记训练样本，找出与其距离最近的原型向量</strong>，并<strong>根据两者的类别标记是否一致来对原型向量进行相应的更新</strong>；</p>
<blockquote>
<p>第5行是竞争学习的“胜者为王”策略.</p>
</blockquote>
</li>
<li><p>在第12行中，若算法的停止条件已满足（例如已达到最大迭代轮数，或原型向量更新很小甚至不再更新），则将当前原型向量作为最终结果返回。</p>
</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119192535246.png" alt="image-20211119192535246" style="zoom:60%;" />



<p>显然，LVQ的关键是第6-10行，即<strong>如何更新原型向量</strong>。</p>
<p>直观上看，对样本 $x_j$，若最近的原型向量 $p_{i^*}$ 与 $x_j$ 的类别标记相同，则令 $p_{i^*}$ 向 $x_j$ 的方向靠拢，如第7行所示，此时新原型向量为</p>
<p>$$\begin{align} p^‘ = p_{i^*} + \eta \  \cdot \ (x_j - p_{i^*}) \tag{9.25} \end{align}$$</p>
<p>那么新的原型向量 $p^‘$ 与 $x_j$ 之间的距离将减小为</p>
<p>$$\begin{align} ||p^‘ - x_j||<em>2 &amp;= ||p</em>{i^*} + \eta \  \cdot \ (x_j - p_{i^*}) - x_j||<em>2 \ &amp;= (1 - \eta) \cdot ||p</em>{i^*} - x_j||_2 \tag{9.26} \end{align}$$</p>
<p>相应地，若 $p_{i^*}$ 与 $x_j$ 的类别标记不同，则更新后的原型向量 $p^‘$ 与 $x_j$ 之间的距离将增大为 $(1 + \eta) \cdot ||p_{i^*} - x_j||_2 $ ，从而更远离 $x_j$ 。</p>
<p>在学得一组原型向量 ${ p_1, p_2, \dots, p_q }$ 后，即可实现对样本空间 $\chi$ 的簇划分。</p>
<ul>
<li>对<strong>任意样本 $x$ ，它将被划入与其距离最近的原型向量所代表的簇中</strong>；</li>
</ul>
<p>换言之，每个原型向量 $p_i$ 定义了与之相关的一个区域 $R_i$ ，该区域中每个样本与 $p_i$ 的距离不大于它与其他原型向量 $p_{j} \ \ (j \neq i)$ 的距离，即</p>
<p>$$\begin{align} R_i = { x \in \chi \ \ | \ \ ||x - p_i||_2 \ \leq \ ||x - p_j||_2 \ , \ j \neq i } \tag{9.27} \end{align}$$</p>
<p>由此形成了对样本空间 $\chi$ 的簇划分 ${R_1, R_2, \dots, R_q}$ ，该划分通常称为 **“Voronoi剖分” (Voronoi tessellation)**。</p>
<blockquote>
<p>若将 $R_i$ 中样本全用原型向量 $p_i$ 表示，则可实现数据的<strong>“有损压缩”（lossy compression）</strong>，这称为<strong>“向量量化”（vector quantization）</strong>，LVQ亦由此而得名.</p>
</blockquote>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20211119201122547.png" alt="image-20211119201122547" style="zoom:55%;" />





<h4 id="9-4-3-高斯混合聚类"><a href="#9-4-3-高斯混合聚类" class="headerlink" title="9.4.3 高斯混合聚类"></a>9.4.3 高斯混合聚类</h4><p>与 $k$ 均值、LVQ用<strong>原型向量</strong>来刻画聚类结构不同，<strong>高斯混合（Mixture-of-Gaussian）聚类</strong>采用<strong>概率模型</strong>来表达聚类原型。</p>
<h5 id="基本原理-5"><a href="#基本原理-5" class="headerlink" title="基本原理"></a>基本原理</h5><p>我们先简单回顾一下（多元）高斯分布的定义：</p>
<p>$$\begin{align} p(x) = \frac{1}{\sqrt{2\pi} \sigma} \exp (- \frac{(x - \mu)^2}{2 \sigma^2}) \end{align}$$</p>
<p>更一般地，对 $n$ 维样本空间 $\chi$ 中的随机向量 $\mathbf{x}$ ，若 $\mathbf{x}$ 服从高斯分布，其概率密度函数为</p>
<p>$$\begin{align} p(\mathbf{x}) &amp;= \frac{1}{(2\pi)^{\frac{n}{2}} |\Sigma|^{\frac{1}{2}} } \exp (- \frac{(\mathbf{x} - \mathbf{\mu})^T(\mathbf{x} - \mathbf{\mu})}{2 \ \Sigma}) \ &amp;= \frac{1}{(2\pi)^{\frac{n}{2}} |\Sigma|^{\frac{1}{2}} } \exp {(- \frac{1}{2} ( \mathbf{x} - \mathbf{\mu} )^T \Sigma^{-1} (\mathbf{x} - \mathbf{\mu}) )} \tag{9.28} \end{align}$$</p>
<p>其中，$\mu$ 是 $n$ 维均值向量， $\Sigma$ 是 $n \times n$ 的协方差矩阵。</p>
<p>可以看出，高斯分布完全由这两个参数确定。为了明确显示高斯分布与相应参数的依赖关系，将概率密度函数记为 $p(\mathbf{x} \ | \ \mu, \Sigma)$ .</p>
<p>那么我们可定义<strong>高斯混合分布</strong></p>
<p>$$\begin{align} p_{M}(\mathbf{x}) = \sum_{i=1}^k \alpha_i \  \cdot \ p(\mathbf{x} \ | \ \mu_i, \Sigma_i)  \tag{9.29} \end{align}$$</p>
<p>该分布共由 $k$ 个<strong>混合成分</strong>组成，每个混合成分对应一个高斯分布。其中，$\alpha_i &gt; 0$ 为相应的“<strong>混合系数</strong>”（mixture coefficient），且 $\sum_{i=1}^k \alpha_i = 1$ .</p>
<p>高斯混合聚类的基本思想是：</p>
<ul>
<li>对于训练集 $D = { \mathbf{x}_1, \mathbf{x}_2, \dots, \mathbf{x}_m }$ 中的某个样本 $\mathbf{x}_j$ ，确定其属于这 $k$ 个高斯分布中的哪一个，并以此将所有样本划分为 $k$ 个簇。</li>
</ul>
<p>那么如何确定样本属于哪个高斯分布呢？</p>
<ul>
<li>我们考虑贝叶斯定理，<strong>如果样本 $\mathbf{x}_j$ 属于高斯分布 $i$ 的后验概率更大，那么我们就将 $\mathbf{x}_j$ 划分到第 $i$ 个簇中</strong>。</li>
</ul>
<p>具体来说，令随机变量 $z_j \in {1, 2, \dots, k}$ 表示生成样本 $\mathbf{x}_j$ 的高斯分布。</p>
<p>显然，$z_j$ 的先验概率对应于 $\alpha_i$ 。</p>
<p>那么根据贝叶斯定理，$z_j$ 的后验概率则对应于</p>
<p>$$\begin{align} p_M(z_j=i \ | \ \mathbf{x}_j) &amp;= \frac{P(z_j = i) \ \cdot \ p_M(\mathbf{x}<em>j | z_j = i)}{p_M(\mathbf{x}_j)} \ &amp;= \frac{\alpha_i \ \cdot \ p_M(\mathbf{x}_j \ | \ \mu_i, \Sigma_i)}{\sum</em>{l=1}^k \alpha_l \ \cdot \ p_M(\mathbf{x}_j \ | \ \mu_l, \Sigma_l)} \tag{9.30} \end{align}$$</p>
<p>换言之，$p_M(z_j=i \ | \ \mathbf{x}_j)$ 给出了样本 $\mathbf{x}_j$ 由第 $i$ 个高斯分布生成的后验概率。</p>
<p>为方便叙述，将其简记为 $\gamma_{ji} \ \ (i = 1, 2, \dots, k)$ .</p>
<p>当高斯混合分布（9.29）已知时，高斯混合聚类将把样本集 $D$ 划分为 $k$ 个簇 $\mathbf{C} = { C_1, C_2, \dots ,C_k}$ ，每个样本 $x_j$ 的簇标记 $\lambda_j$ 如下确定：</p>
<p>$$\begin{align} \lambda_j = \arg \max_{i \in { 1,2,\dots,k }} \gamma_{ji} \tag{9.31} \end{align}$$</p>
<blockquote>
<p>因此，从原型聚类的角度来看，高斯混合聚类是釆用概率模型（高斯分布）对原型进行刻画，簇划分则由原型对应后验概率确定。</p>
</blockquote>
<h5 id="划分过程——EM算法"><a href="#划分过程——EM算法" class="headerlink" title="划分过程——EM算法"></a>划分过程——EM算法</h5><p>那么，对于式（9.29），模型参数 ${ (\alpha_i, \mu_i, \Sigma_i) \ | \ 1 \leq i \leq k }$ 如何求解呢？</p>
<p>显然，给定样本集 $D$，可采用极大似然估计，即最大化（对数）似然</p>
<p>$$\begin{align} LL(D) &amp;= \ln {(\prod_{j=1}^m p_M(\mathbf{x}<em>j))} \ &amp;= \sum</em>{j=1}^m \ln {(\sum_{i=1}^k \alpha_i \ \cdot \ p(\mathbf{x}_j \ | \ \mu_i, \Sigma_i))}  \tag{9.32} \end{align}$$</p>
<p>考虑约束条件  $\sum_{i=1}^k \alpha_i = 1$ ，使用拉格朗日乘子法，分别对 $\mu_i, \Sigma_i, \alpha_i$ 求导，并令一阶导数为零得到新的 $\mu_i, \Sigma_i, \alpha_i$ 表达式。</p>
<p>然后采用EM算法进行迭代优化求解：</p>
<ul>
<li><p>E步（Expectation）：使用当前的 $\mu_i, \Sigma_i, \alpha_i$ 和样本数据 $\mathbf{x}<em>j$ 计算 $\gamma</em>{ji}$ ，表示 $\mathbf{x}_j$ 属于第 $i$ 个高斯的概率；</p>
</li>
<li><p>M步（Maximization）：将 $\gamma_{ji}$ 代入前面利用极大似然估计求得的 $\mu_i, \Sigma_i, \alpha_i$ 表达式，更新 $\mu_i, \Sigma_i, \alpha_i$ 的值。</p>
<p>不断循环迭代E、M步，直至收敛。</p>
</li>
</ul>
<ul>
<li><h3 id="9-x-密度聚类"><a href="#9-x-密度聚类" class="headerlink" title="9.x 密度聚类"></a>9.x 密度聚类</h3></li>
<li><h3 id="9-x-层次聚类"><a href="#9-x-层次聚类" class="headerlink" title="9.x 层次聚类"></a>9.x 层次聚类</h3></li>
</ul>
<h3 id="9-6-思考与归纳"><a href="#9-6-思考与归纳" class="headerlink" title="9.6 思考与归纳"></a>9.6 思考与归纳</h3><ul>
<li>$k$ 均值算法认为一个簇的原型就是该集合中的均值向量，而LVQ则是借助监督信息，通过迭代学习得到的原型向量，这个原型是可能不存在于样本集中的。</li>
</ul>
<h2 id="第10章-降维"><a href="#第10章-降维" class="headerlink" title="第10章 降维"></a>第10章 降维</h2><h3 id="10-1-k近邻学习"><a href="#10-1-k近邻学习" class="headerlink" title="10.1 k近邻学习"></a>10.1 k近邻学习</h3><p><strong>k近邻</strong>（k-Nearest Neighbor，简称kNN）学习是一种常用的监督学习方法，其工作机制非常简单：</p>
<p>给定测试样本，基于某种距离度量找出训练集中与其最靠近的k个训练样本，然后基于这k个“邻居”的信息来进行预测。</p>
<ul>
<li>通常，在分类任务中可使用“投票法”，即选择这k个样本中出现最多的类别标记作为预测结果；</li>
<li>在回归任务中可使用“平均法”，即将这k个样本的实值输出标记的平均值作为预测结果；</li>
<li>还可基于距离远近进行加权平均或加权投票，距离越近的样本权重越大，</li>
</ul>
<blockquote>
<p>与前面介绍的学习方法相比，k近邻学习有一个明显的不同之处：它似乎没有显式的训练过程！</p>
<ul>
<li>事实上，它是“<strong>懒惰学习</strong>”（lazy learning）的著名代表，此类学习技术在训练阶段仅仅是把样本保存起来，<strong>训练时间开销为零</strong>，待收到测试样本后再进行处理；</li>
<li>相应的，那些在训练阶段就对样本进行学习处理的方法，称为“<strong>急切学习</strong>”（eager learning）.</li>
</ul>
</blockquote>
<p>图10.1给出了k近邻分类器的一个示意图。</p>
<ul>
<li>显然，k是一个重要参数，当k取不同值时，分类结果会有显著不同；</li>
<li>另一方面，若采用不同的距离计算方式，则找出的“近邻”可能有显著差别，从而也会导致分类结果有显著不同。</li>
</ul>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20220106115706238.png" alt="image-20220106115706238" style="zoom:80%;" />



<h3 id="10-2-低维嵌入"><a href="#10-2-低维嵌入" class="headerlink" title="10.2 低维嵌入"></a>10.2 低维嵌入</h3><p>诸如kNN等许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦，例如当维数很高时甚至连计算内积都不再容易。</p>
<p>事实上，在高维情形下出现的数据样本稀疏、距离计算困难等问题是所有机器学习方法共同面临的严重障碍，被称为“<strong>维数灾难</strong>”（curse ofdimensionality).</p>
<ul>
<li><p>缓解维数灾难的一个重要途径是<strong>降维</strong>（dimension reduction），亦称“维数约简”，即</p>
<p><strong>通过某种数学变换将原始高维属性空间转变为一个低维“子空间”（subspace）</strong>，在这个子空间中样本密度大幅提高，距离计算也变得更为容易。</p>
</li>
</ul>
<p>为什么能进行降维？这是因为在很多时候，人们观测或收集到的数据样本虽是高维的，但与学习任务密切相关的也许仅是某个低维分布，即<strong>高维空间中的一个低维“嵌入”（embedding）</strong>.</p>
<p>图10.2给出了一个直观的例子，原始高维空间中的样本点，在这个低维嵌入子空间中更容易进行学习。</p>
<img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20220106120824605.png" alt="image-20220106120824605" style="zoom:80%;" />

<p>一般来说，欲获得低维子空间，最简单的是对原始高维空间进行<strong>线性变换</strong>。</p>
<p>给定 $n$ 维空间中的样本 $\mathbf{X} = (\mathbf{x}_1, \mathbf{x}_2, \dots, \mathbf{x}_m) \in \mathbb{R}^{n \times m}$ ，变换之后得到 $d \ll n$ 维空间中的样本</p>
<p>$$\begin{align} \mathbf{Z} = \mathbf{W}^T \mathbf{X} \tag{10.13} \end{align}$$</p>
<p>其中，$\mathbf{W} = (\mathbf{w}_1, \mathbf{w}_2, \dots, \mathbf{w}_d) \in \mathbb{R}^{n \times d}$  是变换矩阵，$\mathbf{Z} = (\mathbf{z}_1, \mathbf{z}_2, \dots, \mathbf{z}_m) \in \mathbb{R}^{d \times m}$ 是样本在新空间中的表达。</p>
<ul>
<li>变换矩阵 $\mathbf{W}$ 可视为 $d$ 个 $n$ 维基向量；</li>
<li>$\mathbf{z}_i = \mathbf{W}^T \mathbf{x}_i$ 是第 $i$ 个样本与这 $d$ 个基向量分别做内积而得到的 <strong>$d$ 维属性向量</strong>。换言之，$\mathbf{z}_i$ 是原样本向量 $\mathbf{x}_i$ 在新坐标系 ${ \mathbf{w}_1, \mathbf{w}_2, \dots, \mathbf{w}_d }$ 中的坐标向量。</li>
</ul>
<p>基于线性变换来进行降维的方法称为线性降维方法，它们都符合式（10.13）的基本形式，不同之处是<strong>对低维子空间的性质有不同的要求</strong>，相当于对 $\mathbf{W}$ 施加了不同的约束。</p>
<p>在下一节我们将会看到，若<strong>要求低维子空间对样本具有最大可分性</strong>，则将得到一种极为常用的线性降维方法。</p>
<h3 id="10-3-主成分分析"><a href="#10-3-主成分分析" class="headerlink" title="10.3 主成分分析"></a>10.3 主成分分析</h3><p><strong>主成分分析</strong>（Principal Component Analysis，简称PCA）是最常用的一种降维方法。</p>
<p>在介绍PCA之前，不妨先考虑这样一个问题：</p>
<ul>
<li>对于正交属性空间中的样本点，如何用一个超平面（直线的高维推广）对所有样本进行恰当的表达？</li>
</ul>
<p>容易想到，若存在这样的超平面，那么它大概应具有这样的性质：</p>
<ol>
<li><strong>最近重构性</strong>：样本点到这个超平面的距离都足够近；</li>
<li><strong>最大可分性</strong>：样本点在这个超平面上的投影能尽可能分开.</li>
</ol>
<p>有趣的是，基于最近重构性和最大可分性，能分别得到主成分分析的两种等价推导。</p>
<h4 id="10-3-1-最近重构性"><a href="#10-3-1-最近重构性" class="headerlink" title="10.3.1 最近重构性"></a>10.3.1 最近重构性</h4><p>最近重构性实际上就是最小均方误差，我们首先：</p>
<ul>
<li>假定数据样本进行了中心化，即令 $\mathbf{x}_i = \mathbf{x}_i - \bar{\mathbf{x}} $ ，最终满足 $\sum_i \mathbf{x}_i = \mathbf{0}$ ；</li>
<li>再假定投影变换后得到的新坐标系为 ${\mathbf{w}_1, \mathbf{w}_2, \dots, \mathbf{w}_n }$ ，其中 $\mathbf{w}_i$ 是标准正交基向量，$||\mathbf{w}_i||_2 = 1$ 且 $\mathbf{w}_i^T \mathbf{w}_j = 0 \ \ (i \neq j)$ ；</li>
<li>若丢弃新坐标系中的部分坐标，即将维度降低到 $d \ll n$ ，则得到变换矩阵 $\mathbf{W} = (\mathbf{w}_1, \mathbf{w}_2, \dots, \mathbf{w}_d)$ 。</li>
</ul>
<p>那么样本点 $\mathbf{x}_i$ 在低维坐标系中的投影是 $\mathbf{z}_i = \mathbf{W}^T \mathbf{x}_i$ 。</p>
<p>为了衡量样本在投影前后，即 $\mathbf{x}_i$ 与 $\mathbf{z}_i$ 之间的距离，需要将其放在同一个坐标系下。</p>
<p>不妨令 $\hat{\mathbf{x}}_i$ 表示投影点 $\mathbf{z}_i$ 在原坐标系下的向量，则有 $\hat{\mathbf{x}}_i = \mathbf{W} \mathbf{z}_i = \mathbf{W} \mathbf{W}^T \mathbf{x}_i$ . </p>
<p>那么原样本点 $\mathbf{x}_i$ 与基于投影重构的样本点 $\hat{\mathbf{x}}_i$ 之间的距离为</p>
<p>$$\begin{align} (\hat{\mathbf{x}}_i - \mathbf{x}_i)^2 &amp;= (\mathbf{W} \mathbf{W}^T \mathbf{x}_i - \mathbf{x}_i)^T (\mathbf{W} \mathbf{W}^T \mathbf{x}_i - \mathbf{x}_i) \ &amp;= ( \mathbf{x}_i^T \mathbf{W} \mathbf{W}^T  - \mathbf{x}_i^T) (\mathbf{W} \mathbf{W}^T \mathbf{x}_i - \mathbf{x}_i) \ &amp;= \mathbf{x}_i^T \mathbf{W} \mathbf{W}^T \mathbf{W} \mathbf{W}^T \mathbf{x}_i - 2 \mathbf{x}_i^T \mathbf{W} \mathbf{W}^T \mathbf{x}_i + \mathbf{x}_i^T \mathbf{x}_i \ &amp;= - \mathbf{x}_i^T \mathbf{W} \mathbf{W}^T \mathbf{x}_i  +  \mathbf{x}_i^T \mathbf{x}_i \ &amp;= - \mathbf{z}_i^T \mathbf{z}_i + C \tag{10.14} \end{align}$$</p>
<p>其中，$\mathbf{x}_i^T \mathbf{x}_i$ 为已知，可直接记为常数 $C$ .</p>
<p>因此考虑整个训练集，得到下面的优化目标</p>
<p>$$\begin{align} \min_{\mathbf{W}} \ \ \frac{1}{m} \sum_{i=1}^m - \mathbf{z}_i^T \mathbf{z}_i  \ s.t. \ \mathbf{W}^T \mathbf{W} = \mathbf{I}  \tag{10.15} \end{align}$$</p>
<p>这就是主成分分析的优化目标。</p>
<h4 id="10-3-2-最大可分性"><a href="#10-3-2-最大可分性" class="headerlink" title="10.3.2 最大可分性"></a>10.3.2 最大可分性</h4><p>从最大可分性出发，能得到主成分分析的另一种解释。</p>
<p>我们知道，样本点 $\mathbf{x}_i$ 在新空间中超平面上的投影是 $\mathbf{W}^T \mathbf{x}_i$ ，若所有样本点尽可能分开，则<strong>应该使投影后样本点的方差最大化</strong>。</p>
<p>由于投影后的协方差矩阵为 $\frac{1}{m} \sum_{i=1}^{m} \mathbf{z}_i^T \mathbf{z}_i$ ，而样本方差为协方差矩阵的迹，即</p>
<p>$$\begin{align} \max_{\mathbf{W}} \ \ &amp; tr(\frac{1}{m} \sum_{i=1}^m \mathbf{z}<em>i \mathbf{z}<em>i^T)  \  &amp;= \frac{1}{m} \sum</em>{i=1}^m tr(\mathbf{z}_i \mathbf{z}_i^T) \ &amp;= \frac{1}{m} \sum</em>{i=1}^m \mathbf{z}_i^T \mathbf{z}_i   \ &amp; s.t. \ \mathbf{W}^T \mathbf{W} = \mathbf{I}  \tag{10.16} \end{align}$$</p>
<p>显然，式（10.16）与（10.15）等价。</p>
<h4 id="10-3-4-PCA的算法过程"><a href="#10-3-4-PCA的算法过程" class="headerlink" title="10.3.4 PCA的算法过程"></a>10.3.4 PCA的算法过程</h4><img src="https://gitee.com/Jayyy1/images/raw/master/posts/Computer%20Science/Machine%20Learning/image-20220106132858645.png" alt="image-20220106132858645" style="zoom:80%;" />



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jay1zhang.github.io/2022/01/06/Computer%20Science/Machine%20Learning/%E3%80%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8D%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/">http://jay1zhang.github.io/2022/01/06/Computer%20Science/Machine%20Learning/%E3%80%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8D%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Machine-Learning/">Machine Learning</a></div><div class="post_share"><div class="social-share" data-image="http://jayyy1.gitee.io/images/pictures/cartoons/039.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/07/19/Computer%20Science/Linux/%E3%80%8CSSH%E3%80%8D%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5ssh%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/027.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">「SSH」远程连接ssh配置.md</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/03/27/Computer Science/Machine Learning/「机器学习」最优化问题之拉格朗日对偶性/" title="「机器学习」（TODO）最优化问题之拉格朗日乘子法"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/038.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-27</div><div class="title">「机器学习」（TODO）最优化问题之拉格朗日乘子法</div></div></a></div><div><a href="/2021/05/01/Computer Science/Machine Learning/「机器学习」过拟合问题与正则化方法/" title="「机器学习」过拟合问题与正则化方法"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/014.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-01</div><div class="title">「机器学习」过拟合问题与正则化方法</div></div></a></div><div><a href="/2021/06/01/Computer Science/Machine Learning/「机器学习」面试常见问题汇总/" title="「机器学习」面试常见问题汇总"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/030.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-01</div><div class="title">「机器学习」面试常见问题汇总</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-text">第1章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-text">1.1 基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%AC"><span class="toc-text">数据样本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE"><span class="toc-text">数据标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="toc-text">训练模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B"><span class="toc-text">测试模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B"><span class="toc-text">泛化能力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BD%92%E7%BA%B3%E5%AD%A6%E4%B9%A0"><span class="toc-text">1.2 归纳学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E7%A9%BA%E9%97%B4"><span class="toc-text">假设空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E5%81%8F%E5%A5%BD"><span class="toc-text">归纳偏好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%85%8D%E8%B4%B9%E7%9A%84%E5%8D%88%E9%A4%90"><span class="toc-text">没有免费的午餐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%80%9D%E8%80%83%E4%B8%8E%E5%BD%92%E7%BA%B3"><span class="toc-text">1.3 思考与归纳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-text">第2章 模型评估与选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="toc-text">第3章 线性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F"><span class="toc-text">3.1 基本形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">3.2 线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95"><span class="toc-text">最小二乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">多元线性回归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">广义线性回归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"><span class="toc-text">3.3 逻辑回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="toc-text">极大似然估计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="toc-text">3.4 线性判别分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95"><span class="toc-text">拉格朗日乘子法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LDA%E5%A4%9A%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1"><span class="toc-text">LDA多分类任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%A4%9A%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0"><span class="toc-text">3.5 多分类学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E7%B1%BB%E5%88%AB%E4%B8%8D%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98"><span class="toc-text">3.6 类别不平衡问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%80%9D%E8%80%83%E4%B8%8E%E5%BD%92%E7%BA%B3"><span class="toc-text">3.7 思考与归纳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-text">第4章 决策树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">4.1 基本流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%88%92%E5%88%86%E9%80%89%E6%8B%A9"><span class="toc-text">4.2 划分选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A"><span class="toc-text">4.2.1 信息增益</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%A2%9E%E7%9B%8A%E7%8E%87"><span class="toc-text">4.2.2 增益率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%9F%BA%E5%B0%BC%E6%8C%87%E6%95%B0"><span class="toc-text">4.2.3 基尼指数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%89%AA%E6%9E%9D%E5%A4%84%E7%90%86"><span class="toc-text">4.3 剪枝处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E9%A2%84%E5%89%AA%E6%9E%9D"><span class="toc-text">4.3.1 预剪枝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E5%90%8E%E5%89%AA%E6%9E%9D"><span class="toc-text">4.3.2 后剪枝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%BF%9E%E7%BB%AD%E4%B8%8E%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-text">4.4 连续与缺失值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E8%BF%9E%E7%BB%AD%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-text">4.4.1 连续值处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-text">4.4.2 缺失值处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89"><span class="toc-text">对问题（1）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E9%97%AE%E9%A2%98%EF%BC%882%EF%BC%89"><span class="toc-text">对问题（2）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%A4%9A%E5%8F%98%E9%87%8F%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-text">4.5 多变量决策树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%80%9D%E8%80%83%E4%B8%8E%E5%BD%92%E7%BA%B3"><span class="toc-text">4.6 思考与归纳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-text">第5章 神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.1 神经元模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E5%A4%9A%E5%B1%82%E7%BD%91%E7%BB%9C"><span class="toc-text">5.2 感知机与多层网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95"><span class="toc-text">5.3 误差反向传播算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC"><span class="toc-text">数学推导</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E8%AE%A1%E7%AE%97-Delta-w-2-hj"><span class="toc-text">1）计算 $\Delta w^{(2)}_{hj}$</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E8%AE%A1%E7%AE%97-Delta-w-1-ih"><span class="toc-text">2）计算  $\Delta w^{(1)}_{ih}$</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E8%AE%A1%E7%AE%97%E5%81%8F%E7%BD%AE-Delta-b-1-h-%E4%B8%8E-Delta-b-2-j"><span class="toc-text">3）计算偏置  $\Delta b^{(1)}_h$ 与 $\Delta b^{(2)}_j$</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84BP"><span class="toc-text">残差网络中的BP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%85%A8%E5%B1%80%E6%9C%80%E5%B0%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E6%9E%81%E5%B0%8F"><span class="toc-text">5.4 全局最小与局部极小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="toc-text">5.5 深度学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E2%80%9C%E9%A2%84%E8%AE%AD%E7%BB%83-%E5%BE%AE%E8%B0%83%E2%80%9D"><span class="toc-text">1）“预训练+微调”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E2%80%9C%E6%9D%83%E5%85%B1%E4%BA%AB%E2%80%9D"><span class="toc-text">2）“权共享”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%80%9D%E8%80%83%E4%B8%8E%E5%BD%92%E7%BA%B3"><span class="toc-text">5.6 思考与归纳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-text">第6章 支持向量机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9E%8B"><span class="toc-text">6.1 支持向量机的基本型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-text">基本分类问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%94%E4%B8%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F"><span class="toc-text">间隔与支持向量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98"><span class="toc-text">6.2 对偶问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E6%B1%82%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98"><span class="toc-text">使用拉格朗日乘子法求对偶问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KKT%E6%9D%A1%E4%BB%B6"><span class="toc-text">KKT条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="toc-text">6.3 核函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%B0%86%E4%BD%8E%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%88%B0%E9%AB%98%E7%BB%B4%E7%A9%BA%E9%97%B4"><span class="toc-text">核技巧：将低维数据映射到高维空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="toc-text">核函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E8%BD%AF%E9%97%B4%E9%9A%94"><span class="toc-text">6.4 软间隔</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E9%97%B4%E9%9A%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-text">软间隔支持向量机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E9%97%B4%E9%9A%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%9A%84%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98"><span class="toc-text">软间隔支持向量机的对偶问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%BA%8F%E5%88%97%E6%9C%80%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-text">6.5 序列最小优化算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%AF%E5%8F%91%E5%BC%8F%E6%96%B9%E6%B3%95%E9%80%89%E5%8F%96%E5%BE%85%E4%BC%98%E5%8C%96%E5%8F%98%E9%87%8F-alpha-i-%E5%92%8C-alpha-j"><span class="toc-text">使用启发式方法选取待优化变量 $\alpha_i$ 和 $\alpha_j$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90%E6%B3%95%E8%AE%A1%E7%AE%97-alpha-i-%E5%92%8C-alpha-j-%E7%9A%84%E6%9C%80%E4%BC%98%E8%A7%A3%E5%B9%B6%E7%A1%AE%E5%AE%9A%E5%81%8F%E7%A7%BB%E9%A1%B9-b"><span class="toc-text">使用解析法计算 $\alpha_i$ 和 $\alpha_j$ 的最优解并确定偏移项 $b$</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89"><span class="toc-text">6.6 支持向量回归（SVR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E6%A0%B8%E6%96%B9%E6%B3%95"><span class="toc-text">6.7 核方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E6%80%9D%E8%80%83%E4%B8%8E%E5%BD%92%E7%BA%B3"><span class="toc-text">6.8 思考与归纳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-text">第7章 贝叶斯分类器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%86%B3%E7%AD%96%E8%AE%BA"><span class="toc-text">7.1 贝叶斯决策论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-text">贝叶斯分类器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="toc-text">7.2 极大似然估计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="toc-text">基本原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-text">7.3 朴素贝叶斯分类器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-2"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%B0%E8%AE%A1%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87%E4%B8%8E%E7%B1%BB%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87"><span class="toc-text">估计先验概率与类条件概率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-text">半朴素贝叶斯分类器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91"><span class="toc-text">7.5 贝叶斯网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-%E7%BB%93%E6%9E%84%EF%BC%88%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="toc-text">7.5.1 结构（重点掌握）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-%E5%AD%A6%E4%B9%A0"><span class="toc-text">7.5.2 学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3-%E6%8E%A8%E6%96%AD"><span class="toc-text">7.5.3 推断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-EM%E7%AE%97%E6%B3%95"><span class="toc-text">7.6 EM算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-%E5%8A%A8%E6%9C%BA%EF%BC%9A%E9%9A%90%E5%8F%98%E9%87%8F"><span class="toc-text">7.6.1 动机：隐变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-EM%E7%AE%97%E6%B3%95"><span class="toc-text">7.6.1 EM算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E6%80%9D%E8%80%83%E4%B8%8E%E5%BD%92%E7%BA%B3"><span class="toc-text">7.7 思考与归纳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0"><span class="toc-text">第8章 集成学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E4%B8%AA%E4%BD%93%E4%B8%8E%E9%9B%86%E6%88%90"><span class="toc-text">8.1 个体与集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Boosting"><span class="toc-text">8.2 Boosting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Bagging%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97"><span class="toc-text">8.3 Bagging与随机森林</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-Bagging"><span class="toc-text">8.3.1 Bagging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97"><span class="toc-text">8.3.2 随机森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">8.3.3 性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%BB%93%E5%90%88%E7%AD%96%E7%95%A5"><span class="toc-text">8.4 结合策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E8%81%9A%E7%B1%BB"><span class="toc-text">第9章 聚类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E8%81%9A%E7%B1%BB%E4%BB%BB%E5%8A%A1"><span class="toc-text">9.1 聚类任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F"><span class="toc-text">9.2 性能度量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97"><span class="toc-text">9.3 距离计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%8E%9F%E5%9E%8B%E8%81%9A%E7%B1%BB"><span class="toc-text">9.4 原型聚类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-k-%E5%9D%87%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-text">9.4.1 $k$ 均值算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-3"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-1"><span class="toc-text">算法流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E5%AD%A6%E4%B9%A0%E5%90%91%E9%87%8F%E9%87%8F%E5%8C%96"><span class="toc-text">9.4.2 学习向量量化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-4"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-2"><span class="toc-text">算法流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-3-%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E8%81%9A%E7%B1%BB"><span class="toc-text">9.4.3 高斯混合聚类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-5"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%92%E5%88%86%E8%BF%87%E7%A8%8B%E2%80%94%E2%80%94EM%E7%AE%97%E6%B3%95"><span class="toc-text">划分过程——EM算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-x-%E5%AF%86%E5%BA%A6%E8%81%9A%E7%B1%BB"><span class="toc-text">9.x 密度聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-x-%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB"><span class="toc-text">9.x 层次聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E6%80%9D%E8%80%83%E4%B8%8E%E5%BD%92%E7%BA%B3"><span class="toc-text">9.6 思考与归纳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E9%99%8D%E7%BB%B4"><span class="toc-text">第10章 降维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-k%E8%BF%91%E9%82%BB%E5%AD%A6%E4%B9%A0"><span class="toc-text">10.1 k近邻学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E4%BD%8E%E7%BB%B4%E5%B5%8C%E5%85%A5"><span class="toc-text">10.2 低维嵌入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90"><span class="toc-text">10.3 主成分分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%9C%80%E8%BF%91%E9%87%8D%E6%9E%84%E6%80%A7"><span class="toc-text">10.3.1 最近重构性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-%E6%9C%80%E5%A4%A7%E5%8F%AF%E5%88%86%E6%80%A7"><span class="toc-text">10.3.2 最大可分性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-4-PCA%E7%9A%84%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-text">10.3.4 PCA的算法过程</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/012.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
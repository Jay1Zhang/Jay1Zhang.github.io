<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「计网」04-网络层 | J1z's Blog</title><meta name="keywords" content="961"><meta name="author" content="Jay"><meta name="copyright" content="Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Chapter4 - 网络层本章最重要的内容是：  虚拟互联网络的概念 IP地址与物理地址的关系 传统的分类的IP地址（包括子网掩码）和无分类域间路由选择CIDR 路由选择协议的工作原理  4.1 网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务？ 两种选择：面向连接 or 无连接 争论焦点的实质：数据的可靠传输应该由网络还是端系统来负责？   面向连接的服务，即虚电路（v">
<meta property="og:type" content="article">
<meta property="og:title" content="「计网」04-网络层">
<meta property="og:url" content="http://jay1zhang.github.io/2020/12/31/BUAA/Computer%20Network/%E3%80%8C%E8%AE%A1%E7%BD%91%E3%80%8D04-%E7%BD%91%E7%BB%9C%E5%B1%82/index.html">
<meta property="og:site_name" content="J1z&#39;s Blog">
<meta property="og:description" content="Chapter4 - 网络层本章最重要的内容是：  虚拟互联网络的概念 IP地址与物理地址的关系 传统的分类的IP地址（包括子网掩码）和无分类域间路由选择CIDR 路由选择协议的工作原理  4.1 网络层提供的两种服务 在计算机网络领域，网络层应该向运输层提供怎样的服务？ 两种选择：面向连接 or 无连接 争论焦点的实质：数据的可靠传输应该由网络还是端系统来负责？   面向连接的服务，即虚电路（v">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/002.jpg">
<meta property="article:published_time" content="2020-12-31T04:00:04.000Z">
<meta property="article:modified_time" content="2021-01-02T03:55:09.103Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="961">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/002.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jay1zhang.github.io/2020/12/31/BUAA/Computer%20Network/%E3%80%8C%E8%AE%A1%E7%BD%91%E3%80%8D04-%E7%BD%91%E7%BB%9C%E5%B1%82/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKEK6XV2V5","apiKey":"e093fbb9f29fdf5c7ddd56ec43e9ae05","indexName":"Jay","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-02 11:55:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/002.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1z's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「计网」04-网络层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-31T04:00:04.000Z" title="Created 2020-12-31 12:00:04">2020-12-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-01-02T03:55:09.103Z" title="Updated 2021-01-02 11:55:09">2021-01-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/">BUAA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/Computer-Network/">Computer Network</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">14.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>46min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter4-网络层"><a href="#Chapter4-网络层" class="headerlink" title="Chapter4 - 网络层"></a>Chapter4 - 网络层</h1><p>本章最重要的内容是：</p>
<ol>
<li>虚拟互联网络的概念</li>
<li>IP地址与物理地址的关系</li>
<li>传统的分类的IP地址（包括子网掩码）和无分类域间路由选择CIDR</li>
<li>路由选择协议的工作原理</li>
</ol>
<h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h2><ul>
<li>在计算机网络领域，网络层应该向运输层提供怎样的服务？<ul>
<li>两种选择：面向连接 or 无连接</li>
<li>争论焦点的实质：<strong>数据的可靠传输应该由网络还是端系统来负责？</strong></li>
</ul>
</li>
<li>面向连接的服务，即<strong>虚电路（virtual circuit）</strong><ul>
<li>通信双方在开始数据传输前，先<strong>由网络建立连接</strong>（在分组交换中是建立一条虚电路），之后的数据均通过该连接进行，由网络保证数据传输的可靠性</li>
<li>虚电路只是一种<strong>逻辑连接</strong>，分组沿着这条逻辑连接按照存储转发方式传送 ，而并不是真正建立了一条物理连接。这样分组的首部不需要填写完整的<strong>目的主机地址</strong>，而只需要填写这条<strong>虚电路的编号</strong>，因而<strong>减少了分组的开销</strong>。</li>
<li>这种通信方式如果再<strong>使用可靠的网络协议</strong>，就可使所发送的分组<strong>无差错按序</strong>到达终点。</li>
<li>支持方：以<strong>电信公司</strong>为代表的一派</li>
</ul>
</li>
<li>无连接的服务，即<strong>数据报（datagram）</strong><ul>
<li>设计思路：<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。（这里数据报就是分组packet）</li>
<li>网络在发送分组时不需要先建立连接，每个分组独在网络中独立发送，与其前后的分组无关（不进行编号）。</li>
<li><strong>网络层不提供服务质量的承诺</strong>。也就是说，分组可能出错、丢失、重复和失序，也不保证分组交付的时限。由网络主机中的<strong>运输层负责可靠传输</strong>（包括差错处理、流量控制）。</li>
<li>好处：网络造价大大降低，运行方式灵活，能够适应多种应用。</li>
<li>支持方：以<strong>Internet</strong>为代表的一派</li>
</ul>
</li>
<li><strong>TCP/IP采用数据报服务</strong></li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-24_11-30-35.png"></p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-24_11-31-43.png"></p>
<h2 id="4-2-网际协议"><a href="#4-2-网际协议" class="headerlink" title="4.2 网际协议"></a>4.2 网际协议</h2><h3 id="一、IP（Internet-Protocol）简介"><a href="#一、IP（Internet-Protocol）简介" class="headerlink" title="一、IP（Internet Protocol）简介"></a>一、IP（Internet Protocol）简介</h3><ul>
<li>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，也是最重要的互联网标准协议之一。<ul>
<li>严格来说，这里所讲的 IP 其实是 IP 的第四个版本，即 IPv4。</li>
<li>由于网际协议 IP 是用来使互联起来的多个计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为<strong>网际层</strong>（Internet layer）。</li>
</ul>
</li>
<li>与 IP 协议配套使用的还有四个<br>协议：<ul>
<li><strong>地址解析协议ARP</strong> (Address Resolution Protocol)</li>
<li><strong>逆地址解析协议RARP</strong> (Reverse Address Resolution Protocol)<del>(已淘汰)</del></li>
<li><strong>网际控制报文协议ICMP</strong> (Internet Control Message Protocol)</li>
<li><strong>网际组管理协议IGMP</strong> (Internet Group Management Protocol)</li>
</ul>
</li>
<li>这几个协议之间的关系如下：<ul>
<li>ARP画在最下面，因为IP经常要使用这个协议。</li>
<li>ICMP和IGMP画在这一层的上部，因为它们要使用IP协议。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-24_11-46-03.png"></p>
<h4 id="实例-Linux中接收-发送包的调用图"><a href="#实例-Linux中接收-发送包的调用图" class="headerlink" title="实例 - Linux中接收/发送包的调用图"></a>实例 - Linux中接收/发送包的调用图</h4><ul>
<li>包接收：<ol>
<li>网络接口卡(NIC)收到帧后触发中断</li>
<li>中断服务程序调用net_rx_action()接收帧</li>
<li>调用网络层接口函数netif_receive_skb()将帧中数据交给网络层</li>
<li>包被注册到sk_buff中以便后续处理<ul>
<li>如为IP协议包则调用ip_rcv()作协议处理</li>
<li>如包是发给本机的，则调用ip_local_deliver()和ip_local_deliver_finish()将数据交给传输层</li>
</ul>
</li>
</ol>
</li>
<li>包发送：<ol>
<li>根据传输层协议不同，分别调用接口函数ip_append_data()、ip_append_page()或ip_queue_xmit()将数据交给传输层</li>
<li>调用dst_output()，将包注册到sk_buff<ul>
<li>如为IP包，则调用ip_output()</li>
<li>如不分片，则ip_finish_output2()调用net_tx_action()将包交给数据链路层</li>
</ul>
</li>
<li>调用网卡驱动程序接口函数发送帧，帧发送完毕后通常会产生中断通知上层</li>
</ol>
</li>
<li>注：<ul>
<li>sk_buff是Linux中用于存储和处理包的数据结构，采用<strong>双向链表结构</strong>。通过使用sk_buff，无需在各层间和程序模块间复制数据，而只需传递指针。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-24_11-58-06.png"></p>
<h3 id="二、虚拟互联网络"><a href="#二、虚拟互联网络" class="headerlink" title="二、虚拟互联网络"></a>二、虚拟互联网络</h3><p>在讨论网际协议IP之前，必须了解什么是虚拟互连网络。</p>
<p>由于用户的需求是多种多样的，<strong>没有一种单一的网络能够适应所有用户的需求</strong>。另外，网络技术是不断发展的。因此在市场上总是有很多种<strong>不同性能、不同网络协议</strong>的网络，供不同的用户选用。</p>
<ul>
<li><p>从一般的概念来讲，将网络互相连接起来要使用一些<strong>中间设备</strong>：</p>
<ol>
<li>物理层使用的中间设备叫做<strong>转发器（repeater）</strong>。</li>
<li>数据链路层使用的中间设备叫做<strong>网桥或桥接器（bridge）</strong>。</li>
<li>网路层使用的中间设备叫做<strong>路由器（router）</strong>。</li>
<li>在网络层以上使用的中间设备叫做<strong>网关（gateway）</strong>。用网关连接两个不兼容的系统需要在高层进行<strong>协议的转换</strong>。</li>
</ol>
</li>
<li><p>其中，网关由于比较复杂，目前使用得较少，因此目前的<strong>网络互连都是指用路由器进行网络互连和路由选择</strong>。</p>
<ul>
<li>由于历史原因，许多有关 TCP/IP 的文献曾经把网络层使用的<strong>路由器</strong>称为网关。</li>
</ul>
</li>
</ul>
<p>下图(a)表示有许多计算机网络通过一些<strong>路由器</strong>进行互连。由于参加互连的计算机网络都是用相同的<strong>网际协议IP</strong>（Internet Protocol），因此可以把互连以后的计算机网络看成如图(b)所示的一个<strong>虚拟互连网络</strong>（Internet），也就是逻辑互联网络。</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-24_19-17-05.png"></p>
<p>这种使用IP协议的虚拟互连网络可简称为<strong>IP网</strong>，下面看一个实例。</p>
<ul>
<li>在如图所示的互联网中的源主机H1要把一个IP数据报发送给目的主机H2。<ol>
<li>主机H1先要查找自己的路由表，看目的主机是否在本网络上。<ul>
<li>如是，则不需要经过任何路由器而是<strong>直接交付</strong>；</li>
<li>如不是，则必须把IP数据报发送给某个<strong>路由器（图中R1）</strong>。</li>
</ul>
</li>
<li>R1在查找了自己的路由表后，知道应当把数据报转发给R2进行<strong>间接交付</strong>。</li>
<li>这样一直转发下去，最后路由器R5知道自己是和H2连接在同一个网络上，于是把数据报<strong>直接交付</strong>给目的主机H2.</li>
</ol>
</li>
<li>注意<ul>
<li><strong>主机的协议栈共有五层，而路由器的协议栈只有下三层</strong>。</li>
<li>R4和R5之间使用了卫星链路，而R5所连接的是个无线局域网。</li>
<li>R1到R4之间的三个网络可以使任意类型的，即<strong>互联网可以由多种异构网络互连组成</strong>。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-24_19-23-43.png"></p>
<h3 id="三、分类的IP地址"><a href="#三、分类的IP地址" class="headerlink" title="三、分类的IP地址"></a>三、分类的IP地址</h3><p>在 TCP/IP 体系中，IP地址是一个最基本的概念，有关IP最重要的文档是<strong>互联网的正式标准 RFC 797</strong>。</p>
<h4 id="1-IP地址及其表示方法"><a href="#1-IP地址及其表示方法" class="headerlink" title="1. IP地址及其表示方法"></a>1. IP地址及其表示方法</h4><ul>
<li><p><strong>IP 地址</strong></p>
<ul>
<li>分配给主机或路由器的标识符，目前使用的IPv4为32位IP地址</li>
<li>IP 地址的分配由<strong>ICANN</strong> (Internet Corporation for Assigned Names and Numbers)负责</li>
</ul>
</li>
<li><p><strong>IP地址的编址方法</strong>经历了三个阶段：（本节仅讨论 1.，后两种方法在4.3节讨论）</p>
<ol>
<li><p><strong>分类的 IP 地址</strong>：最基本的编址方法，1981 年通过标准</p>
</li>
<li><p><strong>子网的划分</strong>：最基本编址方法的改进， 1985 年成为标准[RFC 950]</p>
</li>
<li><p><strong>构成超网</strong>：比较新的无分类编址方法，1993 年提出后很快得到应用</p>
</li>
</ol>
</li>
<li><p><strong>分类的IP地址</strong></p>
<ul>
<li>IP地址被划分为若干个固定类，每一类地址都包含网络号(net-id)和主机号(host-id)两个字段。<ul>
<li><strong>网络号</strong>标志主机（或路由器）所连接到的网络，一个网络号在<strong>整个互联网范围内</strong>必须是<strong>唯一</strong>的。</li>
<li><strong>主机号</strong>标志该主机（或路由器），一台主机号在它前面的网络号所指明的<strong>网络范围内</strong>必须是<strong>唯一</strong>的</li>
<li>这种两级的IP地址可以记为：IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt;} </li>
</ul>
</li>
<li>不同类的IP地址区别主要是网络号、主机号的<strong>长度不同</strong>，下图给出了各种IP地址的网络号字段和主机号字段：<ul>
<li>A类、B类和C类地址都是<strong>单播地址</strong>（一对一通信），最常用。</li>
<li>A类、B类和C类地址的网络字段号分别为1个、2个和3个字节长，而在网络号字段的最前面有 1~3 位的类别位，其数值分别规定为 0，10和110。</li>
<li>A类、B类和C类地址的主机号字段分别为3个、2个和1个字节长。</li>
<li>D类地址（前4位是1110）用于<strong>多播</strong>（一对多通信），4.6节讨论IP多播。</li>
<li>E类地址（前4位1111）保留为以后用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_09-00-00.png"></p>
<ul>
<li><strong>IP地址的表示方法</strong><ul>
<li><strong>点分十进制记法</strong>（dotted decimal notation），下图是一个<strong>B类IP地址</strong>的表示方法。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_09-14-44.png"></p>
<h4 id="2-常用的三种类别的IP地址"><a href="#2-常用的三种类别的IP地址" class="headerlink" title="2. 常用的三种类别的IP地址"></a>2. 常用的三种类别的IP地址</h4><ul>
<li><strong>A类地址</strong><ul>
<li>网络号字段占1个字节，只有7位可供使用（第一位已固定为0），可指派的网络号为126个（即 $2^7 - 2$ 个）。减2的原因是：<ol>
<li>IP地址中的全0为保留地址，表示“<strong>本网络</strong>”。</li>
<li>网络号为127（即 01111111）保留作为本地软件<strong>环回测试（loopback test）</strong> 本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的IP数据报，则本主机中的协议软件<u>仅处理数据，而不会将其发送到任何网络</u>。</li>
</ol>
</li>
<li>主机号字段占3个字节，最大主机数为 $2^{24} - 2$ 个（即 16777214个）。减2的原因是：<ol>
<li>全0的主机号字段表示该IP地址是 <strong>“本主机”所连接到的单个网络地址</strong> 。例如，主机IP地址为 5.6.7.8，则该主机所在网络地址即为 5.0.0.0。</li>
<li>全1表示“<strong>所有的(all)**”，即</strong>该网络上的所有主机**。</li>
</ol>
</li>
<li>IP地址空间共有 $2^{32}$ 个地址，整个A类空间共有 $2^{31}$ 个地址，占整个IP地址空间的50%。</li>
</ul>
</li>
<li><strong>B类地址</strong><ul>
<li>网络号字段有2个字节，前两位（1 0）固定，只有14位可以分配。<ul>
<li>由于B类地址不可能出现整个2字节为全0或全1，因此不存在网络总数减2的问题。但实际上B类网络的<strong>128.0是不指派的</strong>，而可以指派的B类网络最小网络地址为 128.1 [COME06]，因此可指派的网络数为 $2^{14} - 1$ （即16383）。</li>
</ul>
</li>
<li>B类网络最大主机数为 $2^{16} - 2$ ，即65534。这里减2的原因是要<strong>扣除全0和全1的主机号</strong>。</li>
<li>整个B类地址空间共约有 $2^{30}$ 个地址，占整个IP地址空间的25%。</li>
</ul>
</li>
<li><strong>C类地址</strong><ul>
<li>网络号字段有3个字节，前面3位（1 1 0）固定，还有21位可以进行分配。<ul>
<li>C类网络地址 192.0.0 也是不指派的，可以指派的C类最小网络地址是 192.0.1 [COME06]，因此可指派的网络总数是 $2^{21} - 1$，即2097151.</li>
</ul>
</li>
<li>最大主机数为 $2^8 - 2$ ，即254。</li>
<li>整个C类地址空间共约有 $2^{29}$ 个地址，占整个IP地址空间的12.5%。</li>
</ul>
</li>
<li>这样我们就可得出IP地址的指派范围，如下表所示：</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_10-22-22.png"></p>
<ul>
<li><strong>IP地址的特点</strong><ol>
<li>IP地址是一种<strong>分等级的地址结构</strong>。好处是：第一，IP地址管理机构只分配网络号，而主机号由各网络单位自行分配；第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>，而不考虑目的主机号，从而<strong>大大减少了路由表所占的存储空间以及查找路由表的时间</strong>。</li>
<li>实际上IP地址是标志以太主机和一条链路的<strong>接口</strong>。当一台主机同时连接到两个网络上时，该主机必须同时拥有两个IP地址，这种称为<strong>多归属主机</strong>（multihomed host）。</li>
<li>一个网络指具有相同网络号（net-id）的主机的集合，因此，用<strong>转发器或网桥连接起来的若干个局域网仍为同一个网络</strong>，<strong>具有不同网络号的局域网必须使用路由器进行互连</strong>。</li>
<li>在IP地址中，所有网络都是<strong>平等</strong>的，即互联网同等对待每一个IP地址。</li>
</ol>
</li>
</ul>
<h3 id="四、IP地址与硬件地址"><a href="#四、IP地址与硬件地址" class="headerlink" title="四、IP地址与硬件地址"></a>四、IP地址与硬件地址</h3><ul>
<li><strong>物理地址</strong><ul>
<li>数据链路层和物理层使用的地址。</li>
<li>存放在数据链路层的MAC帧中。</li>
</ul>
</li>
<li><strong>IP地址</strong><ul>
<li>网络层和以上各层使用的地址，是一种逻辑地址。</li>
<li>存放在IP包头部</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_10-32-14.png"></p>
<ul>
<li><strong>从不同层次上看IP地址和硬件地址</strong><ul>
<li>下图是用两个路由器连起来的三个局域网，现主机H1要和主机H2通信。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_11-21-36.png"></p>
<ul>
<li>这里要强调以下几点：  <ol>
<li><strong>在IP层抽象的互联网上只能看到IP数据报</strong>。首部中的源地址和目的地址<strong>始终为IP1和IP2</strong>，而中间经过的两个路由表的IP地址并不出现在IP数据报的首部。</li>
<li><strong>在局域网的链路层，只能看见MAC帧</strong>。MAC帧在不同网络上传送时，其MAC帧首部的源地址和目的地址要<strong>发生变化</strong>。</li>
<li>另外，虽然IP数据报首部有源站IP地址，但路由器只<strong>根据目的站的IP地址的网络号</strong>进行路由选择。</li>
</ol>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_11-29-35.png"></p>
<ul>
<li><strong>新的问题</strong>：  <ol>
<li>主机或路由器是怎样知道应当在MAC帧的首部填入什么样的硬件地址？（见下一节ARP协议）</li>
<li>路由器中的路由表是怎样得出的？（见4.5节路由选择协议）</li>
</ol>
</li>
</ul>
<h3 id="五、地址解析协议ARP"><a href="#五、地址解析协议ARP" class="headerlink" title="五、地址解析协议ARP"></a>五、地址解析协议ARP</h3><ul>
<li>ARP协议(Address Resolution Protocol)<ul>
<li>ARP协议的用途是<strong>为了从网络层使用的IP地址，解析出在数据链路层使用的硬件地址</strong>。</li>
<li>主机设有一个<strong>ARP高速缓存</strong>(ARP cache)，存有本地局域网上各主机和路由器的 IP 地址与硬件地址的映射表。且对保存在高速缓存中的每一个映射地址项目都设置<strong>生存时间</strong>，凡超过生存时间的项目就从高速缓存中<strong>删除</strong>。</li>
<li>当主机 A 欲向本局域网上的主机B发送IP包时<ol>
<li>先在其ARP高速缓存中查看有无主机B的IP地址</li>
<li>如有，就可查出其对应的硬件地址，再将此<strong>硬件地址写入MAC帧</strong>，通过局域网发送</li>
<li>如无，则在本局域网中<strong>广播一个ARP请求分组</strong>。</li>
<li>当主机B收到ARP请求后，向主机A返回一个<strong>ARP响应分组（单播）</strong>，告知自己的物理地址。</li>
</ol>
</li>
<li>ARP解决<strong>同一局域网</strong>中的主机或路由器的 IP 地址和硬件地址的映射问题。如果目的主机不在本局域网内，IP包需经由<strong>路由器</strong>转发。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_13-47-29.png"></p>
<h3 id="六、IP数据报格式"><a href="#六、IP数据报格式" class="headerlink" title="六、IP数据报格式"></a>六、IP数据报格式</h3><p>如下图所示，一个IP数据报由首部和数据两部分组成。首部的前一部分是<strong>固定长度</strong>，共20字节，是所有IP数据报必须具有的。在首部的固定部分后面是一些<strong>可选字段</strong>，其长度是可变的。</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_15-29-07.png"></p>
<p>英文版如下：</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_15-44-47.png"></p>
<p>下面介绍首部各字段的意义。</p>
<h4 id="1-IP数据报首部的固定部分中的各字段"><a href="#1-IP数据报首部的固定部分中的各字段" class="headerlink" title="1. IP数据报首部的固定部分中的各字段"></a>1. IP数据报首部的固定部分中的各字段</h4><ol>
<li><strong>版本（Version）</strong><ul>
<li>占4bit。指 IP 协议的版本，目前的 IP 协议版本号为 4 (即 IPv4)。</li>
</ul>
</li>
<li><strong>首部长度（IHL）</strong><ul>
<li>占4bit。指 IP 包头长度，最小5，最大15，单位为word(32bit)。因此 IP包头最长60 字节。</li>
<li>由于大部分IP数据报的可选字段为0，即<strong>首部长度为5个字</strong>（20字节），因此我们经常可以看到IP数据报<strong>由 4 5 开头</strong>。</li>
<li>当首部长度不是4字节的整数倍时，必须<strong>利用最后的填充字段加以填充</strong>。因此IP数据报的<strong>数据部分永远在4字节的整数倍时开始</strong>。</li>
</ul>
</li>
<li><strong>区分服务（Type of service）</strong><ul>
<li>占1字节，用来获得更好的服务。在旧标准中叫做<strong>服务类型</strong>，1998年IETF改名为<strong>区分服务DS</strong>（Differentiated Services）。在一般情况下都不使用这个字段。</li>
</ul>
</li>
<li><strong>总长度（Total length）</strong><ul>
<li>指首部和数据之和的长度。占2字节，因此IP包的最大长度为 64K（即65535） 字节。然而实际上传送这样长的数据报在现实中极少遇到。</li>
<li>每一种数据链路层协议都规定了一个数据帧中的<strong>数据字段的最大长度</strong>，这称为<strong>最大传送单元MTU</strong>（Maximumm Transfer Unit）。当数据报的总长度超过 MTU 的值时，就必须把过长的数据报进行<strong>分片处理</strong>。</li>
<li>此时，该字段是指<strong>分片后的每一个分片</strong>的首部长度与该分片的数据长度的总和。</li>
</ul>
</li>
<li><strong>标识（identification）</strong><ul>
<li>占2字节。IP软件在存储器中维护一个<strong>计数器</strong>，每产生一个数据报，计数器就加1，并将此值赋给标识字段。<ul>
<li>注意这个“标识”并不是序号，因为IP是<strong>无连接服务</strong>，数据报<strong>不存在按序接收的问题</strong>。</li>
</ul>
</li>
<li>当数据报由于长度超过 MTU 而必须分片时，<strong>分片的多个包标识字段相同</strong>，便于接收端重组。</li>
</ul>
</li>
<li><strong>标志（flag）</strong><ul>
<li>占3位，但目前只有两位有意义。<ul>
<li>DF（Don’t Fragment）：<strong>不能分片</strong>，只有当 DF = 0 时才允许分片。</li>
<li>MF（More Fragment）：MF = 1 即表示后面“<strong>还有分片</strong>”；MF = 0 表示这是若干分片的最后一个。</li>
</ul>
</li>
</ul>
</li>
<li><strong>片偏移（Fragment offset）</strong><ul>
<li>占13bit，指出较长的包在分片后，<strong>某片在原分组中的相对位置</strong>。也就是说，相对于用户数据字段的起点，该片从何处开始。</li>
<li>以8字节为偏移单位。也就是说，每个分片的长度一定是8字节的整数倍。</li>
</ul>
</li>
</ol>
<p>【<strong>分片举例</strong>】：一数据报总长度为3820字节，数据部分为3800字节长（使用固定首部），需要分片为长度不超过 1420字节的数据报片。于是数据部分长度分别为 1400，1400，1000字节，结果如下：</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_16-38-35.png"></p>
<p>下表是本例中数据报首部与分片有关的字段中的数值，其中标识字段的值为任意给定的（12345）。</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_16-39-04.png"></p>
<ol start="8">
<li><strong>生存时间（Time to live）</strong><ul>
<li>占1字节，表明数据报在网络中<strong>可通过的路由器个数的最大值</strong>，因而后来又称为“<strong>跳数限制</strong>”。目的是防止无法交付的数据报无限制地在互联网中<strong>兜圈子</strong>。</li>
<li>路由器在每次转发数据报之前就把TTL值减1。若为0则丢弃，并向源主机发送一个<strong>告警包</strong>。</li>
<li>显然数据报在互联网中经过的路由器的<strong>最大数值为255</strong>。由源主机设定初始值，Windows操作系统一般为128，UNIX操作系统一般为255，Linux一般为64</li>
</ul>
</li>
<li><strong>协议（Protocol）</strong><ul>
<li>占8bit，指出此数据报携带的数据时何种协议，以便使目的主机的IP层知道应该将数据部分上交给哪个协议进行处理。</li>
<li>常用的一些协议和相应的协议字段值如下：</li>
</ul>
</li>
</ol>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_16-50-23.png"></p>
<ol start="10">
<li><p><strong>首部校验和（Header checksum）</strong></p>
<ul>
<li>占2字节。这个字段<strong>只检验数据报的首部</strong>，不包括数据部分。</li>
<li>IP首部的校验和不采用复杂的CRC检验码而采用下面的简单计算方法：</li>
</ul>
<blockquote>
<ul>
<li>在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段<strong>置零</strong>。用<strong>反码算数运算</strong>把所有16位字相加后，将得到的<strong>和的取反码</strong>写入检验和字段。</li>
<li>接收方收到数据报后，将首部的所有16位字再使用<strong>反码算数运算</strong>相加一次，将得到的<strong>和取反码</strong>，即得出接收方检验和的计算结果。若首部未发生任何变化，则结果必为0。否则认为出差错，丢弃该包。</li>
</ul>
</blockquote>
</li>
</ol>
<p>【<strong>校验和举例</strong>】下图说明了IP数据报首部检验和的计算过程。        </p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_17-09-34.png"></p>
<p>【问】IP包在网络中传输过程中，何时检查校验和？何时计算填写校验和？</p>
<p>【答】路由器在接收到IP数据报时，应先检验校验和，再令TTL 减1。最后将校验和字段置0后再重新计算一次校验和。</p>
<ol start="11">
<li><strong>源地址（Source address）</strong><ul>
<li>占4字节，源IP地址。</li>
</ul>
</li>
<li><strong>目的地址（Destination address）</strong><ul>
<li>占4字节，目的IP地址。</li>
</ul>
</li>
</ol>
<h4 id="2-IP数据报首部的可变部分"><a href="#2-IP数据报首部的可变部分" class="headerlink" title="2. IP数据报首部的可变部分"></a>2. IP数据报首部的可变部分</h4><p>可变部分就是一个选项字段，用来支持<strong>排错、测量以及安全</strong>等措施。此字段长度可变，从1个字节到40个字节不等，这就增加了路由器处理数据报的开销。因此实际上这些选项很少被使用。</p>
<h3 id="七、IP层转发分组的流程"><a href="#七、IP层转发分组的流程" class="headerlink" title="七、IP层转发分组的流程"></a>七、IP层转发分组的流程</h3><p>略，见教材P142。</p>
<h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h2><h3 id="一、划分子网"><a href="#一、划分子网" class="headerlink" title="一、划分子网"></a>一、划分子网</h3><h4 id="1-从两级IP地址到三级IP地址"><a href="#1-从两级IP地址到三级IP地址" class="headerlink" title="1. 从两级IP地址到三级IP地址"></a>1. 从两级IP地址到三级IP地址</h4><ul>
<li><strong>两级IP地址的缺点</strong>：<ol>
<li>IP地址空间的利用率有时很低。<ul>
<li>A类地址的主机数超过1000万，B类地址也超过6万</li>
</ul>
</li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级IP地址不够灵活。</li>
</ol>
</li>
<li>1985年起，增加子网字段，形成三级IP地址。<ul>
<li>RFC 950: Internet Standard Subnetting Procedure</li>
</ul>
</li>
<li><strong>划分子网的基本思路</strong>如下：<ol>
<li>拥有多个物理网络的单位可按物理网络划分为若干个子网(subnet)</li>
<li>划分方法为：从主机号借用若干位作为<strong>子网号</strong>（subnet-id），于是两级IP地址在本单位内部就变为了<strong>三级IP地址</strong>，记为：<ul>
<li>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}</li>
</ul>
</li>
<li>从其他网络发来的IP数据报，仍然根据IP数据报的目的网络号（net-id），找到本网络的路由器。此路由器收到IP数据报后，再按目的网络号（net-id）和子网号subnet-id找到目的子网。</li>
</ol>
</li>
</ul>
<p>【划分子网举例】</p>
<h4 id="2-子网掩码"><a href="#2-子网掩码" class="headerlink" title="2. 子网掩码"></a>2. 子网掩码</h4><ul>
<li>子网掩码的提出<ul>
<li>从IP数据报的首部<strong>无法看出</strong>源主机或目的主机所连接的网络是否进行了子网的划分。因此，提出了<strong>子网掩码（subnet mask）</strong>。</li>
</ul>
</li>
<li>使用子网掩码的好处：<ul>
<li>不管网络有没有划分子网，只要把<strong>子网掩码和IP地址执行“按位与”运算</strong>，即得到子网地址，见下图。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_19-42-57.png"></p>
<ul>
<li><strong>默认子网掩码</strong>：1的位置和IP地址中的网络号字段 net-id 正好相对应。<ul>
<li>A类地址的默认子网掩码是 255.0.0.0;</li>
<li>B类地址的默认子网掩码是 255.255.0.0;</li>
<li>C类地址的默认子网掩码是 255.255.255.0;</li>
</ul>
</li>
<li><strong>补充</strong>：<ul>
<li>子网掩码是一个网络或一个子网的重要属性。</li>
<li>在RFC 950称为互联网的正式标准后，规定了所有网络都必须使用子网掩码。路由器的路由表中的每个表项除了包含目的网络地址外，还要有<strong>子网掩码栏目</strong>。</li>
<li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li>
</ul>
</li>
</ul>
<p>【子网掩码举例】</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_21-03-26.png"></p>
<h4 id="2-使用子网掩码的分组转发过程"><a href="#2-使用子网掩码的分组转发过程" class="headerlink" title="2. 使用子网掩码的分组转发过程"></a>2. 使用子网掩码的分组转发过程</h4><p>在划分子网的情况下，路由表必须包含：<strong>目的网络地址、子网掩码和下一跳地址</strong>。<strong>路由器转发分组的算法</strong>的<strong>核心操作</strong>为：将目的IP地址与路由表中子网掩码“与”，并判断是否与目的网络匹配，具体步骤如下：</p>
<p>① 从收到的分组的首部提取<strong>目的IP地址D</strong><br>② 先用与该路由器直接相连各网络的子网掩码和D逐位相“与”，看是否和相应<br>的网络地址匹配，若匹配，则将分组<strong>直接交付</strong>（当然还需要把D转换成物理地址，把数据报封装成帧发送出去），转发任务结束；否则就是<strong>间接交付</strong>，执行③<br>③ 若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路<br>由器；否则执行④<br>④ 对路由表中的<strong>每一行</strong>的子网掩码和 D 逐位相“与”，若其结果与该行的目的<br>网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则执行⑤<br>⑤ 若路由表中有一个<strong>默认路由</strong>，则将分组传送给路由表中所指明的默认路由器<br>；否则执行⑥<br>⑥ 报告转发分组出错</p>
<p><strong>注意</strong>：对于默认路由，其在路由表中的<strong>目的网络地址和子网掩码均为 0.0.0.0</strong>。</p>
<hr>
<p>【<strong>举例</strong>】下图有三个子网，两个路由器，以及R1中的部分路由表。考虑主机H1向H2发送数据包后的转发过程。</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-25_21-26-48.png"></p>
<p>【<strong>答</strong>】</p>
<ol>
<li>源主机H1判断目的地址是否在本地子网。<ul>
<li>源主机H1把本子网的“子网掩码 255.255.255.128” 与目的主机H2的 “IP地址 128.30.33.138” 做按位与运算，得出 128.30.33.128，它不等于H1的网络地址（128.30.33.0）。因此，H1不能把分组直接交付给H2，而必须交给子网上的默认路由器R1（也可能是进行了ARP查询），由R1来转发。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((目的地址 &amp; subnet mask) == (主机地址 &amp; subnet mask)) <span class="comment">// &amp;源主机网络地址</span></span><br><span class="line">    目的地址在本地子网，直接交付</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    数据包发往gateway，间接交付</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>路由器R1在收到一个分组后，在路由表中逐行寻找有无匹配的网络地址。<ul>
<li>第二行“子网掩码 255.255.255.128” 与收到分组的目的主机H2的 “IP地址 128.30.33.138” 做按位与运算，得出 128.30.33.128，与目的网络地址相匹配，R1将数据报发往该表项的网络出口。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((目的地址 &amp; subnet mask) == 目的网络地址)</span><br><span class="line">    数据包发往该表项的网络出口；    <span class="comment">// 或是下一跳路由，或是目的主机所在子网</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在子网内直接交付给目的主机H2。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查找ARP缓存，是否有目的IP地址对应的MAC地址</span><br><span class="line"><span class="keyword">if</span> (目的MAC地址在ARP缓存中) </span><br><span class="line">    将IP数据包封装成帧后，在局域网内向目的MAC地址直接发送帧</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    在子网内广播发送ARP请求，目的主机收到请求后返回ARP应答，由此 得知目的主机MAC地址</span><br></pre></td></tr></table></figure>


<h3 id="二、无分类编址-CIDR-（构造超网）"><a href="#二、无分类编址-CIDR-（构造超网）" class="headerlink" title="二、无分类编址 CIDR （构造超网）"></a>二、无分类编址 CIDR （构造超网）</h3><h4 id="1-网络前缀"><a href="#1-网络前缀" class="headerlink" title="1. 网络前缀"></a>1. 网络前缀</h4><p>无分类域间路由CIDR(Classless Inter-Domain Routing， CIDR的读音是 “sider”) ，CIDR的最主要的两个特点：</p>
<ol>
<li><strong>CIDR消除了传统的A类、B类和C类地址以及划分子网的概念</strong>，而是使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。<ul>
<li>IP地址从三级编址(使用子网掩码)又回到了两级编址<ul>
<li>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}</li>
</ul>
</li>
<li>CIDR还使用“<strong>斜线记法</strong>”(slash notation)，又称为<strong>CIDR记法</strong>，即在IP地址后加一个斜线“/”，后跟<strong>网络前缀所占的位数</strong>。<ul>
<li>例：128.14.35.7/20 表示该地址的高20位是网络前缀。</li>
</ul>
</li>
</ul>
</li>
<li>CIDR把<strong>网络前缀都相同</strong>的连续的IP地址组成一个“<strong>CIDR地址块</strong>”，只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的<strong>起始地址（即最小地址）和最大地址</strong>，以及地址块中的<strong>地址数</strong>。<ul>
<li>例如，128.14.32.0/20表示的CIDR地址块共有 $2^{12}$ 个地址.<ul>
<li>地址块的起始地址：128.14.32.0</li>
<li>地址块的最大地址：128.14.47.255</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_13-23-53.png"></p>
<ul>
<li><p><strong>路由聚合(route aggregation)</strong></p>
<ul>
<li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合称为路由聚合。</li>
<li>路由聚合的好处：路由表中的一个项目可以表示很多个(例如上千个)原来传统分类地址的路由，可以减少路由表中表项个数，并减少路由器间交换的路由信息量。</li>
<li>由于CIDR地址块大多包含多个C类地址，因此路由聚合也称为**构成超网(supernetting)**。</li>
</ul>
</li>
<li><p>注意不能把没有的路由聚合进去——“路由黑洞”</p>
</li>
<li><p><strong>关于地址掩码</strong></p>
<ul>
<li>为了更方便地进行路由选择，CIDR 使用 32位的<strong>地址掩码（address mask）</strong>。<ul>
<li>例：/20的地址掩码是：11111111 11111111 11110000 00000000</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意，<strong>“CIDR 不使用子网”是指CIDR并没有在32位地址中指明若干位作为子网字段</strong>。但分配到一个 CIDR 地址块的单位，仍然可以在<strong>本单位内</strong>根据需要划分出一些子网。<br>例如，某单位分配到地址块 /20，就可以再继续划分为8个子网（即从主机号中借用3位来划分子网）。这时每个子网的网络前缀则变成了<strong>23位</strong>。</p>
</blockquote>
<ul>
<li><strong>CIDR记法的其他形式</strong><ol>
<li>省略点分十进制中低位连续的0。如 10.0.0.0/10 可简写为 10/10。</li>
<li>网络前缀后跟星号 * 的表示方法。如 00001010 00<em>，**星号 \</em> 之前为网络前缀，星号 * 为任意主机号**。</li>
</ol>
</li>
</ul>
<hr>
<p>【<strong>CIDR地址块分配举例</strong>】</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_13-47-26.png"></p>
<h4 id="2-最长前缀匹配"><a href="#2-最长前缀匹配" class="headerlink" title="2. 最长前缀匹配"></a>2. 最长前缀匹配</h4><ul>
<li>使用CIDR时，路由表中的表项中的“目的网络地址”由固定长度变成了<strong>变长</strong>的“网络前缀”，因此查找路由表时可能会得到<strong>不止一个匹配结果</strong>。</li>
<li>最长前缀匹配(longest-prefix matching)<strong>原则</strong>：<ul>
<li><strong>从匹配结果中选择具有最长网络前缀的路由</strong>。</li>
<li>网络前缀越长，其地址块就越小，因而路由就越<strong>具体</strong>(more specific)。</li>
<li>最长前缀匹配又称为最长匹配或最佳匹配。</li>
</ul>
</li>
</ul>
<hr>
<p>【<strong>最长前缀匹配举例</strong>】</p>
<ul>
<li>假定大学下属的四系希望ISP把转发给四系的数据报直接发到四系而不经过大学的路由器，则在ISP的路由器的路由表中，至少要有以下两个项目，即 <strong>206.0.68.0/22（大学）</strong>和 <strong>206.0.71.128/25（四系）</strong>。</li>
<li>假定ISP收到的数据报的<strong>目的地址 D = 206.0.71.130</strong>，把D分别和路由表中这两个项目的<strong>地址掩码</strong>进行<strong>按位与</strong>操作，如下：</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_14-07-49.png"></p>
<p>根据最长前缀匹配的原理，应当选择后者，即选择两个匹配的地址中更具体的一个。</p>
<p>【<strong>考研题举例</strong>】</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_14-13-37.png"></p>
<ul>
<li><strong>解答</strong>：<ul>
<li>2010<ul>
<li>由子网掩码知，最后一个字节为 1111 1000，即只有3位可分配主机，最大可分配地址个数为 $2^3 -2 = 6$。</li>
<li>又由IP地址知，网络前缀有24位，故子网分配5位，即 $2^5 = 32$ 个子网。</li>
</ul>
</li>
<li>2011<ul>
<li>网络前缀占30位，因而只有2位分配给主机，则最大主机数为 $2^2 - 2 = 2$ 个。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-使用二叉线索查找路由表"><a href="#3-使用二叉线索查找路由表" class="headerlink" title="3. 使用二叉线索查找路由表"></a>3. 使用二叉线索查找路由表</h4><p>略</p>
<h2 id="4-4-网际控制报文协议-ICMP"><a href="#4-4-网际控制报文协议-ICMP" class="headerlink" title="4.4 网际控制报文协议 ICMP"></a>4.4 网际控制报文协议 ICMP</h2><h3 id="一、ICMP简介"><a href="#一、ICMP简介" class="headerlink" title="一、ICMP简介"></a>一、ICMP简介</h3><ul>
<li>RFC 792: <strong>I</strong>nternet <strong>C</strong>ontrol <strong>M</strong>essage <strong>P</strong>rotocol</li>
<li>ICMP允许主机或路由器报告<strong>差错情况</strong>和提供有关<strong>异常情况</strong>的报告。</li>
<li>ICMP是<strong>IP层的协议</strong>，ICMP报文封装在IP数据报的<strong>数据部分</strong>，报文格式如下图所示。</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_15-23-50.png"></p>
<h3 id="二、ICMP报文的种类"><a href="#二、ICMP报文的种类" class="headerlink" title="二、ICMP报文的种类"></a>二、ICMP报文的种类</h3><ul>
<li>ICMP报文的种类有两种，即<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong>。</li>
<li>ICMP报文的前4个字节是统一格式的，接着的4个字节与ICMP的类型有关，共有9中格式，见下表：</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_15-34-04.png"></p>
<p>【<strong>中文版</strong>】</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_15-27-52.png"></p>
<ul>
<li><strong>差错报告报文</strong><ol>
<li>Destination unreachable：<strong>终点不可达</strong>，路由器或主机<strong>无法传输报文时向源主机</strong>发送此报文。</li>
<li>Time exceeded：<strong>超时</strong>，路由器收到<strong>TTL字段为0</strong>的报文时，向<strong>源主机</strong>发送此报文。</li>
<li>Parameter problem：<strong>参数问题</strong>，路由器或主机收到的报文中，头<strong>部有非法字段</strong>时，<strong>丢弃数据包</strong>，并向源主机发送此报文。</li>
<li>Redirect：<strong>重定向</strong>，路由器向主机发送此报文告知<strong>路由改变</strong>， 主机下次发送数据报给另外的路由器。</li>
<li>Source quench：<strong>源点抑制</strong>，路由器或主机由于拥塞丢弃报文时，向源主机发送此报文，使其<strong>放慢发送速度</strong>。</li>
</ol>
</li>
<li><strong>询问报文</strong><ol>
<li>Echo request / reply：<strong>回声探测</strong>，用于<strong>测试网络连通性</strong>。</li>
<li>Timestamp request / reply：<strong>请求时间</strong>，可用于<strong>时间同步</strong>。</li>
</ol>
</li>
</ul>
<p>【对路由改变的简要解释】</p>
<blockquote>
<ol>
<li>我们知道，互联网中的主机也要有一个路由表。在互联网中，主机的数量远大于路由表的数量，因此出于效率的考虑，这些<strong>主机不和网络上的路由器定期交换路由信息</strong>。</li>
<li>在主机刚开始工作时，一般都在路由表中设置一个默认路由器的IP地址。不管数据报要发送到哪，都一律传送给这个默认路由，而这个默认路由器知道每一个目的网络的<strong>最佳路由</strong>（<strong>通过和其他路由器交换路由信息</strong>）。</li>
<li>如果默认路由器发现主机发往某个目的地址的数据包的最佳路由应当经过网络中的<strong>另一个路由器R</strong>时，就用<strong>改变路由报文</strong>把这个情况告诉主机。</li>
<li>于是，该主机就在其路由表中增加一个项目：<strong>到某某目的地址应经过路由器R</strong>。</li>
</ol>
</blockquote>
<h3 id="三、ICMP应用举例"><a href="#三、ICMP应用举例" class="headerlink" title="三、ICMP应用举例"></a>三、ICMP应用举例</h3><p>详见“第一章概述 - 附”。</p>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><ul>
<li>用来测试两个主机之间的连通性.</li>
<li>采用ICMP echo request / reply报文。<ul>
<li>向目的主机发送ICMP echo request报文，对方收到后会回应ICMP echo reply，根据能否收到应答后判断两台主机之间是否连通。</li>
</ul>
</li>
</ul>
<h4 id="Traceroute-Tracert"><a href="#Traceroute-Tracert" class="headerlink" title="Traceroute / Tracert"></a>Traceroute / Tracert</h4><ul>
<li>用来测试到另一台主机所经过的路由信息</li>
<li>采用ICMP超时报告报文<ul>
<li><strong>逐个</strong>发出UDP报文，其IP包头中的TTL字段<strong>分别</strong>设为1, 2, 3, …，<strong>直到到达目的主机</strong>。</li>
<li>报文路由路径上的路由器会<strong>返回ICMP超时报文</strong>，从该报文即可得知路由器IP地址。</li>
</ul>
</li>
</ul>
<h2 id="4-5-路由算法及路由选择协议"><a href="#4-5-路由算法及路由选择协议" class="headerlink" title="4.5 路由算法及路由选择协议"></a>4.5 路由算法及路由选择协议</h2><h3 id="一、有关路由选择协议的几个基本概念"><a href="#一、有关路由选择协议的几个基本概念" class="headerlink" title="一、有关路由选择协议的几个基本概念"></a>一、有关路由选择协议的几个基本概念</h3><h4 id="1-理想的路由算法"><a href="#1-理想的路由算法" class="headerlink" title="1. 理想的路由算法"></a>1. 理想的路由算法</h4><ul>
<li>在网络中，<strong>路由器依据路由信息(路由表)转发分组，路由信息是路由协议生成的，路由算法是路由协议的基础和核心</strong>。<ul>
<li>注意：路由协议是用来<strong>生成路由信息</strong>(路由表)的，不是转发分组的</li>
</ul>
</li>
<li>理想的路由算法应具备的<strong>特性</strong>：<ol>
<li>必须是<strong>正确的和完整的</strong>：按照得出的路由能够进行正确寻址</li>
<li>在<strong>计算上应简单</strong>：不增加过多开销</li>
<li>有<strong>自适应性</strong>：能根据通信量和网络拓扑的变化调整路由</li>
<li>应具有<strong>稳定性</strong>：通信量和拓扑稳定时，能快速收敛</li>
<li>应是<strong>公平的</strong>：对所有用户公平</li>
<li>应是<strong>最佳的</strong>：能找出最好的路由(时延最小、吞吐量最大)。<ul>
<li>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li>
</ul>
</li>
</ol>
</li>
<li>倘若从路由算法能否随网络的通信量或拓扑<strong>自适应</strong>地进行调整变化来划分，则只有两大类，即<strong>静态路由与动态路由</strong><ul>
<li>静态路由选择策略<ul>
<li>非自适应路由选择</li>
<li>简单和开销较小，但不能及时适应网络状态的变化</li>
<li>适用于<strong>小规模且变化较少</strong>的网络，由人工设置路由</li>
</ul>
</li>
<li>动态路由选择策略<ul>
<li>自适应路由选择</li>
<li>能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大</li>
<li>适用于<strong>较大规模、频繁变化</strong>的网络，通过专门的算法和协议进行路由的计算</li>
</ul>
</li>
</ul>
</li>
<li>两类典型的动态路由算法<ul>
<li><strong>距离向量(distance vector)路由算法</strong></li>
<li><strong>链路状态(link state)路由算法</strong></li>
</ul>
</li>
</ul>
<h4 id="2-分层次的路由选择协议"><a href="#2-分层次的路由选择协议" class="headerlink" title="2. 分层次的路由选择协议"></a>2. 分层次的路由选择协议</h4><ul>
<li>Internet采用分层次的路由，原因：<ul>
<li>Internet规模庞大，任何一台路由器都不可能获取和存储整个Internet的路由信息</li>
<li>接入Internet的众多网络(管理方)不希望外界了解自己网络的内部信息</li>
</ul>
</li>
<li><strong>自治系统(AS—Autonomous System)</strong><ul>
<li>定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 <strong>AS 内部的路由选择协议和共同的度量</strong>以确定分组在该 AS 内的路由，同时还使用一种 <strong>AS 之间的路由选择协议</strong>用以确定分组在 AS之间的路由</li>
<li>一个 AS可使用<strong>多种</strong>内部路由选择协议和度量，但对其他 AS 表现出的是<strong>单一的和一致</strong>的路由选择策略</li>
</ul>
</li>
<li>在自治系统背景下，Internet路由协议可以分为两类：<ul>
<li><strong>内部网关协议 IGP</strong>(Interior Gateway Protocol)<ul>
<li>自治系统内部使用的路由选择协议</li>
<li>这类路由协议使用得最多，如 <strong>RIP</strong> 和 <strong>OSPF</strong> 协议</li>
</ul>
</li>
<li><strong>外部网关协议EGP</strong>(External Gateway Protocol)<ul>
<li>若源站和目的站处在不同的自治系统中，<strong>当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中</strong>，这样的协议就是外部网关协议 EGP。 </li>
<li>应用最为广泛的外部网关协议：BGP-4</li>
</ul>
</li>
</ul>
</li>
<li>自治系统之间的路由选择又称为<strong>域间路由选择</strong>(interdomain routing)，自治系统内部的路由选择又称为<strong>域内路由选择</strong>(intradomain routing)。</li>
</ul>
<hr>
<p>【<strong>自治系统互连示意图</strong>】</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_16-11-29.png"></p>
<h3 id="二、内部网关协议-RIP"><a href="#二、内部网关协议-RIP" class="headerlink" title="二、内部网关协议 RIP"></a>二、内部网关协议 RIP</h3><h4 id="1-RIP-协议的工作原理"><a href="#1-RIP-协议的工作原理" class="headerlink" title="1. RIP 协议的工作原理"></a>1. RIP 协议的工作原理</h4><ul>
<li>RIP(Routing Information Protocol) <ul>
<li>一种分布式的<strong>基于距离向量的路由选择协议</strong></li>
<li>RIP 要求网络中的每一个路由器都要维护<strong>从它自己到其他每一个目的网络的距离</strong>（也称为<strong>跳数</strong>）。<ul>
<li>从一路由器到直接连接的网络的距离定义为<strong>1</strong>；</li>
<li>从一路由器到非直接连接的网络的距离定义为<strong>所经过的路由器数加1</strong>。</li>
</ul>
</li>
<li>RIP允许一条路径最多只能包含15个路由器，因此<strong>距离为16时表示不可达</strong>，可见 RIP 只适用于<strong>小型互联网</strong>。</li>
</ul>
</li>
<li>对于本节讨论的 RIP 协议和下一节要讨论的 OSPF 协议，都是分布式路由选择协议。它们的共同特点就是<strong>每一个路由器都要不断地和其他一些路由器交换路由信息</strong>。因此，以下三个要点非常重要：<ol>
<li><strong>和哪些路由器交换信息？</strong></li>
<li><strong>交换什么信息？</strong></li>
<li><strong>在什么时候交换信息？</strong></li>
</ol>
</li>
<li>RIP 协议的<strong>主要特征</strong>：<ol>
<li><strong>仅和相邻路由器交换信息</strong>。</li>
<li>交换的信息是当前本路由器所知道的<strong>全部信息</strong>，即自己的路由表。</li>
<li>按<strong>固定的时间间隔</strong>交换路由信息(典型值：每隔 30 秒)。</li>
</ol>
</li>
</ul>
<blockquote>
<p>路由表中最重要的信息是：<strong>到某个网络的距离（即最短距离），以及应经过的下一跳地址</strong>。<br>路由表更新的原则就是找出每个目的网络的<strong>最短距离</strong>，这种更新算法又称为<strong>距离向量算法</strong>。</p>
</blockquote>
<h4 id="2-距离向量算法"><a href="#2-距离向量算法" class="headerlink" title="2. 距离向量算法"></a>2. 距离向量算法</h4><ul>
<li>对每一个<strong>相邻路由器</strong>发送过来的 RIP 报文，进行以下<strong>步骤</strong>：<ol>
<li>对于地址为X的相邻路由器发来的报文，先修改此 RIP 报文中的<strong>所有项目</strong>：把 <strong>“下一跳”字段</strong> 中的地址都改为 <strong>X</strong>，并把<strong>所有的“距离”字段</strong>的值<strong>加 1</strong>。每个项目有三个关键数据：<strong>目的网络N、距离d、下一跳路由器X</strong>。</li>
<li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：</li>
</ol>
<ul>
<li>若路由表中没有目的网络N，则把该项目加到路由表中。</li>
<li>否则<ul>
<li>若下一跳字段给出的路由器地址是X，则用收到的项目替换原有项目。</li>
<li>否则<ul>
<li>若收到项目中的距离d小于路由表中的距离，则进行更新，</li>
<li>否则，什么也不做。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为<strong>不<br>可达路由器</strong>，即将<strong>距离置为16</strong>（距离为16表示不可达）。</li>
<li><strong>返回</strong>。</li>
</ol>
</li>
</ul>
<ul>
<li><p>上面给出的距离向量算法的基础就是 【Bellman-Ford 算法】，其<strong>核心思想</strong>为：</p>
<ul>
<li>设 X 是结点 A 到 B 的最短路径上的一个结点。若把路径 A → B 拆成两端路径 A → X 和 X → B，则每一端路径 A → X 和 X → B 也都分别是结点 A 到 X 和结点 X 到 B 的最短路径。</li>
</ul>
</li>
<li><p>距离向量路由的<strong>无穷计算问题</strong></p>
<ul>
<li>算法的缺陷：<strong>对好消息反应迅速，对坏消息反应迟钝</strong>。</li>
<li>见下例</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-26_16-49-53.png"></p>
<h4 id="3-RIP-协议的报文格式"><a href="#3-RIP-协议的报文格式" class="headerlink" title="3. RIP 协议的报文格式"></a>3. RIP 协议的报文格式</h4><p>RIP协议使用运输层的用户数据报 UDP 进行传送，其报文格式如下：</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_13-01-40.png"></p>
<ul>
<li>RIP报文由首部和路由部分组成</li>
<li>RIP的首部占4个字节，其中的命令字段指出报文的意义。<br>例如，1表示请求路由信息，2表示对请求路由信息的相应或未被请求而发出的路由更新报文。首部后面的“必为0”是为了4字节的对齐。</li>
</ul>
<h3 id="三、内部网关协议-OSPF"><a href="#三、内部网关协议-OSPF" class="headerlink" title="三、内部网关协议 OSPF"></a>三、内部网关协议 OSPF</h3><h4 id="1-OSPF-协议的工作原理"><a href="#1-OSPF-协议的工作原理" class="headerlink" title="1. OSPF 协议的工作原理"></a>1. OSPF 协议的工作原理</h4><ul>
<li><p>OSPF（Open Shortest Path First）协议简介</p>
<ul>
<li>一种分布式的<strong>链路状态协议</strong>(link-state protocol)</li>
<li><strong>优点</strong>：<ul>
<li><strong>收敛速度快</strong><ul>
<li>当链路状态发生变化时，结点会以洪泛(flooding)方式告知所有网络中其他所有结点</li>
</ul>
</li>
<li><strong>适用于较大规模的网络</strong><ul>
<li>仅在链路状态发生变化时发送洪泛信息，不会产生很大通信量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>OSPF 协议的<strong>主要特征</strong>：</p>
<ol>
<li>以<strong>洪泛(flooding)**方式向本自治系统中</strong>所有路由器**发送信息。<ul>
<li><strong>洪泛(flooding)</strong>: 结点收到分组时，向<strong>除输入链路外</strong>的所有其他链路发送出去</li>
</ul>
</li>
<li>发送的信息就是<strong>与本路由器相邻的所有路由器的链路状态</strong>，但这只是路由器所知道的<strong>部分信息</strong>。<ul>
<li>“<strong>链路状态</strong>”就是说明本路由器都和哪些路由器相邻，以及该链路的<strong>度量</strong>（metrix）。OSPF将这个度量用来表示<strong>费用、距离、时延、带宽</strong>等等，也称为<strong>代价</strong>。</li>
<li>注意，对于RIP协议，发送的信息是：<strong>到所有网络的距离和下一跳路由器</strong>。</li>
</ul>
</li>
<li>只有<strong>当链路状态发生变化时</strong>，路由器才向所有路由器用洪泛法发送此信息。<ul>
<li>而不像RIP那样，定期交换路由表的信息。</li>
</ul>
</li>
</ol>
</li>
<li><p>由于各路由器之间频繁地交换链路状态信息，每个路由器都建立一个链路状态数库。</p>
<ul>
<li>这个数据库实际上就是<strong>全网的拓扑结构图</strong>，它在全网范围内是<strong>一致</strong>的(即<strong>链路状态数据库的同步</strong>)。</li>
</ul>
</li>
<li><p>因此，各路由器根据<strong>网络拓扑</strong>使用<strong>Dijkstra</strong>算法计算从本路由器到其他结点的最佳路径，构成路由表</p>
</li>
</ul>
<h4 id="2-OSPF-的区域划分"><a href="#2-OSPF-的区域划分" class="headerlink" title="2. OSPF 的区域划分"></a>2. OSPF 的区域划分</h4><ul>
<li><p>为了管理大规模的网络，OSPF 将一个自治系统再划分为若干个区域(area)，每一个区域都有一个 32 位的区域标识符(用点分十进制表示)。在一个区域内的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑。</p>
</li>
<li><p>层次结构的<strong>区域划分</strong>：</p>
<ul>
<li>上层的区域称为<strong>主干区域</strong>(backbone area)，主干区域的作用是用来<strong>连通其他在下层的区域</strong>，主干区域的标识符规定为<strong>0.0.0.0</strong>。</li>
<li>从其他区域来的信息都由<strong>区域边界路由器</strong>（area border router）进行概括，例如下图的R3，R4和R7。</li>
<li>在主干区域内的路由器叫做<strong>主干路由器</strong>（backbone router），例如下图中的R3，R4，R5，R6和R7。</li>
<li>在主干区域内还有一个路由器<strong>专门和本自治系统外</strong>的其他自治系统交换路由信息，叫做<strong>自治系统边界路由器</strong>。例如下图中的R6。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_13-40-52.png"></p>
<ul>
<li>划分区域的<strong>好处</strong>：<ul>
<li>利用洪泛法交换链路状态信息的范围局限于一个区域而不是整个的自治系统，<strong>大大减少了整个网络上的通信量</strong>，因而使 OSPF 协议能够用于<strong>规模很大的自治系统</strong>中。</li>
</ul>
</li>
</ul>
<h4 id="3-OSPF-的分组结构"><a href="#3-OSPF-的分组结构" class="headerlink" title="3. OSPF 的分组结构"></a>3. OSPF 的分组结构</h4><p>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong>（其 IP 数据报首部的协议字段值为 89）。</p>
<blockquote>
<p>OSPF 构成的数据报很短，这样不仅可以减少路由信息的通信量，另一个好处是<strong>不必将长的数据报分片传送</strong>。分配传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p>
</blockquote>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_13-45-52.png"></p>
<ul>
<li>OSPF 首部各字段的意义<ol>
<li><strong>版本</strong>：当前的版本号是2。</li>
<li><strong>类型</strong>：可以使五种类型分组中的一种。</li>
<li><strong>分组长度</strong>：包括OSPF首部在内的分组长度，以字节为单位。</li>
<li><strong>路由器标识符</strong>：标志发送该分组的路由器的接口的IP地址。</li>
<li><strong>区域标识符</strong>：分组属于的区域的标识符</li>
<li><strong>检验和</strong>：用来检测分组中的差错。</li>
<li><strong>鉴别类型</strong>：目前只有两种，0（不用）和1（口令）。</li>
<li><strong>鉴别</strong>：鉴别类型为0时就填入0，鉴别类型为1则填入8个字符的口令。</li>
</ol>
</li>
</ul>
<h4 id="4-OSPF-的五种分组类型"><a href="#4-OSPF-的五种分组类型" class="headerlink" title="4. OSPF 的五种分组类型"></a>4. OSPF 的五种分组类型</h4><ul>
<li>OSPF 共有以下五种分组类型<ol>
<li><strong>类型1：问候</strong>（Hello）分组，用来发现和维持邻站的可达性。</li>
<li><strong>类型2：数据库描述</strong>（Database Description）分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li>
<li><strong>类型3：链路状态请求</strong>（Link State Request）分组，向对方请求发送某些链路状态项目的详细信息。</li>
<li><strong>类型4：链路状态更新</strong>（Link State Update）分组，用洪泛法对全网更新链路状态。<ul>
<li>这种分组时最复杂，也是 OSPF 最核心的部分。</li>
</ul>
</li>
<li><strong>类型5：链路状态确认</strong>（Link State Acknowledgment）分组，对链路更新分组的确认。</li>
</ol>
</li>
</ul>
<ul>
<li>如果所有的路由器都把自己本地的链路状态信息读全网进行广播，这种开销太大，因此，OSPF 采用下面的方法来更新链路状态数据库：<ol>
<li>OSPF 规定，每两个相邻路由器每隔 10s 就交换一次问候分组，以此来确定哪些邻站是可达的。</li>
<li>OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库汇总已有的链路状态摘要信息。<ul>
<li>摘要信息主要就是指出有哪些路由器的链路状态信息已经写入了数据库。</li>
</ul>
</li>
<li>之后，路由器使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。</li>
<li>通过一系列这种分组交换，全网同步的链路数据库就建立了。</li>
</ol>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_13-58-20.png"></p>
<h3 id="四、外部网关协议-BGP"><a href="#四、外部网关协议-BGP" class="headerlink" title="四、外部网关协议 BGP"></a>四、外部网关协议 BGP</h3><blockquote>
<p>首先我们应当弄清，在不同自治系统 AS 之间的路由选择为什么不能使用前面讨论过的内部网关协议，如 RIP 或 OSPF？有以下两个原因：</p>
<ol>
<li>第一，<strong>互联网的规模太大，使得自治系统AS之间路由选择非常困难</strong>。</li>
<li>第二，<strong>自治系统AS之间的路由选择必须考虑有关策略</strong>。</li>
</ol>
<p>具体参考教材 P164。</p>
</blockquote>
<h4 id="1-BGP-协议基本原理"><a href="#1-BGP-协议基本原理" class="headerlink" title="1. BGP 协议基本原理"></a>1. BGP 协议基本原理</h4><ul>
<li><p>BGP(Border Gateway Protocol)简介</p>
<ul>
<li>BGP是<strong>不同自治系统</strong>的路由器之间交换路由信息的协议</li>
<li>BGP采用了<strong>路径向量</strong>（path vector）路由选择协议，它与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大的区别。</li>
</ul>
</li>
<li><p>BGP使用环境的<strong>特殊性</strong></p>
<ul>
<li>Internet的<strong>规模很大</strong>，AS之间的路由选择非常困难<ul>
<li>Internet主干网路由器中的网络前缀达到数万条</li>
<li>对于AS之间的路由选择，要寻找最佳路由是不现实的</li>
<li>不同AS对路径度量标准各不相同</li>
</ul>
</li>
<li>AS之间的路由选择<strong>需考虑多种策略</strong><ul>
<li>例1：AS1到AS2的数据报经过AS3在技术上最佳，但AS3可能不同意</li>
<li>例2：出于国家安全的考虑，可能不希望数据报流经某些国家</li>
</ul>
</li>
<li>由于上述情况，BGP<strong>难以找到最佳路由</strong>，只能寻找一条能够到达目的网络且<strong>比较好</strong>的路由(不能兜圈子)，而<strong>并非要寻找一条最佳路由</strong>。</li>
</ul>
</li>
<li><p><strong>BGP发言人</strong>(speaker)</p>
<ul>
<li>每个AS要选择<strong>至少一个</strong>路由器作为“BGP speaker” </li>
<li>两个BGP发言人通过一个共享网络连接在一起</li>
<li>BGP发言人一般是AS的<strong>边界路由器</strong>，但也可以不是</li>
<li>BGP 发言人与其他自治系统中的BGP发言人交换路由信息</li>
<li>路由信息的交换通过<strong>TCP协议</strong>进行，两个发言人**在TCP连接上交换BGP报文以建立BGP会话(session)**，利用 BGP 会话交换路由信息</li>
<li>BGP发言人除了运行BGP协议外，还要运行<strong>AS的内部网关路由协议</strong></li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_14-27-01.png"></p>
<ul>
<li>信息交换与路由生成<ul>
<li>BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS，称为<strong>路径向量</strong>(path vector)</li>
<li>BGP 发言人互相交换了网络可达性的信息后，就根据所采用的策略从其中找出到达各 AS 的较好路由。</li>
</ul>
</li>
</ul>
<p>【<strong>示例</strong>】</p>
<ul>
<li>AS2的BGP发言人通知主干网的BGP发言人：要到达网络 N1, N2, N3 和 N4 可经过 AS2</li>
<li>主干网还可发出通知：“要到达网络 N5, N6 和 N7 可沿路径(AS1, AS3)</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_14-30-05.png"></p>
<h4 id="2-BGP-4-使用的四种报文"><a href="#2-BGP-4-使用的四种报文" class="headerlink" title="2. BGP-4 使用的四种报文"></a>2. BGP-4 使用的四种报文</h4><ul>
<li><p>在 RFC 4271 中规定了 BGP-4 的四种报文：</p>
<ol>
<li><strong>OPEN报文</strong>：用来与相邻的另一个BGP发言人建立关系</li>
<li><strong>UPDATE报文</strong>：用来发送某一路由的信息，以及列出要撤消的多条路由</li>
<li><strong>KEEPALIVE报文</strong>：用来确认打开报文和周期性地证实邻站关系</li>
<li><strong>NOTIFICATION报文</strong>：用来发送检测到的差错</li>
</ol>
</li>
<li><p><strong>信息交换与路由生成</strong></p>
<ol>
<li>BGP发言人通过OPEN报文与另一发言人建立会话，对方如同意则回应KEEPALIVE报文。</li>
<li>双方周期性交换KEEPALIVE报文，以确认会话未中断。</li>
<li>路由信息变化时，发送UPDATE报文。</li>
</ol>
</li>
</ul>
<h4 id="3-BGP-报文的格式"><a href="#3-BGP-报文的格式" class="headerlink" title="3. BGP 报文的格式"></a>3. BGP 报文的格式</h4><p>下图给出了 BGP 报文的格式。</p>
<ul>
<li><p>四种类型的 BGP 报文具有<strong>同样的通用首部</strong>，其长度为19字节。通用首部分为三个字段。</p>
<ol>
<li><strong>标记</strong>字段，占16字节，用来鉴别收到的BGP报文。</li>
<li><strong>长度</strong>字段，占2字节，指出包括首部在内的整个BGP报文的长度（以字节为单位），范围在 19~4096之间。</li>
<li><strong>类型</strong>字段，占1字节，值为1到4，分别对应四种BGP报文类型。</li>
</ol>
</li>
<li><p><strong>OPEN 报文</strong>共有6个字段，即版本、本自治系统号、保持时间、BGP标识符、可选参数长度和可选参数。</p>
</li>
<li><p><strong>UPDATE报文</strong>共有5个字段，即不可行路由长度、撤销的路由、路径属性总长度、路径属性和网络层可达性信息。</p>
</li>
<li><p><strong>KEEPALIVE报文</strong>只有BGP的19字节唱的通用首部。</p>
</li>
<li><p><strong>NOTIFICATION报文</strong>由3个字段。即差错代码（1字节）、差错子代码（1字节）和差错数据（给出<strong>有关差错的诊断信息</strong>）。</p>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_14-38-36.png"></p>
<h3 id="五、路由器的构成"><a href="#五、路由器的构成" class="headerlink" title="五、路由器的构成"></a>五、路由器的构成</h3><h4 id="1-路由器的结构"><a href="#1-路由器的结构" class="headerlink" title="1. 路由器的结构"></a>1. 路由器的结构</h4><ul>
<li><p>路由器是一种具有多个输入/输出端口的专用计算机，其任务是<strong>转发分组</strong>。</p>
</li>
<li><p><strong>路由器组成</strong>：</p>
<ol>
<li><p><strong>路由选择部分</strong>，也叫<strong>控制部分</strong>，其核心构件是<strong>路由选择处理机</strong>。</p>
<p>路由选择处理机的任务是根据所选定的路由选择协议<strong>构造并维护路由表</strong>。</p>
</li>
<li><p><strong>分组转发部分</strong>，由三部分构成：<strong>交换结构</strong>（switching fabric）、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>。</p>
<p>交换结构根据<strong>转发表</strong>（forwarding table）进行分组的快速转发，转发表从路由表得到。</p>
</li>
</ol>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_14-52-16.png"></p>
<ul>
<li><p>路由器设计的关键之一是<strong>分组的高速转发</strong></p>
<ul>
<li>决定报文转发速率的<strong>因素</strong>有：<ul>
<li>输入/输出端口的处理性能</li>
<li>交换机构的性能</li>
<li>线速(line speed 或 wire speed): <strong>分组的处理速率能够达到线路上分组的传输速率</strong></li>
</ul>
</li>
<li>衡量路由器性能的指标：<strong>pps</strong>(packet per second)<ul>
<li>如oc-48链路(2.5Gb/s)，如分组长度256字节，则线速转发意味着每秒处理分组数&gt;100万</li>
</ul>
</li>
</ul>
</li>
<li><p>输入和输出端口的处理</p>
<ul>
<li>当一个分组正在查找转发表时，后面又仅跟着从这个输入端口收到另一个分组，那么这个后到的分组必须在队列中<strong>排队等待</strong>，因而产生了一定的<strong>时延</strong>。</li>
<li><strong>输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上</strong>。在网络层的处理模块设有一个缓冲区，当交换结构传输过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂存在队列中。<ul>
<li><strong>注意</strong>：当排队的<strong>分组数量过多</strong>时，可能导致路由器内部<strong>缓冲区溢出丢包</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_15-02-50.png"></p>
<h4 id="2-交换结构"><a href="#2-交换结构" class="headerlink" title="2. 交换结构"></a>2. 交换结构</h4><p>交换结构是路由器的关键构件，下面给出了三种常用的交换方法。</p>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-03-31_15-05-53.png"></p>
<p>具体特点见教材P170。</p>
<h2 id="4-6-IP-多播"><a href="#4-6-IP-多播" class="headerlink" title="4.6 IP 多播"></a>4.6 IP 多播</h2><h3 id="一、IP-多播的基本概念"><a href="#一、IP-多播的基本概念" class="headerlink" title="一、IP 多播的基本概念"></a>一、IP 多播的基本概念</h3><ul>
<li>组播(multicast)又称为<strong>多播</strong>，用于<strong>实现一点对多点的数据传输</strong>。<ul>
<li>有许多应用需要由一个源点发送到许多个终点。例如，<strong>实时信息的交付</strong>（新闻、股市行情），软件更新，<strong>交互式会议</strong>等。</li>
</ul>
</li>
<li>与单播相比，在一对多通信中，组播可大大节约网络资源。<ul>
<li>例如，视频服务器用单播方式向90台主机发送同样的视频节目，则需要<strong>90个副本</strong>（图a）。</li>
<li>如果视频服务器把视频分组当作<strong>多播数据报</strong>来发送，则只需要发送一次。R1在转发分组时，<strong>复制3个副本</strong>分别转发给R2、R3和R4。</li>
<li>当分组到达目的局域网时，由于局域网具有<strong>硬件多播</strong>的功能，因此<strong>不需要复制分组</strong>，在局域网上的多播组成员都能收到这个视频分组。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-04-02_08-53-36.png"></p>
<ul>
<li><p>在互联网上进行多播就叫做 <strong>IP 多播</strong>，IP 多播所传送的分组需要使用<strong>多播 IP 地址</strong>。</p>
<ul>
<li><strong>问题</strong>：显然，这个多播数据报的目的地址不能写入IP地址，因为同一时间可能有成千上万台主机需要接受这个多播数据报。</li>
<li><strong>解决方案</strong>：多播数据报的目的地址写入的是<strong>多播组的标识符</strong>，然后设法让加入这个多播组的主机的IP地址与多播组的标识符<strong>关联</strong>起来。</li>
</ul>
</li>
<li><p><strong>多播数据报</strong></p>
<ul>
<li>使用<strong>D类IP地址</strong>作为多播组的标识符。D类IP地址的前四位是 1110，因此地址范围为 224.0.0.0—239.255.255.255。</li>
<li>首部中的协议字段值为2，表明使用网际组管理协议（<strong>IGMP</strong>）。</li>
<li><strong>多播地址只能用于目的地址，而不能用于源地址</strong>。</li>
</ul>
</li>
<li><p>IP多播可以分为两种</p>
<ol>
<li><strong>在局域网中的硬件多播</strong>。</li>
</ol>
<ul>
<li>将MAC地址中的特定地址段作为组播地址，并与IP组播地址形成对应关系。</li>
</ul>
<ol start="2">
<li><strong>在Internet中的多播</strong>。</li>
</ol>
<ul>
<li>路由器需支持多播，即<strong>多播路由器</strong></li>
<li>主机通过<strong>IGMP协议</strong>与多播路由器通信，加入/退出某个多播组</li>
<li>多播路由器之间通过多播路由协议实现多播数据报的传输</li>
</ul>
</li>
</ul>
<h2 id="4-7-网络地址转换-NAT-和虚拟专用网-VPN"><a href="#4-7-网络地址转换-NAT-和虚拟专用网-VPN" class="headerlink" title="4.7 网络地址转换 NAT 和虚拟专用网 VPN"></a>4.7 网络地址转换 NAT 和虚拟专用网 VPN</h2><h3 id="一、网络地址转换-NAT"><a href="#一、网络地址转换-NAT" class="headerlink" title="一、网络地址转换 NAT"></a>一、网络地址转换 NAT</h3><ul>
<li><p><strong>专用地址(保留地址)</strong></p>
<ul>
<li>RFC1918中定义了一系列专用地址(private address)<ol>
<li>10.0.0.0 ～ 10.255.255.255 (CIDR记法: 10/8)</li>
<li>172.16.0.0 ～ 172.31.255.255 (CIDR记法: 172.16/12)</li>
<li>192.168.0.0 ～ 192.168.255.255 (CIDR记法: 192.168/16)</li>
</ol>
</li>
<li>上面这些地址分别相当于1个A类网络、16个连续的B类网络和256个连续的C类网络，采用这些地址的网络称为<strong>专用互联网</strong>或<strong>本地互联网</strong>。</li>
<li>Internet中的路由器<strong>不转发目的地址为专用地址</strong>的包</li>
</ul>
</li>
<li><p>当内部网络使用专用地址时，与Internet的通信需要通过NAT(Network Address Translation)</p>
<ul>
<li>NAT路由器至少要有一个全球IP地址，才能和互联网互连。</li>
<li>NAT路由器内部<strong>使用TCP/UDP端口号实现外网数据包向内网地址的转换</strong>（详见下一章 - 传输层）。</li>
</ul>
</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-04-02_09-56-15.png"></p>
<h3 id="二、虚拟专用网-VPN"><a href="#二、虚拟专用网-VPN" class="headerlink" title="二、虚拟专用网 VPN"></a>二、虚拟专用网 VPN</h3><ul>
<li><p>多个企业/机构的内部网络之间互连的实现方法</p>
<ol>
<li>租用专用线路，形成专用网。这种方法成本高昂，难于承受。</li>
<li>基于公用网络(如Internet)，形成VPN（Virtual Private Network）。</li>
</ol>
</li>
<li><p>VPN涉及的技术包括：<strong>隧道(tunnel)、加密、身份认证</strong>等。</p>
</li>
<li><p>基于Internet建立VPN的两种情形 </p>
<ol>
<li><strong>内部网络通过Internet互连</strong> <ul>
<li>可以采用IPSec的ESP<strong>隧道模式</strong> </li>
</ul>
</li>
<li><strong>远程用户访问内部网</strong>(remote access VPN) <ul>
<li>拨号虚拟专用网(VPDN—Virtual Private Dialup Network) </li>
<li><strong>基于SSL的VPN技术</strong>，优点：客户端无须安装或配置软件</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>【<strong>例</strong>】如何使用IP隧道技术实现虚拟专用网</p>
<ul>
<li>假定两个机构在两个相隔较远的场所建立了专用网A和B，其网络地址分别为专用地址 10.1.0.0 和 10.2.0.0 。</li>
<li>通过公共网络传输的数据内容均经过<strong>加密</strong>，外部仅能通过IP 分组头得知R1在R2在通信</li>
</ul>
<p><img src="http://jayyy1.gitee.io/images/posts/BUAA/Snipaste_2020-04-02_10-07-33.png"></p>
<ul>
<li>如上图所示，由部门A和B的内部网络所构成的虚拟专用VPN又称为又称为Intranet(内联网)，表示A和B都属于同一个机构。</li>
<li>有时一个机构的VPN需要有某些外部机构参加进来，这样的VPN称为Extranet(外联网)。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jay1zhang.github.io/2020/12/31/BUAA/Computer%20Network/%E3%80%8C%E8%AE%A1%E7%BD%91%E3%80%8D04-%E7%BD%91%E7%BB%9C%E5%B1%82/">http://jay1zhang.github.io/2020/12/31/BUAA/Computer%20Network/%E3%80%8C%E8%AE%A1%E7%BD%91%E3%80%8D04-%E7%BD%91%E7%BB%9C%E5%B1%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/961/">961</a></div><div class="post_share"><div class="social-share" data-image="http://jayyy1.gitee.io/images/pictures/cartoons/002.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/31/Coding/LeetCode/%E3%80%8C%E7%AE%97%E6%B3%95%E3%80%8D04-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><img class="prev-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/013.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">「算法」04-二分查找</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/31/Coding/LeetCode/%E3%80%8C%E7%AE%97%E6%B3%95%E3%80%8D03-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/"><img class="next-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/017.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">「算法」03-贪心思想</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/12/31/BUAA/Computer System/「系统」03-设备管理/" title="「系统」03-设备管理"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/003.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「系统」03-设备管理</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer Network/「计网」07-IPv6协议/" title="「计网」07-IPv6协议"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「计网」07-IPv6协议</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer System/「系统」00-概述/" title="「系统」00-概述"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/037.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「系统」00-概述</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer System/「系统」04-磁盘管理/" title="「系统」04-磁盘管理"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「系统」04-磁盘管理</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer Network/「计网」01-概述/" title="「计网」01-概述"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/033.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「计网」01-概述</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer Network/「计网」02-物理层/" title="「计网」02-物理层"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/028.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「计网」02-物理层</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter4-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">Chapter4 - 网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1"><span class="toc-text">4.1 网络层提供的两种服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.2 网际协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81IP%EF%BC%88Internet-Protocol%EF%BC%89%E7%AE%80%E4%BB%8B"><span class="toc-text">一、IP（Internet Protocol）简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-Linux%E4%B8%AD%E6%8E%A5%E6%94%B6-%E5%8F%91%E9%80%81%E5%8C%85%E7%9A%84%E8%B0%83%E7%94%A8%E5%9B%BE"><span class="toc-text">实例 - Linux中接收&#x2F;发送包的调用图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%99%9A%E6%8B%9F%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C"><span class="toc-text">二、虚拟互联网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="toc-text">三、分类的IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IP%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-text">1. IP地址及其表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%88%AB%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="toc-text">2. 常用的三种类别的IP地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80"><span class="toc-text">四、IP地址与硬件地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP"><span class="toc-text">五、地址解析协议ARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">六、IP数据报格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E7%9A%84%E5%9B%BA%E5%AE%9A%E9%83%A8%E5%88%86%E4%B8%AD%E7%9A%84%E5%90%84%E5%AD%97%E6%AE%B5"><span class="toc-text">1. IP数据报首部的固定部分中的各字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E7%9A%84%E5%8F%AF%E5%8F%98%E9%83%A8%E5%88%86"><span class="toc-text">2. IP数据报首部的可变部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81IP%E5%B1%82%E8%BD%AC%E5%8F%91%E5%88%86%E7%BB%84%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">七、IP层转发分组的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91"><span class="toc-text">4.3 划分子网和构造超网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91"><span class="toc-text">一、划分子网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8E%E4%B8%A4%E7%BA%A7IP%E5%9C%B0%E5%9D%80%E5%88%B0%E4%B8%89%E7%BA%A7IP%E5%9C%B0%E5%9D%80"><span class="toc-text">1. 从两级IP地址到三级IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-text">2. 子网掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="toc-text">2. 使用子网掩码的分组转发过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80-CIDR-%EF%BC%88%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91%EF%BC%89"><span class="toc-text">二、无分类编址 CIDR （构造超网）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BC%80"><span class="toc-text">1. 网络前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D"><span class="toc-text">2. 最长前缀匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%9F%A5%E6%89%BE%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="toc-text">3. 使用二叉线索查找路由表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-ICMP"><span class="toc-text">4.4 网际控制报文协议 ICMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ICMP%E7%AE%80%E4%BB%8B"><span class="toc-text">一、ICMP简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ICMP%E6%8A%A5%E6%96%87%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">二、ICMP报文的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81ICMP%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">三、ICMP应用举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PING"><span class="toc-text">PING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Traceroute-Tracert"><span class="toc-text">Traceroute &#x2F; Tracert</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E5%8F%8A%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.5 路由算法及路由选择协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9C%89%E5%85%B3%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">一、有关路由选择协议的几个基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%90%86%E6%83%B3%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-text">1. 理想的路由算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E5%B1%82%E6%AC%A1%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-text">2. 分层次的路由选择协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-RIP"><span class="toc-text">二、内部网关协议 RIP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-RIP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1. RIP 协议的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="toc-text">2. 距离向量算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RIP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">3. RIP 协议的报文格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-OSPF"><span class="toc-text">三、内部网关协议 OSPF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-OSPF-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1. OSPF 协议的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-OSPF-%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-text">2. OSPF 的区域划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-OSPF-%E7%9A%84%E5%88%86%E7%BB%84%E7%BB%93%E6%9E%84"><span class="toc-text">3. OSPF 的分组结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-OSPF-%E7%9A%84%E4%BA%94%E7%A7%8D%E5%88%86%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. OSPF 的五种分组类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-BGP"><span class="toc-text">四、外部网关协议 BGP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-BGP-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">1. BGP 协议基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BGP-4-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8A%A5%E6%96%87"><span class="toc-text">2. BGP-4 使用的四种报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-BGP-%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">3. BGP 报文的格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-text">五、路由器的构成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">1. 路由器的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-text">2. 交换结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-IP-%E5%A4%9A%E6%92%AD"><span class="toc-text">4.6 IP 多播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81IP-%E5%A4%9A%E6%92%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">一、IP 多播的基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-NAT-%E5%92%8C%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-VPN"><span class="toc-text">4.7 网络地址转换 NAT 和虚拟专用网 VPN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-NAT"><span class="toc-text">一、网络地址转换 NAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-VPN"><span class="toc-text">二、虚拟专用网 VPN</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/012.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>
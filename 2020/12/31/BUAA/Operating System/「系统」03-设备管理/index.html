<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「系统」03-设备管理 | J1z's Blog</title><meta name="keywords" content="961"><meta name="author" content="Jay"><meta name="copyright" content="Jay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Chapter3 - 设备管理（I&#x2F;O管理）[TOC] 0x00 I&#x2F;O管理概述略 0x01 I&#x2F;O硬件组成1. I&#x2F;O系统抽象结构处理机操纵设备控制器，提供命令和数据给控制器，由控制器操纵I&#x2F;O设备，使设备完成I&#x2F;O传输。     2. 设备控制器 控制器的功能  接收和识别CPU命令 数据交换：CPU与控制器、控制器与设备 对设备传来的数据进行差错检测 设备状态的了解和报告 设备地址识别 缓冲">
<meta property="og:type" content="article">
<meta property="og:title" content="「系统」03-设备管理">
<meta property="og:url" content="http://jay1zhang.github.io/2020/12/31/BUAA/Operating%20System/%E3%80%8C%E7%B3%BB%E7%BB%9F%E3%80%8D03-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="J1z&#39;s Blog">
<meta property="og:description" content="Chapter3 - 设备管理（I&#x2F;O管理）[TOC] 0x00 I&#x2F;O管理概述略 0x01 I&#x2F;O硬件组成1. I&#x2F;O系统抽象结构处理机操纵设备控制器，提供命令和数据给控制器，由控制器操纵I&#x2F;O设备，使设备完成I&#x2F;O传输。     2. 设备控制器 控制器的功能  接收和识别CPU命令 数据交换：CPU与控制器、控制器与设备 对设备传来的数据进行差错检测 设备状态的了解和报告 设备地址识别 缓冲">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/007.jpg">
<meta property="article:published_time" content="2020-12-31T04:03:00.000Z">
<meta property="article:modified_time" content="2021-03-26T04:54:51.277Z">
<meta property="article:author" content="Jay">
<meta property="article:tag" content="961">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jayyy1.gitee.io/images/pictures/cartoons/007.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jay1zhang.github.io/2020/12/31/BUAA/Operating%20System/%E3%80%8C%E7%B3%BB%E7%BB%9F%E3%80%8D03-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKEK6XV2V5","apiKey":"e093fbb9f29fdf5c7ddd56ec43e9ae05","indexName":"Jay","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-26 12:54:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">50</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/007.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J1z's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「系统」03-设备管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-31T04:03:00.000Z" title="Created 2020-12-31 12:03:00">2020-12-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-26T04:54:51.277Z" title="Updated 2021-03-26 12:54:51">2021-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/">BUAA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/Operating-System/">Operating System</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>26min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter3-设备管理（I-O管理）"><a href="#Chapter3-设备管理（I-O管理）" class="headerlink" title="Chapter3 - 设备管理（I/O管理）"></a>Chapter3 - 设备管理（I/O管理）</h1><p>[TOC]</p>
<h2 id="0x00-I-O管理概述"><a href="#0x00-I-O管理概述" class="headerlink" title="0x00 I/O管理概述"></a>0x00 <strong>I/O管理概述</strong></h2><p>略</p>
<h2 id="0x01-I-O硬件组成"><a href="#0x01-I-O硬件组成" class="headerlink" title="0x01 I/O硬件组成"></a>0x01 I/O硬件组成</h2><h3 id="1-I-O系统抽象结构"><a href="#1-I-O系统抽象结构" class="headerlink" title="1. I/O系统抽象结构"></a>1. I/O系统抽象结构</h3><p>处理机操纵<strong>设备控制器</strong>，提供命令和数据给控制器，由控制器操纵I/O设备，使设备完成I/O传输。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923175352019.png" alt="image-20200923175352019" style="zoom:70%;" />



<h3 id="2-设备控制器"><a href="#2-设备控制器" class="headerlink" title="2. 设备控制器"></a>2. 设备控制器</h3><ul>
<li><p><strong>控制器的功能</strong></p>
<ul>
<li><strong>接收和识别CPU命令</strong></li>
<li><strong>数据交换</strong>：CPU与控制器、控制器与设备</li>
<li>对设备传来的数据进行<strong>差错检测</strong></li>
<li>设备状态的了解和报告</li>
<li>设备地址识别</li>
<li><strong>缓冲区</strong></li>
</ul>
</li>
<li><p><strong>组成</strong></p>
<ul>
<li><strong>控制器与CPU接口</strong>：数据寄存器、控制寄存器、状态寄存器，采用内存映射或专门的I/O指令</li>
<li><strong>控制器与设备接口</strong>：数据信号、控制信号、状态信号</li>
<li><strong>I/O逻辑</strong>：用于实现CPU对I/O设备的控制</li>
</ul>
</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923174838947.png" alt="image-20200923174838947" style="zoom:80%;" />

<h3 id="3-I-O端口地址"><a href="#3-I-O端口地址" class="headerlink" title="3. I/O端口地址"></a>3. I/O端口地址</h3><p><strong>I/O端口地址</strong>：接口电路中<u>每个寄存器具有的唯一地址</u>。所有I/O端口地址形成I/O端口的地址空间（受OS保护）</p>
<p>I/O指令形式与I/O地址是相互关联的，主要有以下形式：</p>
<ul>
<li><p><strong>内存映像编址（内存映像I/O模式）</strong>：</p>
<ul>
<li>控制器的内存/寄存器作为物理内存空间的一部分</li>
</ul>
</li>
<li><p><strong>I/O独立编址（I/O专用指令）</strong>：</p>
<ul>
<li>Intel 体系架构in/out 指令</li>
</ul>
</li>
</ul>
<h4 id="内存映射I-O的特点"><a href="#内存映射I-O的特点" class="headerlink" title="内存映射I/O的特点"></a>内存映射I/O的特点</h4><ul>
<li><p>优点：</p>
<ul>
<li><strong>不需要特殊的保护机制</strong>来阻止用户进程进行相应的I/O 操作。<ul>
<li>操作系统要避免把包含了控制寄存器的那部分地址空间放入用户的虚拟地址空间中。</li>
</ul>
</li>
<li>可以引用内存的每一条指令都可以适用于引用控制寄存器。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>不允许</strong>对一个控制寄存器的内容进行<strong>高速缓存</strong>。<ul>
<li>如果我们把设备控制寄存器进行了 高速缓存，那么第一次引用的时候就把它 放入了高速缓存。 以后再对它的引用都是从高速缓存当中取值，而不会再去对设备进行相应的检测。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="I-O独立编址的特点"><a href="#I-O独立编址的特点" class="headerlink" title="I/O独立编址的特点"></a>I/O独立编址的特点</h4><ul>
<li><p>优点：</p>
<ul>
<li><strong>外设不占用内存的地址空间</strong></li>
<li>编程时，<strong>易于区分</strong>是对内存操作还是对I/O操作。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>I/O端口操作的<strong>指令类型少</strong>，<strong>操作不灵活</strong>。</li>
</ul>
</li>
</ul>
<h2 id="0x02-I-O控制方式"><a href="#0x02-I-O控制方式" class="headerlink" title="0x02 I/O控制方式"></a>0x02 I/O控制方式</h2><ul>
<li><p><strong>程序控制I/O(PIO,Programmed I/O)</strong></p>
</li>
<li><p><strong>中断驱动方式(Interrupt-driven I/O)</strong></p>
</li>
<li><p><strong>直接存储访问方式(DMA, Direct Memory Access)</strong></p>
</li>
<li><p><strong>通道技术（Channel）</strong></p>
</li>
</ul>
<h3 id="1-程序控制I-O"><a href="#1-程序控制I-O" class="headerlink" title="1. 程序控制I/O"></a>1. 程序控制I/O</h3><p>也称<strong>轮询</strong>或查询方式I/O，它由<strong>CPU</strong>代表进程向I/O模块发出指令， 然后进入<strong>忙等状态</strong>， 直到操作完成之后进程才能够继续执行。</p>
<ul>
<li>轮询方式的工作过程如下：</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923100727545.png" alt="image-20200923100727545" style="zoom:70%;" />

<p>① 应用程序提出了一个读数据的请求；</p>
<p>② 设备驱动程序<strong>检查设备的状态</strong>；</p>
<p>③ 如果状态正常，就给设备发出相应的<strong>控制命令</strong>；</p>
<p>④ 不断地去测试这个设备是否完成了这次执行过程，实际上就是一个<strong>轮询</strong>；</p>
<p>⑤ 设备控制器完成操作，把数据送给应用程序</p>
<p>⑥ 应用程序继续进行相应的处理。</p>
<ul>
<li>CPU与设备控制器的轮询流程如下：</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923101656809.png" alt="image-20200923101656809" style="zoom:75%;" />





<h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2. 中断"></a>2. 中断</h3><p>当I/O操作结束后由<strong>设备控制器</strong><u>主动地来通知设备驱动程序说这次结束</u>， 而不是设备驱动程序不断地去轮询看看设备的状态。</p>
<ul>
<li>中断驱动方式的工作流程如下：</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923103121830.png" alt="image-20200923103121830" style="zoom:70%;" />

<p>① 用户程序提出I/O请求；</p>
<p>② 设备驱动程序<strong>检查设备的状态</strong>；</p>
<p>③ 如果设备已经准备好，那么就向设备发出<strong>控制命令</strong>；</p>
<p>④ 将状态<strong>记录在设备状态表</strong>中，CPU继续其它工作。</p>
<p>⑤ 设备完成工作后<strong>向CPU发中断信号</strong>，转入中断处理程序； </p>
<p>⑥ 中断处理程序发现这是一个正常地完成了控制命令的信号后，把结果提交给<strong>设备管理程序</strong>；</p>
<p>⑦ 设备管理程序会<strong>从设备状态表里查询是哪一个请求的完成</strong>；</p>
<p>⑧ 把<strong>相应的数据送到应用程序</strong>；</p>
<p>⑨ 通知应用程序可以继续执行。</p>
<ul>
<li>中断驱动方式的处理过程如下：</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923103522116.png" alt="image-20200923103522116" style="zoom:75%;" />





<h3 id="3-DMA"><a href="#3-DMA" class="headerlink" title="3. DMA"></a>3. DMA</h3><p>直接存储器访问方式， 是由一个<strong>专门的控制器</strong>来完成数据从内存到设备或者是从设备到内存的传输工作。</p>
<ul>
<li>DMA的工作流程大致如下：</li>
</ul>
<p>① 主机将DMA命令块写入内存（命令块含有指向传输源的指针、传输目的地的指针、传输数据的总字节计数）；</p>
<p>② CPU将<strong>命令块地址</strong>写入DMA控制器，然后便去做其他工作（阻塞当前进程，调度执行其他进程）；</p>
<p>③ DMA控制器<strong>直接操作内存总线</strong>，按照地址内容，在总线上进行传输，完成内存与外设的成批数据交换，此时并不需要CPU干预；</p>
<p>④ 在操作完成时由DMA控制器向CPU发出中断。</p>
<ul>
<li>DMA控制器中的寄存器<ul>
<li><strong>命令/状态寄存器（CR）</strong>，用于接收从CPU发送来的I/O命令，或有关控制信息，或设备的状态。</li>
<li><strong>内存地址寄存器（MAR）</strong>，在输入时，它存放把数据从设备传送到内存的起始目标地址，在输出时，它存放由内存到设备的内存源地址。</li>
<li><strong>数据寄存器（DR）</strong>，用于暂存从设备到内存，或从内存到设备的数据。</li>
<li><strong>数据计数器（DC）</strong>，存放本次CPU要读或写的字（节）数。</li>
</ul>
</li>
</ul>
<ul>
<li>DMA处理的基本流程</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923145446788.png" alt="image-20200923145446788" style="zoom:80%;" />



<ul>
<li><p>DMA的优缺点：</p>
<ul>
<li>优点：<ul>
<li>CPU只需干预I/O操作的开始和结束，而后续成批的数据读写则无需CPU控制，适于高速设备。</li>
</ul>
</li>
<li>缺点：<ul>
<li>数据传送的方向、存放数据的内存地址及传送数据的长度等都由CPU控制，<strong>占用了CPU时间</strong>。</li>
<li>每个设备占用一个DMA控制器，当设备增加时，需要增加新的DMA控制器。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>中断方式与DMA方式的区别</strong>：</p>
<ul>
<li>中断方式是在<strong>数据缓冲区寄存器填满之后</strong>则发出中断；而DMA方式则是在所要求的转送的数据块<strong>全部传送结束时</strong>才发出中断，从而减少了CPU进行中断处理的次数。</li>
<li>中断控制方式的数据传送是在中断处理时<strong>由CPU控制完成</strong>的，由于是程序切换，需要保护和恢复现场；而DMA方式下是由<strong>DMA控制器控制</strong>完成的，在<strong>传输过程中不需要CPU干预</strong>，DMA控制器直接在主存和I/O设备之间传送数据，只有<strong>开始和结束</strong>才需要CPU干预。 </li>
<li>程序中断方式具有对<strong>异常事件</strong>的处理能力，而DMA控制方式适用于<strong>数据块</strong>的传输。</li>
</ul>
</li>
</ul>
<h3 id="4-通道"><a href="#4-通道" class="headerlink" title="4. 通道"></a>4. 通道</h3><blockquote>
<p>为了<strong>进一步减少CPU的干预</strong>，提高操作系统I/O效率，引入了“通道”技术。</p>
</blockquote>
<p>通道是一个<strong>独立于CPU的专管I/O控制的处理机</strong>，它控制设备与内存直接进行数据交换。</p>
<ul>
<li>基本思想：<ul>
<li>通道有自己的指令体系，可由通道指令组成的通道程序。通道程序通常由操作系统构造，放在<strong>内存</strong>中。</li>
<li>CPU仅需发出一条<strong>I/O指令</strong>给通道，说明要执行的I/O操作和要访问的I/O设备，通道接到指令后，就启动相应的通道程序来完成I/O操作，并在操作结束时向CPU发中断信号。</li>
<li>这样，通道与CPU分时使用内存，实现了CPU内部运算与I/O设备的<strong>并行</strong>工作。</li>
</ul>
</li>
<li>通道与DMA的原理几乎是一样的，CPU将“<strong>传输控制</strong>”的功能下放给通道后只负责“<strong>数据处理</strong>”功能。</li>
</ul>
<ul>
<li><p>通道的优缺点：</p>
<ul>
<li>优点：执行一个通道程序可以完成几组I/O操作，与DMA相比，减少了CPU干预。</li>
<li>缺点：费用较高</li>
</ul>
</li>
<li><p>通道种类：</p>
<ul>
<li><strong>字节多路通道</strong><ul>
<li>以字节为单位交叉工作：当为一台设备传送一个字节后，立即转去为另一它设备传送一个字节；</li>
<li>适用于连接打印机、终端等<strong>低速或中速</strong>的I/O设备。</li>
</ul>
</li>
<li><strong>数组选择通道</strong><ul>
<li>以“<strong>组方式</strong>”工作，每次传送一批数据，传送速率很高，但在<strong>一段时间只能为一台设备服务</strong>；</li>
<li>每当一个I/O请求处理完之后，就选择另一台设备并为其服务；</li>
<li>适用于连接磁盘、磁带等<strong>高速</strong>设备。</li>
</ul>
</li>
<li><strong>数组多路通道</strong><ul>
<li>综合了字节多路通道分时工作和选择通道传输速率高的特点；</li>
<li>其实质是：对通道程序<strong>采用多道程序设计技术</strong>，使得与通道连接的设备可以并行工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923152346513.png" alt="image-20200923152346513" style="zoom:80%;" />



<ul>
<li>通道与DMA的区别<ul>
<li>DMA方式下，数据的传送方向、存放数据的内存起始地址和数据块长度都<strong>由CPU控制</strong>；而通道是一个特殊的处理器，有自己的指令和程序，通过执行通道程序实现对数据传输的控制，所以通道具有<strong>更强的独立处理I/O的功能</strong>。 </li>
<li>DMA控制器通常只能控制一台或者少数几台同类设备；而一个<strong>通道可同时控制多种设备</strong>。</li>
</ul>
</li>
</ul>
<h2 id="0x03-I-O软件的组成"><a href="#0x03-I-O软件的组成" class="headerlink" title="0x03 I/O软件的组成"></a>0x03 I/O软件的组成</h2><h3 id="1-分层设计思想"><a href="#1-分层设计思想" class="headerlink" title="1. 分层设计思想"></a>1. 分层设计思想</h3><ul>
<li><strong>用户进程层</strong>执行输入输出系统调用，对I/O数据进行格式化，为假脱机输入输出做准备</li>
<li><strong>独立于设备的软件</strong>实现设备的命名、设备的保护、成块处理、缓冲技术和设备分配</li>
<li><strong>设备驱动程序</strong>设置设备寄存器、检查设备的执行状态</li>
<li><strong>中断处理程序</strong>负责I/O完成时，唤醒设备驱动程序进程，进行中断处理</li>
<li><strong>硬件层</strong>实现物理I/O的操作</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923154621277.png" alt="image-20200923154621277" style="zoom:67%;" />



<p>简化版如下：</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923154708379.png" alt="image-20200923154708379" style="zoom:67%;" />



<h3 id="2-设备独立性设计"><a href="#2-设备独立性设计" class="headerlink" title="2. 设备独立性设计"></a>2. 设备独立性设计</h3><p>为了实现设备独立性而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>这两个概念：</p>
<ul>
<li>在应用程序中，使用逻辑设备名称来<strong>请求使用</strong>某类设备，而系统在<strong>实际执行</strong>时，还必须使用物理设备名称。</li>
<li><strong>系统需具有将逻辑设备名称转换为某物理设备名称的功能</strong>，这非常类似于存储器管理所介绍的逻辑地址和物理地址的概念。</li>
</ul>
<p>在实现了设备独立性功能后，可带来以下<strong>好处</strong>：</p>
<ul>
<li><strong>设备分配时的灵活性</strong>。<ul>
<li>当进程以物理名称来请求使用指定设备时，如果该设备已经分配给其他进程或正在检修，而此时尽管还有几台其他的相同设备正在空闲，该进程仍然阻塞。</li>
<li>但若进程能够以逻辑设备名称来请求某类设备时，系统可立即将该类设备中的任一台分配给进程，仅当所有此类设备全部分配完毕时，进程才会阻塞。</li>
</ul>
</li>
<li><strong>易于实现I/O重定向</strong>。<ul>
<li>用于I/O操作的设备可以更换，而不必改变应用程序。</li>
</ul>
</li>
</ul>
<p>为了实现设备的独立性，系统必须设置一张<strong>逻辑设备表LUT</strong>(Logical Unit Table)，用于将应用程序中所使用的逻辑设备名映射为物理设备名。</p>
<ul>
<li>该表的每个表目中包含了三项，逻辑设备名、物理设备名、设备驱动程序的入口地址。</li>
<li>通过<strong>逻辑设备名</strong>，系统可以查找LUT，便<strong>可找到物理设备和驱动程序</strong>。</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923155524948.png" alt="image-20200923155524948" style="zoom:67%;" />



<p>LUT的设置可以采用<strong>两种方式</strong>：</p>
<ul>
<li><strong>在整个系统中设置一张LUT</strong><ul>
<li>由于系统中所有进程的设备分配情况都记录在同一张LUT中，因而不允许在LUT中具有相同的逻辑设备名，这就要求所有用户都不能使用相同的逻辑设备名，多用户下难以做到，单用户很好实现。</li>
</ul>
</li>
<li><strong>为每个用户设置一张LUT</strong><ul>
<li>每当用户登录时，便为该用户建立一个进程，同时建立一张LUT，并将该表放入进程的PCB中。</li>
</ul>
</li>
</ul>
<h3 id="3-设备驱动程序"><a href="#3-设备驱动程序" class="headerlink" title="3. 设备驱动程序"></a>3. 设备驱动程序</h3><ul>
<li><p>基本思想：</p>
<ul>
<li><strong>与设备密切相关</strong>的代码放在设备驱动程序中，<strong>每个设备驱动程序处理一种设备类型</strong>。 </li>
<li>设备驱动程序的任务是<strong>接收来自与设备无关的上层软件的抽象请求，并执行这个请求</strong>。 </li>
<li>每一个控制器都设有一个或多个设备寄存器，用来存放向设备发送的命令和参数。<strong>设备驱动程序负责释放这些命令，并监督它们正确执行</strong>。</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>I/O进程与设备控制器之间的通信程序</li>
<li>驱动程序与I/O设备的特性紧密相关</li>
<li>与I/O控制方式紧密相关</li>
<li>与硬件紧密相关</li>
</ul>
</li>
<li><p><strong>驱动程序的接口</strong></p>
<ul>
<li><p><strong>驱动程序初始化函数</strong></p>
<ul>
<li>向操作系统登记该驱动程序的接口函数，该初始化函数在系统启动时安<strong>装入内核执行</strong>。</li>
</ul>
</li>
<li><p><strong>驱动程序卸载函数</strong></p>
<ul>
<li>申请设备函数，释放设备函数。</li>
</ul>
</li>
<li><p><strong>I/O操作函数</strong></p>
<ul>
<li><p>调用该子程序是<strong>系统调用</strong>的结果。</p>
</li>
<li><blockquote>
<p>对独占设备，包含启动I/O的命令；对共享设备，将I/O请求挂入请求队列。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>中断处理函数</strong></p>
<ul>
<li><p>系统来<strong>接收硬件中断</strong>，再由<strong>系统调用</strong>中断服务子程序。</p>
</li>
<li><blockquote>
<p>I/O完成做善后处理，一般是唤醒等待刚完成I/O求的阻塞进程，时期能进一步做后续工作；如果存在I/O请求队列，则启动下一个I/O请求</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>驱动程序与应用程序的区别</strong></p>
<ul>
<li>应用程序以main开始；驱动程序没有main，它以一个模块初始化函数作为入口。</li>
<li>驱动程序完成初始化之后不再运行，等待系统调用；应用程序从头到尾执行一个任务。</li>
<li>驱动程序不能使用标准C库。</li>
</ul>
</li>
</ul>
<h2 id="0x04-I-O缓冲管理（重点）"><a href="#0x04-I-O缓冲管理（重点）" class="headerlink" title="0x04 I/O缓冲管理（重点）"></a>0x04 I/O缓冲管理（重点）</h2><p>缓冲技术可<strong>提高外设利用率</strong>。</p>
<ul>
<li>原因：<ul>
<li>匹配CPU与外设的不同处理速度</li>
<li>减少对CPU的中断次数。</li>
<li>提高CPU和I/O设备之间的并行性</li>
</ul>
</li>
</ul>
<h3 id="1-单缓冲（single-buffer）"><a href="#1-单缓冲（single-buffer）" class="headerlink" title="1. 单缓冲（single buffer）"></a>1. 单缓冲（single buffer）</h3><p>每当用户进程发出一个I/O请求时，操作系统便在主存中为之分配一个缓冲区，T、M，C的定义见下图：</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923161952200.png" alt="image-20200923161952200" style="zoom:75%;" />

<ul>
<li>由于<strong>T和C是可以并行的</strong>，当T&gt;C时，系统对每一块数据的处理时间为M+T；反之，为M+C。</li>
<li>即系统对每一块数据的处理时间为Max(C，T) + M。</li>
</ul>
<h3 id="2-双缓冲（double-buffer）"><a href="#2-双缓冲（double-buffer）" class="headerlink" title="2. 双缓冲（double buffer）"></a>2. 双缓冲（double buffer）</h3><p>两个缓冲区，CPU和外设都可以连续处理而无需等待对方，<strong>要求CPU和外设速度相近</strong>。</p>
<ul>
<li>如果C&lt;T，可使块**设备连续输入****；如果C&gt;T，则可使<strong>CPU不必等待</strong>设备输入。</li>
<li>即系统对每一块数据的处理时间可以粗略的认为是Max(C，T) 。</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923162150980.png" alt="image-20200923162150980" style="zoom:75%;" />



<h3 id="3-环形缓冲-circular-buffer"><a href="#3-环形缓冲-circular-buffer" class="headerlink" title="3. 环形缓冲(circular buffer)"></a>3. 环形缓冲(circular buffer)</h3><p>若CPU和外设的处理速度差较大，双缓冲效果不够理想，因此引入了多缓冲机制。</p>
<ul>
<li>组成<ul>
<li>多个缓冲区，在循环缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为<strong>三种类型</strong>，用于装输入数据的<strong>空缓冲区R</strong>、已<strong>装满数据的缓冲区G</strong>以及计算进程<strong>正在使用的工作缓冲区C</strong>。</li>
<li>多个指针，作为输入的缓冲区可设置<strong>三个指针</strong>，用于<strong>指示计算进程下一个可用缓冲区G的指针Nextg</strong>、<strong>指示输入进程下次可用的空缓冲区R的指针Nexti</strong>、以及用于<strong>指示计算进程正在使用的缓冲区C的指针Current</strong>。</li>
</ul>
</li>
</ul>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923163139638.png" alt="image-20200923163139638" style="zoom:75%;" />



<h3 id="4-缓冲池（buffer-pool）"><a href="#4-缓冲池（buffer-pool）" class="headerlink" title="4. 缓冲池（buffer pool）"></a>4. 缓冲池（buffer pool）</h3><p>为了提高缓冲区的利用率，引入缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。</p>
<ul>
<li>空闲缓冲区。</li>
<li>装满输入数据的缓冲区。</li>
<li>装满输出数据的缓冲区</li>
</ul>
<p>为了管理方便，将相同类型的缓冲区链成一个队列，形成了：空缓冲队列emq，输入队列inq，输出队列outq。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923163409012.png" alt="image-20200923163409012" style="zoom:80%;" />

<p>缓冲区可以在<strong>收容输入、提取输入、收容输出、提取输出</strong>四种工作方式下工作：</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923163501767.png" alt="image-20200923163501767" style="zoom:75%;" />

<ul>
<li><strong>收容输入</strong>：在输入进程需要输入数据时，便调用Getbuf(emp)过程，从空缓冲队列的队首取出一个空缓冲区，把它作为收容输入工作缓冲hin，然后，把数据输入其中，装满后再调用Putbuf(inq, hin)过程，将该缓冲区挂在输入队列上。</li>
<li><strong>提取输入</strong>：当计算进程需要输入数据时，调用Getbuf(inq)过程，从输入队列队首取出一个缓冲区，作为提取输入工作缓冲区sin，计算进程从中提取数据，计算进程用完该数据后，再调用Putbuf(emq, sin)过程，将该缓冲区挂到空缓冲队列emq上。</li>
<li><strong>收容输出</strong>：当计算进程需要输出时，调用Getbuf(emq)过程从空缓冲区队列emq的队首取出一个空缓冲区，作为收容输出工作缓冲区hout，当其中装满输出数据后，又调用Putbuf(outq, hout)过程，将该缓冲区挂在outq末尾。</li>
<li><strong>提取输出</strong>：由输出进程调用Getbuf(outq)过程，从输出队列队首取出一个装满输出数据的缓冲区，作为提取输出工作缓冲区sout，在数据提取完后，再调用Putbuf(emq, sout)过程，将该缓冲区挂在空缓冲队列末尾。</li>
</ul>
<h2 id="0x05-I-O设备管理"><a href="#0x05-I-O设备管理" class="headerlink" title="0x05 I/O设备管理"></a>0x05 I/O设备管理</h2><h3 id="1-I-O设备分配"><a href="#1-I-O设备分配" class="headerlink" title="1. I/O设备分配"></a>1. I/O设备分配</h3><p>由于设备、通道资源的有限性，进程必须首先向设备管理程序提出资源申请，然后由设备分配程序根据相应的分配算法为进程分配资源。</p>
<ul>
<li>两种常见作法：<ul>
<li>在进程间切换使用外设，如键盘和鼠标；</li>
<li>通过一个虚拟设备把外设与应用进程隔开，只由虚拟设备来使用设备</li>
</ul>
</li>
</ul>
<h3 id="2-设备分配用数据结构"><a href="#2-设备分配用数据结构" class="headerlink" title="2. 设备分配用数据结构"></a>2. 设备分配用数据结构</h3><h4 id="1）设备控制表（DCT-Device-Control-Table）"><a href="#1）设备控制表（DCT-Device-Control-Table）" class="headerlink" title="1）设备控制表（DCT, Device Control Table）"></a>1）设备控制表（DCT, Device Control Table）</h4><p>每个设备一张，反映设备的特性、设备和控制器的连接情况。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923164251225.png" alt="image-20200923164251225" style="zoom:80%;" />

<ul>
<li>DCT说明<ul>
<li><strong>设备队列队首指针</strong>：凡因为请求本设备而未得到满足的进程，其PCB都应按照一定的策略排成一个队，称该队列为设备请求队列或简称设备队列，其队首指针指向<strong>队首PCB</strong>；</li>
<li><strong>设备状态</strong>：当设备处于使用状态时，应该设备设置为忙/闲标志置为1；</li>
<li><strong>控制器表指针</strong>：该指针指向该设备所连接的控制器的控制表；</li>
<li><strong>重复执行次数</strong>：外部设备在传送数据时，较容易发生数据传送错误。在许多系统中，如果发生传送错误，并不立即认为传送失败，而是令它重传，并由系统规定设备在工作中发生错误时应重复执行的次数。</li>
</ul>
</li>
</ul>
<h4 id="2）系统设备表（SDT-system-device-table）"><a href="#2）系统设备表（SDT-system-device-table）" class="headerlink" title="2）系统设备表（SDT, system device table）"></a>2）系统设备表（SDT, system device table）</h4><p>在整个系统中只有一张，它记录被连接到系统中的所有物理设备的情况，并为每个物理设备设一表目项。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923164913677.png" alt="image-20200923164913677" style="zoom:80%;" />

<ul>
<li>SDT说明<ul>
<li>DCT指针：指向相应设备的DCT；</li>
<li>设备使用进程标识：正在使用该设备的进程标识；</li>
<li>DCT信息：为引用方便而保存的DCT信息，如：设备标识、设备类型等；</li>
</ul>
</li>
</ul>
<h4 id="3）控制器控制表（COCT-COntroller-Control-Table）"><a href="#3）控制器控制表（COCT-COntroller-Control-Table）" class="headerlink" title="3）控制器控制表（COCT, COntroller Control Table）"></a>3）控制器控制表（COCT, COntroller Control Table）</h4><p>每个设备控制器一张，反映I/O控制器的配置和状态以及和通道的连接情况等。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923164946343.png" alt="image-20200923164946343" style="zoom:80%;" />



<h4 id="4）通道控制表（CHCT-CHannel-Control-Table）"><a href="#4）通道控制表（CHCT-CHannel-Control-Table）" class="headerlink" title="4）通道控制表（CHCT, CHannel Control Table）"></a>4）通道控制表（CHCT, CHannel Control Table）</h4><p>每个通道一张，描述通道工作状态。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923165007523.png" alt="image-20200923165007523" style="zoom:80%;" />



<h3 id="3-设备分配的原则"><a href="#3-设备分配的原则" class="headerlink" title="3. 设备分配的原则"></a>3. 设备分配的原则</h3><ul>
<li><strong>设备固有属性</strong>：独享、共享、虚拟设备</li>
<li><strong>设备分配算法</strong>：先来先服务、优先级高者优先</li>
<li><strong>设备分配中的安全性</strong>：死锁问题<ul>
<li><strong>安全分配（同步）</strong>：在设备分配中<strong>防止</strong>死锁，进程发出I/O请求之后，进入阻塞，直到I/O完成。CPU和I/O串行工作，打破了死锁条件，但是效率低。</li>
<li><strong>不安全分配（异步）</strong>：设备在分配时不考虑可能产生的死锁，进程发出I/O请求后，仍然继续运行，可继续请求其他I/O设备。需要进行<strong>安全性检查</strong>，但进程执行效率相对较高</li>
</ul>
</li>
</ul>
<h3 id="4-设备分配策略"><a href="#4-设备分配策略" class="headerlink" title="4. 设备分配策略"></a>4. 设备分配策略</h3><h4 id="1）单（多）通路I-O系统的设备分配"><a href="#1）单（多）通路I-O系统的设备分配" class="headerlink" title="1）单（多）通路I/O系统的设备分配"></a>1）单（多）通路I/O系统的设备分配</h4><p><strong>单（多）通路</strong>：一个设备对应一（多）个控制器，一个控制器对应一（多）个通道。</p>
<ol>
<li><p><strong>分配设备</strong></p>
<p>根据物理设备名查找系统设备表SDT，从中找到设备控制器表DCT，如果设备忙，则进入等待队列；否则，计算是否产生死锁，进行分配。</p>
</li>
<li><p><strong>分配设备控制器</strong></p>
<p>将设备分配给进程后，在DCT中找到该设备相连的设备控制器表COCT，如果控制器空闲，则分配；否则，进入等待队列。</p>
</li>
<li><p><strong>分配通道</strong></p>
</li>
<li><p>从COCT中找到相连的通道控制表CHCT，如果通道空闲，则分配，否则，进入等待队列。</p>
</li>
</ol>
<h4 id="2）用户空间的I-O软件：SPOOLing技术（重点）"><a href="#2）用户空间的I-O软件：SPOOLing技术（重点）" class="headerlink" title="2）用户空间的I/O软件：SPOOLing技术（重点）"></a>2）用户空间的I/O软件：SPOOLing技术（重点）</h4><blockquote>
<p>在多道程序系统中，专门利用一道程序（SPOOLing程序）来完成对设备的I/O操作，<strong>无需使用外围I/O处理机</strong>。</p>
</blockquote>
<p>SPOOLing, (Simultaneous Peripheral Operation OnLine)，也称为<strong>虚拟设备技术</strong>可<u>把独享设备转变成具有共享特征的虚拟设备</u>，从而提高设备利用率。</p>
<h5 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h5><ul>
<li>SPOOLing程序和外设进行数据交换：<ul>
<li>SPOOLing程序预先从外设读取数据并加以缓冲，在以后需要的时候输入到应用程序；</li>
<li>SPOOLing程序接受应用程序的输出数据并加以缓冲，在以后适当的时候输出到外设。</li>
</ul>
</li>
<li>应用程序进行I/O操作时，<strong>只是和SPOOLing程序交换数据</strong>（从SPOOLing程序的缓冲池中读出数据或把数据送入缓冲池），而不是跟实际的外设进行I/O操作，称为“<strong>虚拟I/O</strong>”。</li>
</ul>
<h5 id="SPOOLing系统组成"><a href="#SPOOLing系统组成" class="headerlink" title="SPOOLing系统组成"></a>SPOOLing系统组成</h5><img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923170400180.png" alt="image-20200923170400180" style="zoom:75%;" />

<ul>
<li><strong>输入井和输出井</strong>，这是在磁盘上开辟的两个大存储空间。<ul>
<li>输入井是模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据；</li>
<li>输出井是模拟脱机输出时的磁盘设备，用于暂存用户程序和输出数据。</li>
</ul>
</li>
<li><strong>输入缓冲区和输出缓冲区</strong>，<strong>缓和CPU与磁盘之间速度不匹配</strong>，在内存中开辟的两个缓冲区。<ul>
<li>输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井；</li>
<li>输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备。</li>
</ul>
</li>
<li><strong>输入进程SPi和输出进程SPo</strong>，利用两个进程来<strong>模拟脱机I/O时的外围控制机</strong>。<ul>
<li>进程SPi模拟脱机输入时的外围控制机，将用户要求的数据<strong>从输入机通过输入缓冲区再送到输入井</strong>，当CPU需要输入数据时，直接<strong>从输入井读入内存</strong>；</li>
<li>进程SPo模拟脱机输出时的外围控制机，将用户要求输出的数据先<strong>从内存送到输出井</strong>，待输出<strong>设备空闲</strong>时，再将<strong>输出井中的数据经过输出缓冲区送到输出设备</strong>上。</li>
</ul>
</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li><p><strong>高速虚拟I/O操作</strong>：</p>
<ul>
<li>一方面，应用程序的虚拟I/O比实际I/O速度提高，缩短应用程序的执行时间。</li>
<li>另一方面，程序的虚拟I/O操作时间和实际I/O操作时间分离开来。</li>
</ul>
</li>
<li><p><strong>实现对独享设备的共享</strong>：</p>
<ul>
<li>由SPOOLing程序提供虚拟设备，可以<strong>对独享设备依次共享使用</strong>。</li>
</ul>
</li>
</ul>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>打印机设备和可由<strong>打印机管理器</strong>管理的打印作业队列。</p>
<blockquote>
<p>例如：Windows NT中，应用程序直接向针式打印机输出需要15分钟，而向打印作业队列输出只需要1分钟，此后用户可以关闭应用程序而转入其他工作，在以后适当的时候由打印机管理器完成15分钟的打印输出而无需用户干预。</p>
</blockquote>
<h2 id="0x06-I-O性能问题"><a href="#0x06-I-O性能问题" class="headerlink" title="0x06 I/O性能问题"></a>0x06 I/O性能问题</h2><p>解决I/O性能问题的两个途径：</p>
<ul>
<li><p><strong>使CPU利用率尽可能不被I/O降低</strong></p>
<ul>
<li>可以使用缓冲技术减少或<strong>缓解速度差异</strong>，同时使用<strong>异步I/O</strong>使CPU不等待 I/O。</li>
</ul>
</li>
<li><p><strong>使CPU尽可能摆脱I/O</strong></p>
<ul>
<li>使用<strong>DMA、通道</strong>等I/O部件让CPU<strong>摆脱I/O操作</strong>的影响</li>
</ul>
</li>
</ul>
<h2 id="0x07-I-O操作过程"><a href="#0x07-I-O操作过程" class="headerlink" title="0x07 I/O操作过程"></a>0x07 I/O操作过程</h2><p><strong>从系统调用的开始到系统调用结束经过的步骤：</strong></p>
<p>① 进程向内核发起一个系统调用；</p>
<p>② 内核接收到系统调用，知道是对文件的请求，于是告诉磁盘，把文件读取出来；</p>
<p>③ 磁盘接收到来着内核的命令后，把文件载入到内核的内存空间里面；</p>
<p>④ 内核的内存空间接收到数据之后，把数据copy到用户进程的内存空间(此过程是I/O发生的地方)；</p>
<p>⑤ 进程内存空间得到数据后，给内核发送通知；</p>
<p>⑥ 内核把接收到的通知回复给进程，此过程为唤醒进程，然后进程得到数据，进行下一步操作。</p>
<p>all in all，I/O操作主要分为两个步骤:</p>
<ol>
<li><strong>磁盘把数据装载进内核的内存空间</strong></li>
<li><strong>内核的内存空间的数据copy到用户的内存空间中</strong></li>
</ol>
<p>有如下五种方式。</p>
<h3 id="1-阻塞I-O"><a href="#1-阻塞I-O" class="headerlink" title="1. 阻塞I/O"></a>1. 阻塞I/O</h3><p>阻塞I/O是指调用结果返回之前，当前线程会被<strong>挂起</strong>(线程进入睡眠状态) 。函数只有在得到结果之后，才会返回，才能继续执行。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923173220818.png" alt="image-20200923173220818" style="zoom:80%;" />



<h3 id="2-非阻塞I-O"><a href="#2-非阻塞I-O" class="headerlink" title="2. 非阻塞I/O"></a>2. 非阻塞I/O</h3><p>进程发起I/O调用，I/O自己知道需过一段时间完成，就立即通知进程进行别的操作，则为非阻塞I/O。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923173303923.png" alt="image-20200923173303923" style="zoom:80%;" />



<h3 id="3-I-O多路复用"><a href="#3-I-O多路复用" class="headerlink" title="3. I/O多路复用"></a>3. I/O多路复用</h3><p><strong>I/O多路复用</strong></p>
<ul>
<li>工作进程调用一个管理I/O的特殊库函数，此库函数可以接受并管理多个I/O请求，工作进程则可以同时等待多个I/O请求，虽然是阻塞，但是阻塞在多个进程上，可以提高效率。第二阶段依然需要工作进程参与库函数<strong>把内核空间数据复制到用户空间</strong>，第二阶段依旧<strong>阻塞</strong>。</li>
</ul>
<p>原本进程和系统内核直接沟通，现在在中间加一个i/o复用select。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923173418093.png" alt="image-20200923173418093" style="zoom:80%;" />





<h3 id="4-事件（信号）驱动I-O"><a href="#4-事件（信号）驱动I-O" class="headerlink" title="4. 事件（信号）驱动I/O"></a>4. 事件（信号）驱动I/O</h3><p>进程发起调用，通过<strong>回调函数</strong>，内核会记住是哪个进程申请的，一旦第一段完成了，就可以向这个进程发起通知，这样<strong>第一段就是非阻塞的</strong>，进程不需要盲等了，但是<strong>第二段依然是阻塞的</strong>。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923173635891.png" alt="image-20200923173635891" style="zoom:80%;" />



<h3 id="5-异步I-O"><a href="#5-异步I-O" class="headerlink" title="5. 异步I/O"></a>5. 异步I/O</h3><p>无论第一第二段，不再向系统调用提出任何反馈，只有数据完全复制到服务进程内存中后，才向服务进程返回ok的信息，其它时间，进程可以随意做自己的事情，直到内核通知ok信息。</p>
<img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923173808606.png" alt="image-20200923173808606" style="zoom:80%;" />



<h3 id="五种模型对比"><a href="#五种模型对比" class="headerlink" title="五种模型对比"></a>五种模型对比</h3><img src="http://jayyy1.gitee.io/images/posts/BUAA/image-20200923173817710.png" alt="image-20200923173817710" style="zoom:80%;" />

<ul>
<li><strong>同步阻塞</strong>：<ul>
<li>两段都是阻塞的，所有数据准备完成后才响应。</li>
</ul>
</li>
<li><strong>同步非阻塞</strong><ul>
<li>磁盘从磁盘复制到内核内存中的时候, 不停询问内核数据是否准备完成。<strong>盲等性能有可能更差</strong> ,看上去他可以做别的事情了, 但是其实在不停的循环。</li>
<li>缺点：<strong>无法处理多个I/O</strong>,比如用户打开文件,ctrl+C想终止这个操作,是无法停掉的。</li>
</ul>
</li>
<li><strong>同步IO</strong>：<ul>
<li>如果第二段是阻塞的 ,代表是同步的。</li>
</ul>
</li>
<li><strong>异步IO</strong>：<ul>
<li>内核后台自己处理 ,把大量时间拿来处理用户请求</li>
</ul>
</li>
</ul>
<h2 id="考点积累"><a href="#考点积累" class="headerlink" title="考点积累"></a>考点积累</h2><h3 id="知识点积累"><a href="#知识点积累" class="headerlink" title="知识点积累"></a>知识点积累</h3><ul>
<li>用户程序发出磁盘I/O请求后，系统正确的处理流程是：用户程序 -&gt; 系统调用处理程序 -&gt; <strong>设备驱动程序 -&gt; 中断处理程序</strong> -&gt; 硬件</li>
<li>I/O交通管制程序的主要挂能是管理<strong>设备、控制器和通道</strong>的状态信息。</li>
<li>SPOOLING技术时操作系统中采用的一种将独占设备改造为共享设备的技术，其有效减少了进程等待读入/独处信息的时间，加快了作业的执行速度，并提高了处理器与通道并行工作的能力。</li>
<li>字符设备的基本特征是<strong>不可寻址到字节</strong>；共享设备是指<strong>同一时间段内</strong>允许多个进程同时访问的设备。</li>
<li>在分配独占设备时可能引起死锁，在分配共享设备时不会引起进程死锁。</li>
<li>I/O通道是一种特殊的处理机，它具有执行I/O指令的能力，通过执行通道程序来控制I/O操作，用于<strong>完成主存和外设之间的信息传输</strong>。</li>
<li>通常，一个CPU可以连接多个通道，一个通道连接多个设备控制器，一个设备控制器连接多个设备。因而，设备分配的过程是<strong>先分配设备，再分配控制器，最后分配通道</strong>。</li>
<li>虚拟设备是指使用虚拟技术把独占设备改造成为多用户共享的设备，也就要把一台具体的物理设备变换为若干个逻辑设备。</li>
<li>设备独立性是指<strong>用户程序独立于物理设备的一种特性</strong>，引入设备的独立性是为了<strong>提高设备分配的灵活性和设备的利用率</strong>等。</li>
<li>为了实现逻辑设备名到物理设备名的映射，系统必须设置一张逻辑设备表LUT，能够将应用程序中所使用的的逻辑设备名映射成物理设备名，并提高该设备驱动程序的入口地址。</li>
<li>缓冲技术能解决设备间传送速率不匹配问题；虚拟技术能提高外设的利用率。</li>
<li><strong>中断屏蔽</strong>可以影响中断响应次序。</li>
<li>构成SPOOLING系统的基本条件是要有大容量、高速度的外设作为输入井和输出井，同时利用SPOOLING技术，进城不必等待I/O操作的完成，提高了系统和I/O设备的利用率。</li>
<li>假设从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一数据块的处理时间为C。可把系统对每一块数据的处理时间表示为 MAX(C, T) + M。</li>
</ul>
<ul>
<li>缓冲区由缓冲头部和缓冲体组成</li>
<li>设备驱动程序是一种低级的系统例程，它通常分为<strong>驱动I/O设备工作程序</strong>和<strong>设备中断处理程序</strong>。</li>
<li>进行设备分配时所需的数据结构主要有<strong>设备控制表、系统设备表、控制器控制表、通道控制表</strong>。</li>
<li>在通道进行I/O操作期间，要访问两个内存固定的单元<strong>通道地址字和通道状态字</strong>。</li>
<li>为了记录设备的分配情况，操作系统应设置一张系统设备表SDT和3个控制块：<strong>设备控制块、控制器控制块和通道控制块</strong>。</li>
<li>磁盘的驱动调度先进行<strong>移臂或查找时间优化调度</strong>，再进行<strong>旋转或等待时间优化</strong>调度。</li>
<li>为实现CPU与外部设备的并行工作，系统引入了<strong>通道和中断</strong>硬件机制。</li>
<li>列举I/O控制的四种方式：<strong>程序直接控制方式、DMA、中断驱动方式、通道控制方式</strong>。</li>
<li>通道技术的引入，实现了CPU与设备、设备与设备、进程与进程的并行。</li>
<li>逻辑设备表LUT的主要功能室<strong>实现设备的独立性和设备的灵活性</strong>。</li>
<li>设备管理中引入缓冲机制主要是为了<strong>改善CPU和I/O之间速度不匹配的矛盾、实现I/O设备之间的并行性、有效减少I/O次数</strong>。</li>
<li>*实现虚拟设备的条件：硬件上必须配置大容量的磁盘，要有中断装置和通道或DMA，具有CPU与通道或DMA并行工作的能力。<ul>
<li>感觉答案有点问题</li>
</ul>
</li>
<li>采用SPOOLING技术，操作员只要启动<strong>预输入</strong>程序工作，就可以把作业存放到<strong>输入井</strong>中等待处理。</li>
<li>I/O中断是使CPU和通道协调工作的一种手段，通道借助I/O中断<strong>请求CPU进行干预</strong>，CPU根据I/O中断时间了解<strong>输入输出操作</strong>的执行情况。</li>
<li>在中断驱动方式中，CPU是以<strong>字节</strong>为单位对I/O进行干预的；DMA是以<strong>数据块</strong>为单位进行干预的；I/O通道是以<strong>一组数据块</strong>为单位进行干预的。</li>
<li>按照信息交换的单位划分，I/O设备可以分为<strong>字符型设备和块设备</strong>。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Jay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://jay1zhang.github.io/2020/12/31/BUAA/Operating%20System/%E3%80%8C%E7%B3%BB%E7%BB%9F%E3%80%8D03-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">http://jay1zhang.github.io/2020/12/31/BUAA/Operating%20System/%E3%80%8C%E7%B3%BB%E7%BB%9F%E3%80%8D03-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/961/">961</a></div><div class="post_share"><div class="social-share" data-image="http://jayyy1.gitee.io/images/pictures/cartoons/007.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/31/BUAA/Operating%20System/%E3%80%8C%E7%B3%BB%E7%BB%9F%E3%80%8D05-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"><img class="prev-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/040.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">「系统」05-文件管理</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/31/BUAA/Operating%20System/%E3%80%8C%E7%B3%BB%E7%BB%9F%E3%80%8D02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><img class="next-cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/020.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">「系统」02-进程管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/12/31/BUAA/Computer Network/「计网」03-数据链路层/" title="「计网」03-数据链路层"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/026.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「计网」03-数据链路层</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer Network/「计网」07-IPv6协议/" title="「计网」07-IPv6协议"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/010.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「计网」07-IPv6协议</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer Network/「计网」02-物理层/" title="「计网」02-物理层"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/001.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「计网」02-物理层</div></div></a></div><div><a href="/2020/12/31/BUAA/Computer Network/「计网」01-概述/" title="「计网」01-概述"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/003.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「计网」01-概述</div></div></a></div><div><a href="/2020/12/31/BUAA/Operating System/「系统」00-概述/" title="「系统」00-概述"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/003.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「系统」00-概述</div></div></a></div><div><a href="/2020/12/31/BUAA/Operating System/「系统」04-磁盘管理/" title="「系统」04-磁盘管理"><img class="cover" src="http://jayyy1.gitee.io/images/pictures/cartoons/007.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-31</div><div class="title">「系统」04-磁盘管理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%88I-O%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-text">Chapter3 - 设备管理（I&#x2F;O管理）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-text">0x00 I&#x2F;O管理概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-I-O%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-text">0x01 I&#x2F;O硬件组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-I-O%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-text">1. I&#x2F;O系统抽象结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">2. 设备控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-I-O%E7%AB%AF%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="toc-text">3. I&#x2F;O端口地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84I-O%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">内存映射I&#x2F;O的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">I&#x2F;O独立编址的特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">0x02 I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6I-O"><span class="toc-text">1. 程序控制I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD"><span class="toc-text">2. 中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DMA"><span class="toc-text">3. DMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%9A%E9%81%93"><span class="toc-text">4. 通道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-I-O%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">0x03 I&#x2F;O软件的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">1. 分层设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-text">2. 设备独立性设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">3. 设备驱动程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-I-O%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">0x04 I&#x2F;O缓冲管理（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E7%BC%93%E5%86%B2%EF%BC%88single-buffer%EF%BC%89"><span class="toc-text">1. 单缓冲（single buffer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E7%BC%93%E5%86%B2%EF%BC%88double-buffer%EF%BC%89"><span class="toc-text">2. 双缓冲（double buffer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2-circular-buffer"><span class="toc-text">3. 环形缓冲(circular buffer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%93%E5%86%B2%E6%B1%A0%EF%BC%88buffer-pool%EF%BC%89"><span class="toc-text">4. 缓冲池（buffer pool）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-I-O%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-text">0x05 I&#x2F;O设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-I-O%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="toc-text">1. I&#x2F;O设备分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">2. 设备分配用数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8%EF%BC%88DCT-Device-Control-Table%EF%BC%89"><span class="toc-text">1）设备控制表（DCT, Device Control Table）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8%EF%BC%88SDT-system-device-table%EF%BC%89"><span class="toc-text">2）系统设备表（SDT, system device table）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8%EF%BC%88COCT-COntroller-Control-Table%EF%BC%89"><span class="toc-text">3）控制器控制表（COCT, COntroller Control Table）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8%EF%BC%88CHCT-CHannel-Control-Table%EF%BC%89"><span class="toc-text">4）通道控制表（CHCT, CHannel Control Table）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">3. 设备分配的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">4. 设备分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%8D%95%EF%BC%88%E5%A4%9A%EF%BC%89%E9%80%9A%E8%B7%AFI-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="toc-text">1）单（多）通路I&#x2F;O系统的设备分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84I-O%E8%BD%AF%E4%BB%B6%EF%BC%9ASPOOLing%E6%8A%80%E6%9C%AF%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">2）用户空间的I&#x2F;O软件：SPOOLing技术（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-text">基本思想：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SPOOLing%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-text">SPOOLing系统组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-text">举例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-I-O%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">0x06 I&#x2F;O性能问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-I-O%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">0x07 I&#x2F;O操作过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9EI-O"><span class="toc-text">1. 阻塞I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="toc-text">2. 非阻塞I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">3. I&#x2F;O多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8B%E4%BB%B6%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89%E9%A9%B1%E5%8A%A8I-O"><span class="toc-text">4. 事件（信号）驱动I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BC%82%E6%AD%A5I-O"><span class="toc-text">5. 异步I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-text">五种模型对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B9%E7%A7%AF%E7%B4%AF"><span class="toc-text">考点积累</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF"><span class="toc-text">知识点积累</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(http://jayyy1.gitee.io/images/pictures/cartoons/012.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jay</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>